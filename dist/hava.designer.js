angular.module("designer.app-scope", [])
.factory("$appScope", [function() {
  return {
    // The scope of page
    topScope: function() {
      return this.scope(document);
    },

    // Help us safely apply a change to a variable
    safeApply: function(fn, $scope) {
      $scope = $scope || this.topScope();
      fn = fn || function() {};
      if ($scope.$root.$$phase) {
        fn();
      } else {
        $scope.$apply(function() { fn(); });
      }
    }
  };
}]);

angular.module('designer.configuration', [])
.value('DesignerConfig', {
  default: {
    showControls:     true,  // Show canvas controls and view options
    showExport:       true,  // Show sharing and export buttons
    showAttributes:   true,  // Show the attributes bar
    fitToContent:     false, // Calls the jointjs fitToContent on load (TODO: tbh I can't remember what this does right now)
    showLabels:       false, // Show the labels on load
    showConnections:  false, // Show the connections on load
    showRevisions:    true,  // Show the revision list
    loadConnections:  true,  // Whether to load connections at all, used to improve the speed of renders of we don't need connections
    loadBadges:       true,  // Whether to load badges on resources, to improve the speed of thumbnail renders that don't require them
    showIsometric:    false, // Load the isometric diagram on load
    highlightDeleted: null,  // A comma separated list of deleted resources to be highlighted
    highlightAdded:   null,  // A comma separated list of added resources to be highlighted
    autohide:         false, // Automatically hides the attribute bar if nothing is selected
    defaultView:      null,  // The default view to load in the viewer, otherwise it selects the first it finds
    exportFormats:    [],    // List of formats allowed in the export panel
    watermark:        false, // Display watermark on the workspace
    allowableViews:   [],    // TODO: a temp value that let's us define allowable views in the dropdown. This should be handled by the API ideally
    allowEmbed:       false, // Allow the users to embed their environments in external pages
    showIcons:        true,  // Show the icon select options
    iconsPath:        "",    // Location of the icons (can be local or remote)
    imagesPath:       "",    // Location of the images (can be local or remote)
    iconSet:          null,  // The default icon to load in the viewer, otherwise it selects the first it finds
    show3DView:       false, // Boolean flag for toggling the 3D view on and off
    enable3DView:     false, // This flag is used to enabled/disable 3D view feature
    enableShare:      false, // Temporary feature flag to enable sharing
    embeddableHost:   "",    // The host where the embeddable viewer is found
    hideDefaultArrows: false,// Hide default arrows on AWS security views
    hideNamespaces:   true,  // Hide default namespaces in kubernetes

    // Override defaults for the layout
    layout: null,

    // The function to call when retrieving search results. By default returns an empty result set.
    searchMethod:     function () {
      return { "recordsTotal": 0, "recordsFiltered": 0, "data": [] }
    }
  },

  overrides: {},

  set: function(k, v) {
    this.overrides[k] = v;
  },

  get: function(k) {
    if (this.overrides.hasOwnProperty(k)) {
      return this.overrides[k];
    }

    return this.default[k];
  },

  full: function() {
    return Object.assign(this.default, this.overrides);
  },

  reset: function() {
    this.overrides = {};
  }
});

// Fix: http://jointjs.com/blog/get-transform-to-element-polyfill.html
SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function(toElement) {
  return toElement.getScreenCTM().inverse().multiply(this.getScreenCTM());
};

angular.module("designer", [
  "designer.configuration",
  "designer.state",
  "designer.workspace",
  "designer.model.environment",
  "designer.app-scope",
  'designer.workspace.layout'
])
.directive("designer", ["Environment", "$appScope", "DesignerConfig", "DesignerState",
  function (Environment, $appScope, DesignerConfig, DesignerState) {
  return {
    templateUrl: "/designer/designer.html",
    scope: {
      model: "="
    },
    controllerAs: 'Designer',
    bindToController: true,
    controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
      this.$onInit = function() {
        DesignerState.loadFromConfig(DesignerConfig);
        this.show_controls = DesignerConfig.get("showControls");
        this.show_export = DesignerConfig.get("showExport");
        this.show_sidebar = DesignerConfig.get("showAttributes");
        this.watermarked = DesignerConfig.get("watermark");

        // Select a default view
        if(!DesignerConfig.get("defaultView")) {
          DesignerState.selectDefaultView(this.model["views"]);
        }

        this.environment = Environment.load(this.model, DesignerState.get("selectedView"));
      };

      this.iconsLoaded = function() {
        $scope.$broadcast("icons:loaded");
      };
    }],
    link: function(scope, element, attrs, ctrl) {
      scope.$on("environment:reload", function(evt, environment, params) {
        $appScope.safeApply(function() {
          // If we have no selected view, or it doesn't exist, make sure we reselect it
          let reselect_view = !DesignerState.get("selectedView") || !_.find(environment.views, (v) => v.type === DesignerState.get("selectedView"))

          // Make sure we select an appropriate view from the new environment
          if(reselect_view)
            DesignerState.selectDefaultView(environment["views"]);

          // Handle import events - either alert them, or auto refresh
          ctrl.model       = environment;
          ctrl.environment = Environment.load(ctrl.model, DesignerState.get("selectedView"));

          scope.$broadcast("environment:reloaded", environment, params);
        }, scope);

        scope.$watch(function() { return element.hasClass("apogee"); }, function(hasApogee) {
          if (!hasApogee && ctrl.watermarked) {
            element.addClass("apogee");
          }
        });
      });

      scope.$on("view:positioned", function(e, view_type, positions) {
        if (ctrl.environment.current_view.type !== view_type) return;

        if (ctrl.environment.current_view.positioned) {
          ctrl.environment.current_view.reposition(ctrl.environment, positions);
          scope.$broadcast("view:repositioned");
        }
        else {
          ctrl.environment.current_view.load_with_positions(ctrl.environment, positions);
          scope.$broadcast("view:ready");
        }
      });
    }
  };
}]);

angular.module('designer.state', [])
.value('DesignerState', {
  default: {
    selectedView: null,
    displayLabels: false,
    displayConnections: false,
    displayIsometric: false,
    display3DView: false,
    hideDefaultArrows: false,
    hideNamespaces: true,
    highlightTagged: false,
    selectedIconSet: "",
    selectedResource: "",
    layout: {
      "Views::Infrastructure": {
        resource_width: 16,
        resource_height: 32,
        subnet_width: 0
      },
      "Views::Infrastructure::Extended": {
        resource_width: 16,
        resource_height: 64,
        subnet_width: 0
      }
    }
  },

  overrides: {},

  set: function(k, v) {
    this.overrides[k] = v;
  },

  get: function(k) {
    return this.overrides.hasOwnProperty(k) ? this.overrides[k] : this.default[k];
  },

  reset: function(k) {
    this.overrides[k] = angular.copy(this.default[k]);
  },

  loadFromConfig: function(config) {
    this.set("selectedView", config.get("defaultView"));
    this.set("displayLabels", config.get("showLabels"));
    this.set("displayConnections", config.get("showConnections"));
    this.set("displayIsometric", config.get("showIsometric"));
    this.set("highlightTagged", config.get("highlightTagged"));
    this.set("selectedIconSet", config.get("iconSet"));
    this.set("display3DView", config.get("show3DView"));
    this.set("hideDefaultArrows", config.get("hideDefaultArrows"));
    this.set("hideNamespaces", config.get("hideNamespaces"));
    this.set("selectedResource", config.get("selectedResource"));

    if(config.get("layout")) {
      this.set("layout", angular.copy(config.get("layout")));
    }
    else {
      this.set("layout", angular.copy(this.default["layout"]));
    }
  },

  selectDefaultView: function(views) {
    var view_types = _.map(views, function(v) { return v["type"] });

    if(_.includes(view_types, "Views::Infrastructure"))
      this.set("selectedView", "Views::Infrastructure");
    else
      this.set("selectedView", view_types[0]);
  }
});

angular.module("reporter", [
  "designer.model.report",
  "designer.app-scope",
  "report.report",
])
.directive("reporter", [
  function () {
  return {
    templateUrl: "/designer/reporter.html",
    scope: {
      model: "=",
      mode: "=",
      formats: "=",
      path: "="
    },
    controllerAs: 'Reporter',
    bindToController: true,
    controller: ["$scope", "$rootScope", "$element", "$attrs", function($scope, $rootScope, $element, $attrs) {
      this.$onInit = function() {
      };
    }],
    link: function(scope, element, attrs, ctrl) {
    }
  };
}]);

angular.module('reporter.state', [])
.value('ReporterState', {
  default: {
    expandedList: {},
    exportOption: ""
  },

  overrides: {},

  set: function(k, v) {
    this.overrides[k] = v;
  },

  get: function(k) {
    return this.overrides[k] || this.default[k];
  },

  reset: function(k) {
    this.overrides[k] = angular.copy(this.default[k]);
  }
});

angular.module("resource.list", [
  "designer.search",
  "designer.search.controls.sidebar",
  "designer.search.controls.header",
  "designer.search.data.results",
  'designer.model.resource.images',
])
.directive("resourceList", ["SearchResults", "ResourceImages", "$rootScope",
  function (SearchResults, ResourceImages, $rootScope) {
    return {
      templateUrl: "/designer/resource.list.html",
      scope: {},
      controllerAs: 'ResourceList',
      bindToController: true,
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        this.$onInit = function() {
          this.search_results = SearchResults.load();
        };

        this.iconsLoaded = function() {
          $scope.$broadcast("icons:loaded");
        };
      }],
      link: function(scope, element, attrs, ctrl) {
        scope.$on("resource:select", function(evt, resource) {
          $rootScope.$broadcast("resource:selected", resource);
        });
      }
    };
  }]);

angular.module('designer.attributes.environment', [
  "designer.app-scope",
  'designer.attributes.region',
  'designer.attributes.map',
  'designer.attributes.export',
  'designer.attributes.price-estimate'])
  .directive('environmentAttributes', ["$appScope", "$rootScope", function($appScope, $rootScope) {
    return {
      templateUrl: "/designer/attributes/attributes.environment.html",
      scope: true,
      link: function(scope, element, attrs) {
        scope.current_account = $rootScope.current_account;
        scope.display_name = scope.Designer.environment.name;
        scope.regions = [];

        // TODO: eventually we should probably just show the regions from the currently selected view?
        // TODO: need to move this info to a layer specific panel so we can use it for Azure too
        _.each(scope.Designer.environment.views, function(view) {
          if(view.regions) {
            scope.regions = _.uniq(scope.regions.concat(view.regions));
          }
          else if(view.locations) {
            scope.regions = _.uniq(scope.regions.concat(view.locations));
          }
        });

        if(scope.Designer.environment.name.length > 80) {
          scope.display_name = scope.Designer.environment.name.substr(0, 77) + " ...";
        }
      }
    }
  }]);

angular.module('designer.attributes', [
  'designer.attributes.tags',
  'designer.attributes.vpc.control',
  'designer.attributes.elb.listeners',
  'designer.attributes.elb.healthcheck',
  'designer.attributes.resource',
  'designer.attributes.environment',
  'designer.attributes.json_formatter'
])
.directive('attributes', [function() {
  return {
    templateUrl: "/designer/attributes/attributes.html",
    link: function(scope, element, attrs, ctrl) {
      scope.resourceSelected = false;

      if(scope.Designer && scope.Designer.autohide) element.hide();

      scope.$on("resource:selected", function(event, val) {
        scope.resourceSelected = !!val;

        if(scope.Designer && scope.Designer.autohide) {
          if(scope.resourceSelected) { element.show(); }
          else                       { element.hide(); }
        }
      });
    }
  }
}]);

angular.module('designer.attributes.resource', [
  "designer.app-scope",
  'designer.attributes.header',
  'designer.attributes.info.display'])
.directive('resourceAttributes', ["$appScope", "$rootScope", function($appScope, $rootScope) {
  return {
    scope: {
      environment: '='
    },
    templateUrl: "/designer/attributes/attributes.resource.html",
    link: function(scope, element, attrs) {
      scope.selected_resource = null;
      scope.cell_watchers = [];

      scope.$on("resource:selected", function(event, resource) {
        $appScope.safeApply(function() { scope.selected_resource = resource; }, scope);
      });

      scope.selectResource = function(resource) {
        $rootScope.$broadcast("resource:select", resource);
      };
    }
  }
}]);

angular.module('designer.attributes.export', [
  "designer.configuration",
  "designer.state"
])
  .directive('exportOptions', ["$rootScope", "DesignerConfig", "DesignerState", function($rootScope, DesignerConfig, DesignerState) {
    return {
      templateUrl: '/designer/attributes/export.html',
      replace: true,
      link: function (scope, element, attrs) {
        scope.exporting = null;
        scope.error = "";
        scope.show_export = false;
        scope.formats = DesignerConfig.get("exportFormats");

        scope.export_view = function(format) {
          scope.error = "";
          
          scope.exporting = {
            format: format,
            state: "pending",
            type: scope.Designer.environment.current_view.type,
            token: (new Date).getTime(),
            download_path: null
          };

          $rootScope.$broadcast("view:export", {
            format: format,
            show_connections: DesignerState.get("displayConnections"),
            show_names: DesignerState.get("displayLabels"),
            icon_set: DesignerState.get("selectedIconSet"),
            isometric: DesignerState.get("displayIsometric"),
            hideDefaultArrows: DesignerState.get("hideDefaultArrows"),
            hide_namespaces: DesignerState.get("hideNamespaces"),
            layout: DesignerState.get("layout"),
            view: scope.Designer.environment.current_view,
            token: scope.exporting.token
          });
        };

        scope.$on("view:export:complete", function() {
          if(scope.exporting.format === 'cf') {
            scope.exporting = null;
          }
          else {
            scope.exporting.state = "queued";
          }
        });

        scope.$on("view:export:cancelled", function() {
          scope.exporting = null;
        });

        scope.$on("view:export:error", function() {
          scope.exporting = null;
          scope.error = "Failed to contact the export server, please try again soon."
        });

        // Type coercion is expected for these token comparisons, don't make strict
        scope.$on("view:export:started", function(event, data) {
          if(data["token"] == scope.exporting.token) {
            scope.exporting.state = "exporting";
          }
        });

        scope.$on("view:export:finished", function(event, data) {
          if(data["token"] == scope.exporting.token) {
            scope.exporting.state = "finished";
            scope.exporting.download_path = data["url"];
          }
        });

        scope.$on("view:export:failed", function(event, data) {
          if(data["token"] == scope.exporting.token) {
            scope.exporting = null;
            scope.error = data["message"];
          }
        });
      }
    }
  }]);

angular.module('designer.attributes.json_formatter', ['RecursionHelper'])
.provider('JSONFormatterConfig', function JSONFormatterConfigProvider() {

  // Default values for hover preview config
  var hoverPreviewEnabled = false;
  var hoverPreviewArrayCount = 100;
  var hoverPreviewFieldCount = 5;

  return {
    get hoverPreviewEnabled() {
      return hoverPreviewEnabled;
    },
    set hoverPreviewEnabled(value) {
     hoverPreviewEnabled = !!value;
    },

    get hoverPreviewArrayCount() {
      return hoverPreviewArrayCount;
    },
    set hoverPreviewArrayCount(value) {
      hoverPreviewArrayCount = parseInt(value, 10);
    },

    get hoverPreviewFieldCount() {
      return hoverPreviewFieldCount;
    },
    set hoverPreviewFieldCount(value) {
      hoverPreviewFieldCount = parseInt(value, 10);
    },

    $get: function () {
      return {
        hoverPreviewEnabled: hoverPreviewEnabled,
        hoverPreviewArrayCount: hoverPreviewArrayCount,
        hoverPreviewFieldCount: hoverPreviewFieldCount
      };
    }
  };
})

.directive('jsonFormatter', ['RecursionHelper', 'JSONFormatterConfig', function jsonFormatterDirective(RecursionHelper, JSONFormatterConfig) {
  function escapeString(str) {
    return str.replace('"', '\"');
  }

  // From http://stackoverflow.com/a/332429
  function getObjectName(object) {
    if (object === undefined) {
      return '';
    }
    if (object === null) {
      return 'Object';
    }
    if (typeof object === 'object' && !object.constructor) {
        return 'Object';
    }

    //ES6 default gives name to constructor 
    if (object.__proto__ !== undefined && object.__proto__.constructor !== undefined && object.__proto__.constructor.name !== undefined) {
      return object.__proto__.constructor.name;
    } 
       
    var funcNameRegex = /function (.{1,})\(/;
    var results = (funcNameRegex).exec((object).constructor.toString());
    if (results && results.length > 1) {
      return results[1];
    } else {
      return '';
    }
  }

  function getType(object) {
    if (object === null) { return 'null'; }
    return typeof object;
  }

  function getValuePreview (object, value) {
    var type = getType(object);

    if (type === 'null' || type === 'undefined') { return type; }

    if (type === 'string') {
      value = '"' + escapeString(value) + '"';
    }
    if (type === 'function'){

      // Remove content of the function
      return object.toString()
          .replace(/[\r\n]/g, '')
          .replace(/\{.*\}/, '') + '{…}';

    }
    return value;
  }

  function getPreview(object) {
    var value = '';
    if (angular.isObject(object)) {
      value = getObjectName(object);
      if (angular.isArray(object))
        value += '[' + object.length + ']';
    } else {
      value = getValuePreview(object, object);
    }
    return value;
  }

  function link(scope) {
    scope.isArray = function () {
      return angular.isArray(scope.json);
    };

    scope.isObject = function() {
      return angular.isObject(scope.json);
    };

    scope.getKeys = function (){
      if (scope.isObject()) {
        return Object.keys(scope.json).map(function(key) {
          if (key === '') { return '""'; }
          return key;
        });
      }
    };
    scope.type = getType(scope.json);
    scope.hasKey = typeof scope.key !== 'undefined';
    scope.getConstructorName = function(){
      return getObjectName(scope.json);
    };

    if (scope.type === 'string'){

      // Add custom type for date
      if((new Date(scope.json)).toString() !== 'Invalid Date') {
        scope.isDate = true;
      }

      // Add custom type for URLs
      if (scope.json.indexOf('http') === 0) {
        scope.isUrl = true;
      }
    }

    scope.isEmptyObject = function () {
      return scope.getKeys() && !scope.getKeys().length &&
        scope.isOpen && !scope.isArray();
    };


    // If 'open' attribute is present
    scope.isOpen = !!scope.open;
    scope.toggleOpen = function () {
      scope.isOpen = !scope.isOpen;
    };
    scope.childrenOpen = function () {
      if (scope.open > 1){
        return scope.open - 1;
      }
      return 0;
    };

    scope.openLink = function (isUrl) {
      if(isUrl) {
        window.location.href = scope.json;
      }
    };

    scope.parseValue = function (value){
      return getValuePreview(scope.json, value);
    };

    scope.showThumbnail = function () {
      return !!JSONFormatterConfig.hoverPreviewEnabled && scope.isObject() && !scope.isOpen;
    };

    scope.getThumbnail = function () {
      if (scope.isArray()) {

        // if array length is greater then 100 it shows "Array[101]"
        if (scope.json.length > JSONFormatterConfig.hoverPreviewArrayCount) {
          return 'Array[' + scope.json.length + ']';
        } else {
          return '[' + scope.json.map(getPreview).join(', ') + ']';
        }
      } else {

        var keys = scope.getKeys();

        // the first five keys (like Chrome Developer Tool)
        var narrowKeys = keys.slice(0, JSONFormatterConfig.hoverPreviewFieldCount);

        // json value schematic information
        var kvs = narrowKeys
          .map(function (key) { return key + ':' + getPreview(scope.json[key]); });

        // if keys count greater then 5 then show ellipsis
        var ellipsis = keys.length >= 5 ? '…' : '';

        return '{' + kvs.join(', ') + ellipsis + '}';
      }
    };
  }

  return {
    templateUrl: 'json-formatter.html',
    restrict: 'E',
    replace: true,
    scope: {
      json: '=',
      key: '=',
      open: '='
    },
    compile: function(element) {

      // Use the compile function from the RecursionHelper,
      // And return the linking function(s) which it returns
      return RecursionHelper.compile(element, link);
    }
  };
}]);

// from http://stackoverflow.com/a/18609594
angular.module('RecursionHelper', []).factory('RecursionHelper', ['$compile', function($compile){
  return {
    /**
     * Manually compiles the element, fixing the recursion loop.
     * @param element
     * @param [link] A post-link function, or an object with function(s)
     * registered via pre and post properties.
     * @returns An object containing the linking functions.
     */
    compile: function(element, link){
      // Normalize the link parameter
      if(angular.isFunction(link)){
        link = { post: link };
      }

      // Break the recursion loop by removing the contents
      var contents = element.contents().remove();
      var compiledContents;
      return {
        pre: (link && link.pre) ? link.pre : null,
        /**
         * Compiles and re-adds the contents
         */
        post: function(scope, element){
          // Compile the contents
          if(!compiledContents){
            compiledContents = $compile(contents);
          }
          // Re-add the compiled contents to the element
          compiledContents(scope, function(clone){
            element.append(clone);
          });

          // Call the post-linking function, if any
          if(link && link.post){
            link.post.apply(null, arguments);
          }
        }
      };
    }
  };
}]);

angular.module("designer.attributes.json_formatter").run(["$templateCache", function($templateCache) {$templateCache.put("json-formatter.html","<div ng-init=\"isOpen = open && open > 0\" class=\"json-formatter-row\"><a ng-click=\"toggleOpen()\"><span class=\"toggler {{isOpen ? \'open\' : \'\'}}\" ng-if=\"isObject()\"></span> <span class=\"key\" ng-if=\"hasKey\"><span class=\"key-text\">{{key}}</span><span class=\"colon\">:</span></span> <span class=\"value\"><span ng-if=\"isObject()\"><span class=\"constructor-name\">{{getConstructorName(json)}}</span> <span ng-if=\"isArray()\"><span class=\"bracket\">[</span><span class=\"number\">{{json.length}}</span><span class=\"bracket\">]</span></span></span> <span ng-if=\"!isObject()\" ng-click=\"openLink(isUrl)\" class=\"{{type}}\" ng-class=\"{date: isDate, url: isUrl}\">{{parseValue(json)}}</span></span> <span ng-if=\"showThumbnail()\" class=\"thumbnail-text\">{{getThumbnail()}}</span></a><div class=\"children\" ng-if=\"getKeys().length && isOpen\"><json-formatter ng-repeat=\"key in getKeys() track by $index\" json=\"json[key]\" key=\"key\" open=\"childrenOpen()\"></json-formatter></div><div class=\"children empty object\" ng-if=\"isEmptyObject()\"></div><div class=\"children empty array\" ng-if=\"getKeys() && !getKeys().length && isOpen && isArray()\"></div></div>");}]);
angular.module("designer.attributes.map", [])
.directive("map", [function() {
  return {
    templateUrl: "/designer/attributes/map.html",
    scope:{
      regions: "=",
      responsive: "=" 
    },   
    replace: true,
    link: function (scope, element, attrs, ctrl) {
      scope.path = "assets";

      var region_location = {
        // AWS
        "eu-north-1":     { s: { y: 59, x: 166}, location: "Stockholm", name: "eu-north-1", color: "orange" },
        "ap-south-1":     { s: { y: 99, x: 219}, location: "Mumbai", name: "ap-south-1", color: "orange" },
        "eu-west-3":      { s: { y: 76, x: 154}, location: "Paris", name: "eu-west-3", color: "orange" },
        "eu-west-2":      { s: { y: 64, x: 142}, location: "London", name: "eu-west-2", color: "orange" },
        "eu-west-1":      { s: { y: 53, x: 137}, location: "Ireland", name: "eu-west-1", color: "orange" },
        "ap-northeast-2": { s: { y: 76, x: 277}, location: "Seoul", name:"ap-northeast-2", color: "orange" },
        "ap-northeast-1": { s: { y: 82, x: 289}, location: "Tokyo", name:"ap-northeast-1", color: "orange" },
        "sa-east-1":      { s: { y: 152, x: 107}, location: "São Paulo", name: "sa-east-1", color: "orange" },
        "ca-central-1":   { s: { y: 70, x: 61}, location: "Canada Central", name: "ca-central-1", color: "orange" },
        "ap-southeast-1": { s: { y: 129, x: 254}, location: "Singapore", name:"ap-southeast-1", color: "orange" },
        "ap-southeast-2": { s: { y: 158, x: 300}, location: "Sydney", name:"ap-southeast-2", color: "orange" },
        "eu-central-1":   { s: { y: 65, x: 178}, location: "Frankfurt", name: "eu-central-1", color: "orange" },
        "us-east-1":      { s: { y: 82, x: 84}, location: "N. Virginia", name: "us-east-1", color: "orange" },
        "us-east-2":      { s: { y: 82, x: 65}, location: "Ohio", name: "us-east-2", color: "orange" },
        "us-west-1":      { s: { y: 93, x: 37}, location: "N. California", name: "us-west-1", color: "orange" },
        "us-west-2":      { s: { y: 82, x: 37}, location: "Oregon", name: "us-west-2", color: "orange" },
        "eu-south-1":     { s: { y: 82, x: 173}, location: "Milan", name: "eu-south-1", color: "orange" },
        "af-south-1":     { s: { y: 171, x: 166}, location: "Cape Town", name: "af-south-1", color: "orange" },
      
        // Azure 
        "eastasia":      { s: { y: 83, x: 277 }, name: "AP East", location: "Hong Kong", color: "blue" },
        "southeastasia": { s: { y: 129, x: 254 }, name: "AP Southeast", location: "Singapore", color: "blue" },
        "uaecentral":    { s: { y: 105, x: 207 }, name: "AE Central", location: "Abu Dhabi",  color: "blue" },
        "uaenorth":      { s: { y: 105, x: 201 }, name: "AE North", location: "Dubai",  color: "blue" },
        "australiaeast": { s: { y: 158, x: 300 }, name: "AU East", location: "New South Wales", color: "blue" },
        "australiasoutheast": { s: { y: 170, x: 289 }, name: "AU Southeast", location: "Victoria", color: "blue" },
        "australiacentral":   { s: { y: 159, x: 295 }, name: "AU Central", location: "Canberra", color: "blue" },
        "australiacentral2":  { s: { y: 159, x: 295 }, name: "AU Central 2", location: "Canberra", color: "blue" },
        "brazilsouth":   { s: { y: 152, x: 107 },  name: "BR South", location: "São Paulo", color: "blue" },
        "canadacentral": { s: { y: 70, x: 61 }, name: "CA Central", location: "Toronto", color: "blue" },
        "canadaeast":    { s: { y: 71, x: 84 },  name: "CA East", location: "Quebec", color: "blue" },
        "switzerlandnorth":   { s: { y: 82, x: 173 }, name: "CH North", location: "Zürich",  color: "blue" },
        "switzerlandwest": { s: { y: 82, x: 173 }, name: "CH West", location: "Geneva",  color: "blue" },
        "northeurope":   { s: { y: 53, x: 137 }, name: "EU North", location: "Ireland",  color: "blue" },
        "westeurope":    { s: { y: 64, x: 149 }, name:"EU West", location: "Netherlands",  color: "blue" },
        "francecentral": { s: { y: 76, x: 154 }, name: "FR Central", location: "Paris",  color: "blue" },
        "francesouth":   { s: { y: 82, x: 154 }, name: "FR South", location: "Marseille",  color: "blue" },
        "centralindia":  { s: { y: 99, x: 219 }, name: "IN Central", location: "Pune",  color: "blue" },
        "southindia":    { s: { y: 105, x: 231 }, name: "IN South", location: "Chennai", color: "blue" },
        "westindia":     { s: { y: 99, x: 219 }, name: "IN West", location: "Mumbai",  color: "blue" },
        "japaneast":     { s: { y: 82, x: 289 },  name: "JA East", location: "Tokyo",  color: "blue" },
        "japanwest":     { s: { y: 94, x: 283 },  name: "JA West", location: "Osaka",  color: "blue" },
        "koreacentral":  { s: { y: 76, x: 277 }, name: "KR Central", location: "Seoul",  color: "blue" },
        "koreasouth":    { s: { y: 83, x: 277 }, name: "KR South", location: "Busan",  color: "blue" },
        "uksouth":       { s: { y: 64, x: 142 }, name: "UK South", location: "London",  color: "blue" },
        "ukwest":        { s: { y: 64, x: 142 }, name: "UK West", location: "Cardiff",  color: "blue" },
        "centralus":     { s: { y: 70, x: 61 }, name: "US Central", location: "Iowa", color: "blue" },
        "eastus":        { s: { y: 82, x: 84 }, name: "US East", location: "Virginia", color: "blue" },
        "eastus2":        { s: { y: 82, x: 84 }, name: "US East 2", location: "Virginia", color: "blue" },
        "northcentralus": { s: { y: 70, x: 61 }, name: "US  North Central", location: "Illinois", color: "blue" },
        "southcentralus": { s: { y: 94, x: 49 }, name: " US South Central", location: "Texas", color: "blue" },
        "westus":         { s: { y: 93, x: 37 }, namee: "US West", location: "California", color: "blue" },
        "westus2":        { s: { y: 93, x: 37 }, namee: "US West 2", location: "California", color: "blue" },
        "westcentralus":  { s: { y: 88, x: 49 }, name: "US West Central", location: "Wyoming", color: "blue" },
        "southafricanorth": { s: { y: 171, x: 166 }, name: "ZA North", location: "Johannesburg", color: "blue" },
        "southafricawest":  { s: { y: 171, x: 166 }, name: "ZA West", location: "Cape Town", color: "blue" },

        //GCP
        "asia-east1": { s: { y: 94, x: 283 }, name: "asia-east1", location: "Taiwan", color: "purple" },
        "asia-east2": { s: { y: 83, x: 277 }, name: "asia-east2", location: "Hong Kong", color: "purple" },
        "asia-northeast1": { s: { y: 82, x: 289 }, name: "asia-northeast1", location: "Tokyo", color: "purple" },
        "asia-northeast2": { s: { y: 82, x: 289 }, name: "asia-northeast2", location: "Osaka", color: "purple" },
        "asia-northeast3": { s: { y: 76, x: 277 }, name: "asia-northeast3", location: "Seoul", color: "purple" },
        "asia-south1": { s: { y: 99, x: 219 }, name: "asia-south1", location: "Mumbai", color: "purple" },
        "asia-southeast1": { s: { y: 129, x: 254 }, name: "asia-southeast1", location: "Singapore", color: "purple" },
        "australia-southeast1": { s: { y: 158, x: 300 }, name: "australia-southeast1", location: "Sydney", color: "purple" },
        "europe-north1": { s: { y: 59, x: 176 }, name: "europe-north1", location: "Finland", color: "purple" },
        "europe-west1": { s: { y: 70, x: 154 }, name: "europe-west1", location: "Belgium", color: "purple" },
        "europe-west2": { s: { y: 64, x: 142 }, name: "europe-west2", location: "London", color: "purple" },
        "europe-west3": { s: { y: 65, x: 178 }, name: "europe-west3", location: "Frankfurt", color: "purple" },
        "europe-west4": { s: { y: 64, x: 149 }, name: "europe-west4", location: "Netherlands", color: "purple" },
        "europe-west6": { s: { y: 82, x: 173 }, name: "europe-west6", location: "Zurich", color: "purple" },
        "northamerica-northeast1": { s: { y: 71, x: 84 }, name: "northamerica-northeast1", location: "Montreal", color: "purple" },
        "southamerica-east1": { s: { y: 152, x: 107 }, name: "southamerica-east1", location: "São Paulo", color: "purple" },
        "us-central1": { s: { y: 70, x: 61 }, name: "us-central1", location: "Iowa", color: "purple" },
        "us-east1": { s: { y: 88, x: 73 }, name: "us-east1", location: "South Carolina", color: "purple" },
        "us-east4": { s: { y: 82, x: 84 }, name: "us-east4", location: "Northern Virginia", color: "purple" },
        "us-west1": { s: { y: 82, x: 37 }, name: "us-west1", location: "Oregon", color: "purple" },
        "us-west2": { s: { y: 93, x: 37 }, name: "us-west2", location: "Los Angeles", color: "purple" },
        "us-west3": { s: { y: 82, x: 43 }, name: "us-west3", location: "Salt Lake City", color: "purple" },
        "us-west4": { s: { y: 88, x: 49 }, name: "us-west4", location: "Las Vegas", color: "purple" }
      }
      scope.loadRegions = function() {
        scope.mapped_regions = _.pickBy(region_location, function(v,r) {return scope.regions.indexOf(r) !== -1 });
      }

      scope.loadRegions();

      scope.$on("environment:reloaded",  function(event, environment, params) {
        scope.regions = environment.regions;
        scope.loadRegions();
      });
    }
  }
}]);

angular.module('designer.attributes.price-estimate', [])
  .directive('priceEstimate', [function() {
    return {
      replace: true,
      templateUrl: "/designer/attributes/price-estimate.html",
      link: function(scope, element, attrs) {
        scope.extended = false;

        scope.loadPricing = function() {
          scope.price = 0;
          scope.extended_info = {
            "Elastic IP": 0,
            "Load Balancing": 0,
            "EFS": 0,
            "WAF": 0,
            "WorkSpaces": 0,
            "NAT Gateway": 0,
            "EC2 Instance": 0,
            "RDS Cluster": 0,
            "RDS Instance": 0,
            "Volume": 0,
            "ElastiCache": 0,
            "Route 53": 0,
            "Redshift": 0,
            "Virtual Machine": 0,
            "Application Gateway": 0,
            "Public IpAddress": 0,
            "Network Gateway": 0,
            "Peering": 0,
            "RedisCache": 0,
            "DataBase": 0,
            "DirectConnect": 0,
            "DynamoDB": 0,
            "Other": 0,

            // GCP
            "Address": 0,
            "Disk": 0,
            "Forwarding Rule": 0,
            "Instance": 0,
            "Interconnect": 0,
            "VPN": 0,
            "SQL": 0,
            "MemoryStore": 0,
            "DNS": 0
          };

          _.each(scope.Designer.environment.facet.resources, function(r) {
            scope.price += r.price;

            if(r.price) {
              switch(r.type) {
                // AWS
                case "Resources::AWS::EC2::Address":                       scope.extended_info["Elastic IP"] += r.price;   break;
                case "Resources::AWS::ElasticLoadBalancing::LoadBalancer": scope.extended_info["Load Balancing"] += r.price;          break;
                case "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer": scope.extended_info["Load Balancing"] += r.price;          break;
                case "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer": scope.extended_info["Load Balancing"] += r.price;          break;
                case "Resources::AWS::EC2::NATGateway":                    scope.extended_info["NAT Gateway"] += r.price;          break;
                case "Resources::AWS::EC2::Instance":                      scope.extended_info["EC2 Instance"] += r.price; break;
                case "Resources::AWS::RDS::DBCluster":                     scope.extended_info["RDS Cluster"] += r.price; break;
                case "Resources::AWS::RDS::DBInstance":                    scope.extended_info["RDS Instance"] += r.price; break;
                case "Resources::AWS::EC2::Volume":                        scope.extended_info["Volume"] += r.price;       break;
                case "Resources::AWS::ElastiCache::CacheCluster":          scope.extended_info["ElastiCache"] += r.price;  break;
                case "Resources::AWS::Route53::HostedZone":                scope.extended_info["Route 53"] += r.price;  break;
                case "Resources::AWS::Redshift::Cluster":                  scope.extended_info["Redshift"] += r.price;  break;
                case "Resources::AWS::EFS::FileSystem":                    scope.extended_info["EFS"] += r.price;  break;
                case "Resources::AWS::WAF::RateBasedRule":                 scope.extended_info["WAF"] += r.price;  break;
                case "Resources::AWS::WAF::Rule":                          scope.extended_info["WAF"] += r.price;  break;
                case "Resources::AWS::WAF::WebACL":                        scope.extended_info["WAF"] += r.price;  break;
                case "Resources::AWS::WAFV2::WebACL":                      scope.extended_info["WAF"] += r.price;  break;
                case "Resources::AWS::WorkSpaces::WorkSpace":              scope.extended_info["WorkSpaces"] += r.price;  break;
                case "Resources::AWS::DirectConnect::Connection":          scope.extended_info["DirectConnect"] += r.price;  break;
                case "Resources::AWS::DynamoDB::Table":                    scope.extended_info["DynamoDB"] += r.price;  break;

                // Azure
                case "Resources::Azure::Compute::VirtualMachine":          scope.extended_info["Virtual Machine"] += r.price;  break;
                case "Resources::Azure::Network::ApplicationGateway":      scope.extended_info["Application Gateway"] += r.price;  break;
                case "Resources::Azure::Network::PublicIpAddress":         scope.extended_info["Public IpAddress"] += r.price;  break;
                case "Resources::Azure::Network::VirtualNetworkGateway":   scope.extended_info["Network Gateway"] += r.price;  break;
                case "Resources::Azure::Network::VirtualNetworkPeering":   scope.extended_info["Peering"] += r.price;  break;
                case "Resources::Azure::Redis::RedisCache":                scope.extended_info["RedisCache"] += r.price;  break;
                case "Resources::Azure::SQL::DataBase":                    scope.extended_info["DataBase"] += r.price;  break;

                // GCP
                case "Resources::GCP::Compute::Address":                  scope.extended_info["Address"] += r.price;  break;
                case "Resources::GCP::Compute::Disk":                     scope.extended_info["Disk"] += r.price;  break;
                case "Resources::GCP::Compute::ForwardingRule":           scope.extended_info["Forwarding Rule"] += r.price;  break;
                case "Resources::GCP::Compute::GlobalForwardingRule":     scope.extended_info["Forwarding Rule"] += r.price;  break;
                case "Resources::GCP::Compute::GlobalAddress":            scope.extended_info["Address"] += r.price;  break;
                case "Resources::GCP::Compute::Instance":                 scope.extended_info["Instance"] += r.price;  break;
                case "Resources::GCP::Compute::InterconnectAttachment":   scope.extended_info["Interconnect"] += r.price;  break;
                case "Resources::GCP::Compute::Interconnect":             scope.extended_info["Interconnect"] += r.price;  break;
                case "Resources::GCP::Compute::RegionDisk":               scope.extended_info["Disk"] += r.price;  break;
                case "Resources::GCP::Compute::VPNTunnel":                scope.extended_info["VPN"] += r.price;  break;
                case "Resources::GCP::SQL::Instance":                     scope.extended_info["SQL"] += r.price;  break;
                case "Resources::GCP::MemoryStore::Instance":             scope.extended_info["MemoryStore"] += r.price;  break;
                case "Resources::GCP::Compute::DNS":                      scope.extended_info["DNS"] += r.price;  break;

                // Ignore these, they just wrap up other services
                case "Resources::AWS::Autoscaling::AutoScalingGroup": break;
                default:
                  scope.extended_info["Other"] += r.price; break;
              }
            }
          });
        };

        scope.loadPricing();

        scope.$on("environment:reloaded", function() {
          scope.loadPricing();
        });
      }
    }
  }]);

angular.module('designer.attributes.region', [])
  .directive('regionInfo', [function() {
    return {
      templateUrl: '/designer/attributes/region.html',
      replace: true,
      scope: {
        regions: "=",
        responsive: "="
      },
      link: function (scope, element, attrs) {
        scope.region_location = {
          // AWS
          "eu-north-1":     { l: { y: 47,  x: 438}, m: { y: 19, x: 240}, location: "Stockholm", name: "eu-north-1"},
          "ap-south-1":     { l: { y: 175, x: 606}, m: { y: 92, x: 335}, location: "Mumbai", name: "ap-south-1"},
          "eu-west-3":      { l: { y: 80,  x: 406}, m: { y: 49, x: 232}, location: "Paris", name: "eu-west-3"},
          "eu-west-2":      { l: { y: 68,  x: 394}, m: { y: 31, x: 217}, location: "London", name: "eu-west-2"},
          "eu-west-1":      { l: { y: 66,  x: 378}, m: { y: 28, x: 207}, location: "Ireland", name: "eu-west-1"},
          "ap-northeast-2": { l: { y: 112, x: 744}, m: { y: 58, x: 412}, location: "Seoul", name:"ap-northeast-2"},
          "ap-northeast-1": { l: { y: 120, x: 781}, m: { y: 60, x: 430}, location: "Tokyo", name:"ap-northeast-1"},
          "sa-east-1":      { l: { y: 305, x: 266}, m: { y: 162, x: 146}, location: "São Paulo", name: "sa-east-1"},
          "ca-central-1":   { l: { y: 105, x: 138}, m: { y: 48,  x: 64}, location: "Canada Central", name: "ca-central-1"},
          "ap-southeast-1": { l: { y: 224, x: 695}, m: { y: 116, x: 384}, location: "Singapore", name:"ap-southeast-1"},
          "ap-southeast-2": { l: { y: 341, x: 817}, m: { y: 178, x: 457}, location: "Sydney", name:"ap-southeast-2"},
          "eu-central-1":   { l: { y: 93,  x: 451}, m: { y: 43, x: 251}, location: "Frankfurt", name: "eu-central-1"},
          "us-east-1":      { l: { y: 117, x: 181}, m: { y: 61, x: 95}, location: "N. Virginia", name: "us-east-1"},
          "us-east-2":      { l: { y: 106, x: 167}, m: { y: 51, x: 83}, location: "Ohio", name: "us-east-2"},
          "us-west-1":      { l: { y: 124, x: 69 }, m: { y: 64, x: 40}, location: "N. California", name: "us-west-1"},
          "us-west-2":      { l: { y: 98,  x: 64},  m: { y: 55, x: 32}, location: "Oregon", name: "us-west-2"},
          "eu-south-1":     { l: { y: 93,  x: 427}, m: { y: 38, x: 227}, location: "Milan", name: "eu-south-1"},
          "af-south-1":     { l: { y: 341, x: 445}, m: { y: 181, x: 245}, location: "Cape Town", name: "af-south-1"},
        }  
        _.each(scope.regions, function(region) { 
          if(scope.region_location[region]){
            scope.region_location[region]["in_use"] = true;
          };
        })
      }
    }
  }]);

angular.module('designer.model.environment', ["designer.data.resources.factory", "designer.workspace.views.factory", "designer.configuration"])
.factory('Environment', ["ResourcesFactory", "ViewsFactory", "DesignerConfig", function(ResourcesFactory, ViewsFactory, DesignerConfig) {
  return {
    load: function(environment, default_view) {
      // Initialise
      environment.name = environment.name || "";
      environment.valid = true;
      environment.valid_name = (environment.name.length > 0);
      environment.errors = [];
      environment.dirty = false;
      environment.facet.resources = _.map(environment.facet.resources, function (s) { return ResourcesFactory(s, environment) });
      environment.searching = (environment.environment_type === 'search' && (environment.state === 'pending' || environment.state === 'importing'));

      // Parse the query to see if we need ot do any tag highlighting
      environment.search_tokens = _(environment.query.match(/(([a-zA-Z_]+:[^"\s]+)|([a-zA-Z_]+:".+?"))/g))
      .map(function(m) {
        var pair = m.replace('"', "").split(":");

        return { key: pair[0], value: pair[1] };
      }).value();

      // Methods
      environment.setCurrentView = function(id) {
        this.current_view = _.find(this.views, function(l) { return l.id === id });
      };

      environment.setCurrentRevision = function(id) {
        this.current_revision = _.find(this.latest_revisions, function(l) { return l.id === id });
      };

      environment.getResource = function (id) {
        return _.find(this.facet.resources, function (s) {
          return s.id === id;
        });
      };

      environment.getResourceBySourceId = function(id) {
        return _.find(this.facet.resources, function (r) {
          return r.provider_id === id;
        });
      };

      environment.simple = function() { 
        var sources = _.compact(_.uniq(this.sources.map(function (s) { return s.type})));
        if (sources.length > 1 || sources.length == 0) {
          return false;
        } else {
          return sources[0].toLowerCase().includes("azure");
        }
      }

      environment.connectedTo = function(resource, type, children_only) {
        var connected = [];

        _.each(resource.connections, function(connection) {
          if(children_only && connection.resource_id === resource.id) return;

          var resource_id = (connection.resource_id === resource.id) ? connection.remote_resource_id : connection.resource_id;
          var connected_to = this.getResource(resource_id);

          if(connected_to && (!type || connected_to.type === type)) {
            connected_to.connection_data = connection.data;
            connected.push(connected_to);
          }
        }.bind(this));

        return _.uniq(connected);
      };

      environment.findConnectedTo = function(resource, types, children_only) {
        var connected_to = [];
         _.find(types, function(type) {
          connected_to = environment.connectedTo(resource, type);
          return connected_to.length;
        });
        return connected_to;
      };

      environment.getResourcesByType = function(type, parent) {
        var resources = (parent) ? this.connectedTo(parent, null) : this.facet.resources;
        return _.filter(resources, function(s) { return s.type === type });
      };

      ////////////////////////////////////////////////////////////////////////////////////
      // Load connections into the opposite side before we return the decorated object
      ////////////////////////////////////////////////////////////////////////////////////
      _.each(environment.facet.resources, function(resource) {
        _.each(resource.connections, function(connection) {
          if(connection.resource_id === resource.id) {
            var remote_resource = environment.getResource(connection.remote_resource_id);

            // TODO: we should ALWAYS find a remote resource! Right now this handles missing DHCPOptions, once layout code is finished removed this
            if(remote_resource)
              remote_resource.connections.push(connection);
          }
        });
      });

      // Initialise views, if we don't have any views create a basic mock one
      if(environment.views.length) {
        environment.views = _.map(environment.views, function(view) { return ViewsFactory(view, environment) });
      }
      else {
        environment.views = [ViewsFactory({}, environment)];
      }

      // Set the current view to whatever we select for default
      environment.current_view = _.find(environment.views, function(v) { return v.type === default_view }) ||
                                 _.sortBy(environment.views, function(v) { return v.type })[0];

      // Set the current revision
      environment.current_revision =  _.find(environment.latest_revisions, function(l) { return l.id === environment.current_revision.id }) || environment.current_revision;

      return environment;
    }
  }
}]);

angular.module('designer.model.report', [])
.factory('Report', [function() {
  return {
    load: function(report) {

      report.name = report.name || "";
      report.searching = (report.state === 'pending' || report.state === 'importing');

      return report;
    }
  }
}]);

angular.module('designer.model.resource.images', [
  "designer.model.images.aws_20180222_simple",
  "designer.model.images.aws_20181009_arch_light",
  "designer.model.images.azure_vendor",
  "designer.model.images.gcp_classic",
  "designer.model.images.ibm_classic",
  "designer.model.images.kubernetes_classic",
  "designer.configuration",
  "designer.state"
])
  .service('ResourceImages', ["AWS_20180222SimpleImages", "AWS_20181009ArchLightImages", "Azure_VendorImages", "GCP_ClassicImages", "IBM_ClassicImages", "Kubernetes_ClassicImages",
    "DesignerConfig", "DesignerState",
    function(AWS_20180222SimpleImages, AWS_20181009ArchLightImages, Azure_VendorImages, GCP_ClassicImages, IBM_ClassicImages, Kubernetes_ClassicImages,
             DesignerConfig, DesignerState) {
    return {
      icons_sets: {
        azure: {
          classic: {
            provider: "azure",
            images:  Azure_VendorImages,
            main_icon: "resources.azure.network.loadbalancer",
            icon_overlay: true,
            styles: {
              "azure.virtual-network": { 
                stroke: '#B8B8B8',
                "stroke-width": 1, 
                'fill-opacity': 0, 
                rx: 5, ry: 5 
              },
              "azure.subnet": {
                stroke: "#B8B8B8",
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 5, ry: 5, 
                fill: "#FFFFFF"
              },
              "azure.resource-group": {
                stroke: '#B8B8B8', 
                "stroke-width": 1, 
                'fill-opacity': 1, 
                rx: 5, ry: 5, 
                fill: "#FFFFFF",
                "stroke-dasharray": 0 
              }
            }
          }
        },
        aws: {
          "20181009-arch-light": {
            provider: "aws",
            images: AWS_20181009ArchLightImages,
            main_icon: "resources.aws.ec2.natgateway",
            icon_overlay: true,
            styles: {
              "aws.vpc": { 
                stroke: '#077a07',
                "stroke-width": 1, 
                'fill-opacity': 0, 
                rx: 0, ry: 0 
              },
              "aws.subnet": {
                stroke: '#0e7fba',
                "stroke-width": 1, 
                'fill-opacity': 1,
                rx: 0, ry: 0, 
                fill: "#FFFFFF"
              },
              "aws.availability-zone": {
                stroke: '#0e7fba', 
                "stroke-width": 1, 
                'fill-opacity': 1, 
                rx: 0, ry: 0, 
                fill: "#FFFFFF",
                "stroke-dasharray": 2 
              }
            }
          },
          "20180222-simple" : {
            provider: "aws",
            images: AWS_20180222SimpleImages,
            main_icon: "resources.aws.ec2.natgateway",
            styles: {
              "aws.vpc": {
                stroke: '#B8B8B8',
                "stroke-width": 1,
                'fill-opacity': 0,
                rx: 5, ry: 5
              },
              "aws.subnet": {
                stroke: "#B8B8B8",
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 5, ry: 5,
                fill: "#FFFFFF"
              },
              "aws.availability-zone": {
                stroke: '#FFAD32',
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 5, ry: 5,
                fill: "#F4F8FA",
                "stroke-dasharray": 0
              }
            }
          }
        },
        gcp: {
          classic: {
            provider: "gcp",
            images:  GCP_ClassicImages,
            main_icon: "resources.gcp.compute.instance",
            icon_overlay: true,
            styles: {
              "gcp.network": { 
                stroke: '#B8B8B8',
                "stroke-width": 1, 
                'fill-opacity': 0, 
                rx: 5, ry: 5 
              },
              "gcp.subnetwork": {
                stroke: "#B8B8B8",
                "stroke-width": 1,
                'fill-opacity': 0.5,
                rx: 5, ry: 5, 
                fill: "#FFFFFF"
              },
              "gcp.zone": {
                stroke: '#B8B8B8',
                "stroke-width": 1, 
                'fill-opacity': 1, 
                rx: 5, ry: 5, 
                fill: "#fffaed",
                "stroke-dasharray": 0 
              }
            }
          }
        },
        ibm: {
          classic: {
            provider: "ibm",
            images:  IBM_ClassicImages,
            main_icon: "resources.ibm.ec2.instance",
            styles: {
              "ibm.vpc": {
                stroke: '#4376BB',
                "stroke-width": 1,
                'fill-opacity': 0,
                rx: 0, ry: 0
              },
              "ibm.subnet": {
                stroke: "#00882B",
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 0, ry: 0,
                fill: "#E6F0E2"
              },
              "ibm.availability-zone": {
                stroke: '#919191',
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 0, ry: 0,
                fill: "#E0E0E0",
                "stroke-dasharray": 0
              }
            }
          }
        },
        kubernetes: {
          classic: {
            provider: "kubernetes",
            images:  Kubernetes_ClassicImages,
            main_icon: "resources.kubernetes.cluster.cluster",
            styles: {
              "kubernetes.cluster": {
                stroke: '#4376BB',
                "stroke-width": 1,
                'fill-opacity': 0,
                rx: 0, ry: 0
              },
              "kubernetes.deployment": {
                stroke: "#00882B",
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 0, ry: 0,
                fill: "#E6F0E2"
              },
              "kubernetes.pod": {
                stroke: '#919191',
                "stroke-width": 1,
                'fill-opacity': 1,
                rx: 0, ry: 0,
                fill: "#E0E0E0",
                "stroke-dasharray": 0
              }
            }
          }
        }
      },

      default_set: {
        azure: "classic",
        aws: "20181009-arch-light",
        gcp: "classic",
        ibm: "classic",
        kubernetes: "classic"
      },

      getSet: function(provider_type) {
        var icon_set = DesignerState.get("selectedIconSet");

        // If the set doesn't exist or isn't configured then use a default
        if (!this.icons_sets[provider_type][icon_set]) {
          icon_set = this.default_set[provider_type];
          DesignerState.set("selectedIconSet", icon_set);
        }
        return icon_set;
      },

      getUrl: function(resource) {
        if (!_.keys(this.icons_sets).includes(resource.provider_type)) { return "#" + "default-blank" };

        var icon_set = this.getSet(resource.provider_type);
        
        if (resource.type.includes("Generic::GlobalResource")) {
          return "#generic-circle"
        } else if (_.includes(this.icons_sets[resource.provider_type][icon_set]["images"].list, resource.simple_name)) {
          return "#" + resource.provider_type + "-" + icon_set + "-" + resource.simple_name;
        } else {
          return "#" + "default-blank";
        }
      },

      getIconList: function(environment) {
        var types = _.uniq(_.map(environment.facet.resources, function (s) { return s.provider_type }));

        if (_.includes(types, "aws")) {
          return this.icons_sets["aws"];
        } else if (_.includes(types, "azure")) {
          return this.icons_sets["azure"];
        } else if (_.includes(types, "gcp")) {
          return this.icons_sets["gcp"];
        } else if (_.includes(types, "ibm")) {
          return this.icons_sets["ibm"];
        } else if (_.includes(types, "kubernetes")) {
          return this.icons_sets["kubernetes"];
        }
      },

      getStyle: function(provider_type, shape) {
        var icon_set = this.getSet(provider_type);
        return this.icons_sets[provider_type][icon_set]["styles"][shape];
      }
    }
  }]);

angular.module('designer.model.resource', ['designer.model.resource.images', 'designer.data.ip.matcher'])
.factory('Resource', ["ResourceImages", "IpMatcher", function(ResourceImages, IpMatcher) {
    return {
      load: function(obj, environment) {
        var resource = angular.copy(obj);

        resource.summary_line   = "<span></span>";
        resource.provider_id    = resource.provider_id || "";
        resource.simple_name    = resource.type.toLowerCase().replace(/::/g, ".");
        resource.provider_type  = resource.simple_name.split(".")[1];
        resource.display_type   = resource.type.split("::").slice(-1)[0];
        resource.image          = ResourceImages.getUrl(resource);
        resource.connections    = resource.connections || [];
        resource.displayable    = null;
        resource.matched_search = null;
        resource.display_faded  = false;
        resource.has_badge      = false;

        // Map data fields back to the main resource, if we have any
        if(resource.data)
          _.assign(resource, resource.data);

        // To be overriden in child classes to show info specific to the resource
        resource.info = function() { };

        resource.highlightableConnections = function() { return [] };

        resource.getConnectables = function() { return []; };

        resource.getDisplayableConnections = function() {
          if(!this.displayable) {
            this.displayable = this.getConnectables();
          }

          return this.displayable;
        };
        
        // If it is a generic resource show the abbreviation of the type
        // to help the engineer understand what resource is being displaued
        var resource_type = resource.terraform_type;
        if (resource_type && resource.type.includes("Generic::GlobalResource")) {
          resource.getIconInformation = function() {
            var tokens = resource_type.split("_");
            var txt = "G"; // G for Generic or Global

            if (tokens.length > 1) {
              txt = tokens[1][0].toUpperCase()
            }
    
            return {
              txt: txt,
              fill: "#000000",
              'font-size': 30,
              dx: 25,
              dy: 45
            }
          };
        }

        resource.drawable = function() {
          return !this.hidden;
        };

        // Does it have anything to display in a 'BADGE'?
        resource.badgeContent = function() {
          return null;
        };

        resource.setImageUrl = function() {
           this.image = ResourceImages.getUrl(this);
        };

        resource.hasIPMatch = function(ip) {
          var ip_fields = [
            "ip_address", "public_ip", "private_ip_address", "public_ip_address", "cidr_block",
            "private_ipaddress", "ip_address", "gateway_ip_address", "address_space_prefix", "local_network_address_space",
            "backend_addresses", "source_address_prefix", "destination_address_prefix", "address_prefix"
          ];
          var matched = false;

          _.each(ip_fields, function(field) {
            if(!this[field]) return;

            // If ip has a / compare range, otherwise compare string
            if (ip.indexOf("/", 0) !== -1) {
              if(IpMatcher.isIp4InCidr(this[field], ip)) {
                matched = true;
              }
            }
            else {
              if (this[field].lastIndexOf(ip, 0) === 0) {
                matched = true;
              }
            }
          }.bind(this));

          return matched;
        };

        resource.hasTagMatch = function(key, value) {
          var matched = false;

          // Handle quoted strings
          key = key.replace(/"/, "");
          value = value.replace(/"/, "");

          // AWS is an array, Azure is an object
          if(Array.isArray(this.tags)) {
            _.each(this.tags, function(tag_pair) {
              if(key === tag_pair["key"] && value === tag_pair["value"])
                matched = true;
            }.bind(this));
          }
          else {
            if(this.tags && this.tags[key] === value) {
              matched = true;
            }
          }

          return matched;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: null,
            info3: null
          }
        };

        // Check if whether a resource is imported from Terraform state
        // If it is, then we might need to add resources using different routes
        resource.terraformMode = function() {
          if (resource && resource.importMode === 'Terraform') {
            return true;
          }
          return false;
        }

        // We need this for resources which are geenric
        // Meaning we don't have a model/resource created for them yet
        resource.empty = function() {
          return _.isEmpty(this.only_properties);
        }

        return resource;
      }
    }
  }]);

angular.module('designer.model.view', [])
  .factory('View', [function() {
    return {
      create: function(obj) {
        var view = angular.copy(obj);

        // Set to false in views that need to wait for positioning info to come from cliet side layout
        view.positioned = true;
        view.supported_exports = {
          pdf: true,
          png: true,
          vsdx: false,
          csv: true,
          json: true
        };

        view.load    = function() { };
        view.clear   = function() { };
        view.render  = function() { };
        view.isEmpty = function() { };

        return view;
      }
    }
  }]);

angular.module('designer.data.ip.matcher', [])
.service('IpMatcher', [function() {
  return {
    ip4ToInt: function(ip) {
      return ip.split('.').reduce(function(int, oct) { return (int << 8) + parseInt(oct, 10) }, 0) >>> 0;
    },

    isIp4InCidr: function(ip, cidr) {
      var parts = cidr.split("/");
      var range = parts[0];
      var bits = parts[1] || 32;

      var mask = ~(Math.pow(2, (32 - bits)) - 1);
      return (this.ip4ToInt(ip) & mask) === (this.ip4ToInt(range) & mask);
    }
  };
}]);

angular.module('designer.search', [
  "designer.data.resources.factory",
  "designer.app-scope",
  "designer.configuration",
  "designer.search.state"
])
  .directive('search',
    ["$rootScope", "$timeout", "$appScope", "Resources", "ResourcesFactory", "$window", "$filter", "DesignerConfig", "DesignerSearchState",
      function($rootScope, $timeout, $appScope, Resources, ResourcesFactory, $window, $filter, DesignerConfig, DesignerSearchState) {
      return {
        templateUrl: '/designer/search/search.html',
        controllerAs: "Search",
        controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
          this.$onInit = function() {
            $scope.dt_options = {
              "columns": [
                {
                  "data": "image",
                  "render": function ( data, type, row, meta ) {
                    return '<img src="' + data + '" width="32px" />';
                  },
                  "orderable": false,
                  "searchable": false
                },
                {
                  "data": "name", "title": "Name",
                  "render": function(data, type, row, meta) {
                    data = data || "";
                    var content = data.length > 50 ? '<span title="' + data + '">' + data.substr( 0, 48 ) + '...</span>' : data;
                    content += "<br />";
                    content += row.summary_line;
                    return content;
                  }
                },
                {
                  "data": "type",
                  "title": "Type",
                  defaultContent: "-",
                  "render": function(data, type, row, meta) {
                    if(!data) {
                      return data;
                    }

                    var sections = data.split("::").slice(1);

                    return sections.join(" ");
                  }
                },
                { "data": "region", "title": "Region", defaultContent: "-" }, // Call the render method for this to display extra details... row["summary"] or something?
                {
                  "data": "price", "title": "Price",
                  "render": function ( data, type, row, meta ) {
                    return $filter("currency")(data, "$", 0);
                  }
                }
              ],
              "ajax": this.search,
              "dom": '<"designer-search-table"rtiS>',
              "deferRender": true,
              "processing": true,
              "serverSide": true,
              "scrollY": "600px",
              rowId: function(a) {
                return 'id_' + a.id;
              },
              "order": [[4, "desc"]],
              "scroller": {
                displayBuffer: 10,
                boundaryScale: 0.25
              },
              select: {
                style: 'single'
              }
            };
          };

          this.search = function(data, callback, settings) {
            // Format the params as we'd need them
            var params = {};
            params.q = DesignerSearchState.query;
            params.start = data["start"];
            params.length = data["length"];
            params.draw = data["draw"];
            params.context = true;

            // Figure out which column we're sorting on
            var order_info = data["order"]["0"];
            params.sort = data["columns"][order_info["column"]]["data"];
            params.sort_dir = order_info["dir"];

            $scope.SearchHeader.toggleLoading();

            DesignerConfig.get("searchMethod")(params).then(function(result) {
              // Use the resource objects to display in the list
              result.data = $scope.ResourceList.search_results.addResultSet(result, params);

              $scope.SearchHeader.toggleLoading();
              DesignerSearchState.count = result["recordsTotal"];
              DesignerSearchState.error = false;

              $timeout(function() {
                callback(result);
              }, 0);
            }, function(e) {
              var error = "";

              if (e["data"] && e["data"]["positions"]) {
                error = "Syntax error at character " + e["data"]["positions"][1]
                $rootScope.$broadcast("search:query:error", e["data"]["positions"]);
              }
              else {
                error = "There was an unexpected error!";
              }

              $scope.SearchHeader.toggleLoading();
              $scope.SearchHeader.setError(error);
              DesignerSearchState.error = true;
            });
          };
        }],
        link: function(scope, element, attrs, ctrl) {
          scope.selected = null;
          scope.dTable = null;

          scope.calculateHeight = function() {
            // Get available height and subtract header and footer. Man this sucks.
            var header = 38;
            var footer = 33;
            scope.dt_options["scrollY"] = $(".search-results").height() - header - footer;
          };

          scope.drawTable = function() {
            scope.calculateHeight();

            scope.dTable = $("#datatable-resources").DataTable(scope.dt_options);

            // Handlers!
            scope.dTable.on("select", function(e, dt, type, indexes) {
              var rowData = scope.dTable.rows(indexes).data().toArray()[0];
              $appScope.safeApply(function() {
                var resource =  scope.ResourceList.search_results.getResource(rowData.id);

                scope.selected = (resource === scope.selected) ? null : resource;

                $rootScope.$broadcast("resource:selected", scope.selected);
              }, scope);
            });

            scope.dTable.on("deselect", function(e, dt, type, indexes) {
              $appScope.safeApply(function() {
                scope.selected = null;

                $rootScope.$broadcast("resource:selected", scope.selected);
              }, scope);
            });

            scope.resizeTable();
          };

          // Add a delay on resize so we don't fire this a bajillion times
          scope.resizeTimer = null;
          scope.resizeTable = function() {
            clearTimeout(scope.resizeTimer);
            scope.resizeTimer = $timeout(function() {
              scope.calculateHeight();

              $('.dataTables_scrollBody').css('height', scope.dt_options["scrollY"] + "px");
              scope.dTable.scroller.measure(false);
            }, 500);
          };

          // Load the datatable once the directives have completed (timeout puts it outside the current digest)
          $timeout(function() {
            scope.drawTable();
          });

          // If the user resizes their window we have to redraw the whole table for now (https://datatables.net/manual/tech-notes/3)
          $window.addEventListener('resize', scope.resizeTable);
          scope.$on('$destroy', function () {
            $window.removeEventListener('resize', scope.resizeTable);
          });

          // Handle searches
          scope.$on("resource:search", function(evt, query) {
            scope.dTable.search("").draw();
          });
        }
      }
    }]);

angular.module('designer.search.state', [])
.value('DesignerSearchState', {
  query: "",
  count: 0,
  error: false
});

angular.module('report.report', [
  "report.graphs.bar-chart",
  "report.graphs.column-chart",
  "report.graphs.combo-chart",
  "report.graphs.report-map",
  "reporter.state",
  "report.exporter"
])
.directive('report', [
  function() {
  return {
    templateUrl: '/designer/report/report.html',
    replace: true,
    controller: ["$scope", "ReporterState", function($scope, ReporterState) {
      var report = $scope.Reporter.model;
      $scope.report = report;
      
      $scope.extended = {};
      $scope.mode = $scope.Reporter.mode ? "reporter-" + $scope.Reporter.mode : "reporter-app";
      var export_option = ReporterState.get("exportOption");
      $scope.export_option = _.isEmpty(export_option) ? "hide" : export_option;
      $scope.expanded_list = ReporterState.get("expandedList");
      $scope.path = $scope.Reporter.path || "assets";

      $scope.account_id = report.data.table.accounts[0].table.id;
      $scope.account_name = report.data.table.accounts[0].table.name;
      
      // Format Region/Resource Data 
      $scope.resource_stats = {};
      $scope.resource_stats["id"] = 'total-resources';
      $scope.resource_stats["title"] = 'Total Resources';
      $scope.resource_stats["categories"] = [];

      var series = [];
      var resource_list = report.data.table.resource_data_set;

      _.each(resource_list, function(resource) {
        var total = resource.table.data[0];
        if (total>0) {
          $scope.resource_stats.categories.push(resource.table.label);
          series.push(total);
        }    
      });
      $scope.resource_stats["series"] = [{
        name: 'Resources',
        data: series
      }];
      $scope.resource_stats["max"] = _.max(series);
  
      // Format Regions and Resources utilized
      $scope.region_resource_stats = {};
      var resource_hash = {};
      var region_resources = {};
      var region_stats = report.data.table.region_stats_tooltip.table[$scope.account_name].table;
      _.each(region_stats, function(resources, region) {
        var resource_list = _.compact(resources.split("<br>"))
        _.each(resource_list, function(resource){
          var resource_total = resource.split(":");

          if (!resource_hash[resource_total[0]]) resource_hash[resource_total[0]] = {};
          resource_hash[resource_total[0]][region] = resource_total[1];
          
          if (!region_resources[region]) region_resources[region] = {};
          region_resources[region][resource_total[0]] = resource_total[1];
        })   
      });
  
      var resource_values = {};
      var totals = [];
      var regions = _.keys(region_resources);
      _.each(regions, function(region, index){
        var total_region = 0;
        var tmp_resources = region_resources[region];
        _.each(tmp_resources, function(total, resource){
          if (!resource_values[resource]) resource_values[resource] = Array(regions.length).fill(null);
          resource_values[resource][index] = parseInt(total);
          total_region += parseInt(total);
        })
        totals.push(total_region);
      });
  
      var region_series = [];
      _.each(resource_values, function(values, resource){
        region_series.push({
          name: resource,
          data: values
        })
      });
  
      $scope.region_resource_stats["series"] = region_series;
      $scope.region_resource_stats["categories"] = regions;
      $scope.region_resource_stats["title"] = 'Resources by Region';
      $scope.region_resource_stats["max"] = _.max(totals);
      $scope.region_resource_stats["stack"] = true;
      
      // Format IAM Data
      $scope.iam_data = {};
      var active_values = {};
      var inactive_values = {};
      var list = report.data.table.iam_active_data_set;
      var categories = ['Users', 'Roles'];
  
      _.each(list, function(iam) {
        var key = iam.table.label;
        var val = iam.table.data[0];

        key.indexOf("Active") != -1 ? 
          active_values[key.replace('Active ','')] = val : 
          inactive_values[key.replace('Inactive ','')] = val;
      });
  
      var series = [
        {
          name: 'Active',
          data: _.sortBy(active_values, function(k,v) { return v })
        },
        {
          name: 'Inactive',
          data: _.sortBy(inactive_values, function(k,v) { return v }) 
        }
      ];
      
      var max_x = _.max(_.map(categories, function(category){
        return active_values[_.lowerCase(category)] + inactive_values[_.lowerCase(category)];
      }));

      $scope.iam_data["categories"] = categories;
      $scope.iam_data["series"] = series
      $scope.iam_data["title"] = "IAM";
      $scope.iam_data["max"] = max_x;
      $scope.iam_data["stack"] = true;
  
      $scope.findings = {};
  
      $scope.severity_color = {
        "Critical": "#ba1f06",
        "High": "#ff5a46",
        "Medium": "#fb9702",
        "Low": "#36a2eb",
        "Info": "#33cab2",
        "Verbose": "#00a9ff"
      };
      
      var findings_map = {
        "Critical": {},
        "High": {},
        "Medium": {},
        "Low": {},
        "Info": {},
        "Verbose": {}
      };

      var list = report.data.table.findings.table;
      $scope.extended.list = {};
  
      _.each(list, function(values, type){
        // Don't display cloudmapper errors, it's because the user didn't give us permission to check something
        if(type === "ERROR") return;

        _.each(values.table, function(vals, subtype) {
          var severity_regions = vals.table.accounts.table[$scope.account_id].table.regions.table;
          var details = _.find(_.uniq(_.map(severity_regions, function(val,key) {return val.table.hits[0].table.details})), function(state){ return state !== 'null' });
          if (! findings_map[vals.table.severity][type])  findings_map[vals.table.severity][type] = {};
          $scope.extended.list[subtype] = $scope.export_option=="expand" ? true : $scope.export_option=="preselected" ? _.includes($scope.expanded_list, subtype) : false;
          findings_map[vals.table.severity][type][subtype] = !_.isEmpty(details);
        });
      });
      ReporterState.set("expandedList", _.keys(_.pickBy($scope.extended.list, function(val) { return val})));

      $scope.findings_map = _.pickBy(findings_map, function(i) { return _.keys(i).length > 0 });

      var serie_pie1_hash = {};
      var serie_pie2 = [];
      var severity_total_resources = {};
      _.each($scope.findings_map, function(values, severity){
        var severity_finding = $scope.findings_map[severity];
        severity_total_resources[severity] = _.keys(values).length;

        _.each(severity_finding, function(subtypes, type){
          var total = _.keys(subtypes).length;
          serie_pie2.push({
            name: type,
            data: total
          });
          if (! serie_pie1_hash[severity])  serie_pie1_hash[severity] = 0;
          serie_pie1_hash[severity] = serie_pie1_hash[severity] + total;
        }); 
      }); 
  
      var serie_pie1 = [];
      _.each(serie_pie1_hash, function(values, resource){
        serie_pie1.push({
          name: resource,
          data: values
        })
      }); 
      
      $scope.findings["categories"] = ['Finding'];
      $scope.findings["series"] = [{ name: 'pie1', data: serie_pie1 }, { name: 'pie2', data: serie_pie2 }];
      $scope.findings["title"] = "Findings";
      $scope.findings["severity_total_resources"] = severity_total_resources;
  
      // Theme
      var theme = {
        series: {
          colors: [
            '#4bc0c0', '#36a2eb', '#f27173', '#ffcd56', '#289399',
            '#60ca87', '#617178', '#8a9a9a', '#516f7d', '#dddddd'
          ]
        }
      };
      // toastui.Chart.registerTheme('reportTheme', theme);
        
      $scope.set_extended_list = function(subtype) {
        $scope.extended.list[subtype] = !$scope.extended.list[subtype]
        ReporterState.set("expandedList", _.keys(_.pickBy($scope.extended.list, function(val) { return val})));
      };
    }],
    link: function(scope, element, attrs, ctrl) {
      
    }
  }
}]);

angular.module('designer.workspace', [
  'designer.workspace.sidebar',
  'designer.workspace.canvases.jointjs.canvas',
  'designer.workspace.canvases.html.canvas',
  'designer.workspace.canvases.3dview',
  'designer.workspace.exporter',
  'designer.workspace.sharer',
  'designer.workspace.view.options',
  "designer.configuration",
  "designer.state"
])
.directive('workspace',
  ["DesignerConfig", "DesignerState", "$timeout", function(DesignerConfig, DesignerState, $timeout) {
      return {
        templateUrl: '/designer/workspace/workspace.html',
        replace: true,
        controllerAs: "Workspace",
        controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
          this.view = $scope.Designer.environment.current_view || {};
          this.watermarked = DesignerConfig.get("watermark");
          this.show_controls = DesignerConfig.get("showControls");
        }],
        link: function(scope, element, attrs, ctrl) {
          scope.$on("icons:loaded", function() {
            ctrl.loading_icons = false;
          });

          scope.$on("environment:reloaded", function(e, environment) {
            ctrl.view = environment.current_view;
          });

          scope.$on("view:selected", function(e, view) {
            ctrl.view = view;
            
            $timeout(function() {
             var resource = DesignerState.get("selectedResource")
              if(resource) {
                scope.$broadcast("resource:select", resource)
              }
            }, 0, false);
          });
        
          scope.$on("resource:selected", function(e, resource) {
            DesignerState.set("selectedResource", resource);
          });

          scope.$watch(function() { return element.hasClass("apex"); }, function(hasApex) {
            if (!hasApex && ctrl.watermarked) {
              element.addClass("apex");
            }
          });

          scope.$on("icon:switch", function() {
            var resources = scope.Designer.environment.facet.resources;
            _.each(resources, function(resource) {
              if(resource) {
                resource.setImageUrl();
              }
            }.bind(this));
          });

          // TODO: so ideally we'd have the entire view loaded here with state, and switch between them as required - not just hide them behind each other, still catching events.
        }
      }
    }]);

angular.module('designer.attributes.info.display', [])
  .directive('infoDisplay', ["$rootScope", function($rootScope) {
    return {
      templateUrl: '/designer/attributes/info/display.html',
      replace: true,
      link: function (scope, element, attrs, ctrl) {
        scope.resource = null;
        scope.template = "";

        // TODO: I don't wanna have to add one for each of them, but right now it's just VPC anyways
        scope.extended = {
          rt: false,
          sg: false
        };

        scope.$watch("selected_resource", function(s) {
          scope.resource = s;
          scope.info     = (s) ? s.info() : null;
          // TODO: determine if the file exists and load a default otherwise?
          scope.template = (s) ? "/designer/data/" + scope.resource.simple_name.replace(/\./g, "/") + ".html" : "";
        });

        scope.selectResource = function(resource) {
          $rootScope.$broadcast("resource:select", resource);
        };

        scope.$on("toggle_control", function(evt, k, val) {
          scope.extended = { rt: false, sg: false };
          scope.extended[k] = val;
        });
      }
    }
  }]);

angular.module('designer.attributes.elb.healthcheck', [])
  .directive('elbHealthcheck', [function() {
    return {
      templateUrl: '/designer/attributes/controls/elb.healthcheck.html',
      replace: true,
      scope: true,
      link: function (scope, element, attrs) {
        scope.healthcheck = null;

        scope.load = function() {
          scope.healthcheck = scope.resource["health_check"] || {};
        };

        scope.$watch("resource", function(s) {
          if(scope.resource) {
            scope.load();
          }
        });
      }
    }
  }]);

angular.module('designer.attributes.elb.listeners', [])
  .directive('elbListeners', [function() {
    return {
      templateUrl: '/designer/attributes/controls/elb.listeners.html',
      replace: true,
      scope: true,
      link: function (scope, element, attrs) {
        scope.listeners = [];

        scope.loadResource = function() {
          scope.listeners = scope.resource.listeners;
        };

        scope.$watch("resource", function(s) {
          if(scope.resource) {
            scope.loadResource();
          }
        });
      }
    }
  }]);

angular.module("designer.attributes.header", [])
  .directive("resourceHeader", [function() {
    return {
      templateUrl: "/designer/attributes/controls/header.html",
      link: function (scope, element, attrs) {

        scope.$watch("selected_resource", function(resource) {
          if(resource) {
            scope.resource = resource;
            scope.resource.type_name = resource.type_name || resource.display_type.split(/(?=[A-Z][a-z])/).join(" ").toUpperCase();
            scope.display_status = scope.setStatusName(resource);
            scope.status_color = scope.getStatusColor(resource);
          }
        });

        scope.setStatusName = function(resource){
          if (!resource.status) return; 
          return resource.status.replace("_", " ").replace("-", " ").split(/(?=[A-Z][a-z])/).join(" ").toUpperCase();
        };

        scope.getStatusColor = function(resource) {
          if (!resource.status || !resource.status_list) return "stopped";

          var status_list = {};
          _.each(resource.status_list, function(k, v){ status_list[v.toLowerCase()] = k });
          return status_list[resource.status.toLowerCase()] || "stopped";
        };
      }
    }
  }]);

angular.module('designer.attributes.tags', [])
  .directive('resourceTags', [function() {
    return {
      templateUrl: '/designer/attributes/controls/tags.html',
      link: function (scope, element, attrs) {
        scope.$watch("selected_resource", function(val) {
          if(val && val["tags"]) {
            if ($.isArray(val["tags"])) {
              var hash_tags = {};
              var filtered_tags = _.reject(val["tags"], function(tag) { return (tag["key"] || "").startsWith("aws:cloudformation") });
              _.each(filtered_tags, function(at){ hash_tags[at.key] = at.value });
              scope.tags = hash_tags;
            }
            else {
              scope.tags = val["tags"];
            }
          }
          else {
            scope.tags = {};
          }

          scope.has_tags = _.size(scope.tags);
        });
      }
    }
  }]);

angular.module('designer.attributes.vpc.control', ['designer.workspace.canvases.jointjs.resource.connections.highlighter','designer.workspace.canvases.jointjs.resource.highlighter'])
  .directive('vpcControl', ["$appScope", "$rootScope", function($appScope, $rootScope) {
    return {
      templateUrl: "/designer/attributes/controls/vpc.control.html",
      replace: true,
      scope: {
        environment: '=',
        resources: '='
      },
      link: function(scope, element, attrs) {
        scope.display = false;
        scope.cellView = {};
        scope.connected_resources = [];
        scope.resource_type = null;
        scope.title = null;

        scope.$on("attributes:control", function(event, params, cellView) {
          $appScope.safeApply(function() {
            if (!cellView || (cellView.id === scope.cellView.id && scope.resource_type === params.type)) {
              scope.display = false;
              scope.cellView = {};
              scope.connected_resources = [];
              scope.selected = null;
              scope.resource_type = null;
              scope.title = null;
              scope.deleting = null;
            }
            else {
              scope.display = true;
              scope.selected = null;
              scope.cellView = cellView;
              scope.resource_type = params.type;
              scope.title = params.title;
              scope.connected_resources = scope.environment.connectedTo(cellView.model.get("resource"), params.type);
            }
          }, scope);
        });

        scope.select = function(resource) {
          scope.selected = resource;
          $rootScope.$broadcast("resource:selected", resource);
        };
      }
    }
  }]);

angular.module("designer.data.resources.factory", [
  "designer.data.resources.aws.factory",
  "designer.data.resources.azure.factory",
  "designer.data.resources.gcp.factory",
  "designer.data.resources.ibm.factory",
  "designer.data.resources.kubernetes.factory",
])
  .service("ResourcesFactory", ["AWSResourcesFactory", "AzureResourcesFactory", "GCPResourcesFactory", "IBMResourcesFactory", "KubernetesResourcesFactory",
    function(AWSResourcesFactory, AzureResourcesFactory, GCPResourcesFactory, IBMResourcesFactory, KubernetesResourcesFactory)
  {
    return function fromResourceObject(resource, environment) {
      if(resource.type.lastIndexOf("Resources::AWS", 0) === 0) {
        return AWSResourcesFactory(resource, environment);
      }
      else if(resource.type.lastIndexOf("Resources::Azure", 0) === 0) {
        return AzureResourcesFactory(resource, environment);
      }
      else if(resource.type.lastIndexOf("Resources::GCP", 0) === 0) {
        return GCPResourcesFactory(resource, environment);
      }
      else if(resource.type.lastIndexOf("Resources::IBM", 0) === 0) {
        return IBMResourcesFactory(resource, environment);
      }
      else if(resource.type.lastIndexOf("Resources::Kubernetes", 0) === 0) {
        return KubernetesResourcesFactory(resource, environment);
      }
    };
  }]);

angular.module('designer.search.controls.header', [
  "designer.app-scope",
  "designer.search.state"
])
.directive('searchHeader', [ "$rootScope", "DesignerSearchState", function($rootScope, DesignerSearchState) {
    return {
      templateUrl: '/designer/search/controls/search.header.html',
      controllerAs: "SearchHeader",
      replace: true,
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        var vm = this;

        vm.error = null;
        vm.loading = false;
        vm.search_state = DesignerSearchState;

        vm.saveEnvironment = function() {
          $rootScope.$broadcast("resources:save");
        };

        // TODO: we probably don't want to toggle the error here :P
        vm.toggleLoading = function() {
          vm.loading = !vm.loading;
          vm.error = null;
        };

        vm.setError = function(e) {
          vm.error = e;
        };
      }],
      link: function(scope, element, attrs, ctrl) {
      }
    }
  }]
);

angular.module('designer.search.controls.sidebar', [
  "designer.attributes"
])
.directive('searchSidebar', [function() {
  return {
    templateUrl: '/designer/search/controls/search.sidebar.html',
    replace: true,
    link: {
      post: function(scope, element, attrs, ctrl) {
      }
    }
  }
}]);

angular.module('designer.search.data.results', ["designer.data.resources.factory"])
.factory('SearchResults', ["ResourcesFactory", function(ResourcesFactory) {
  return {
    load: function() {
      var results = {};

      // Initialise
      results.errors = [];
      results.resources = [];
      results.context = [];
      results.query = "";

      results.addResultSet = function(result, params) {
        // Set up the query ... if it's new do we reload the resource list and start again? Probably should if we've sorted too!
        this.query = params.q;

        // Rightooooo so we want to grab the resources, map them into our classes, then make them selectable
        var count = params.start;
        var new_resources = _.map(result.data, function (s) {
          var r = ResourcesFactory(s, this);
          r.counter = count + 1;
          count++;
          return r;
        }.bind(this));

        var context_resources = _.map(result.context, function(s) { return ResourcesFactory(s, this) }.bind(this));

        this.resources = _.uniqBy(this.resources.concat(new_resources).concat(context_resources), function(r) { return r.id });

        // Load remote connections, unless it's already in the array
        _.each(this.resources, function(resource) {
          _.each(resource.connections, function(connection) {
            if(connection.resource_id === resource.id) {
              var remote_resource = this.getResource(connection.remote_resource_id);

              if(remote_resource && !_.includes(remote_resource.connections, connection)) {
                remote_resource.connections.push(connection);
              }
            }
          }.bind(this));
        }.bind(this));

        return new_resources;
      };

      results.getResource = function (id) {
        return _.find(this.resources, function (s) {
          return s.id === id;
        });
      };

      results.connectedTo = function(resource, type, children_only) {
        var connected = [];

        _.each(resource.connections, function(connection) {
          if(children_only && connection.resource_id === resource.id) return;

          var resource_id = (connection.resource_id === resource.id) ? connection.remote_resource_id : connection.resource_id;
          var connected_to = this.getResource(resource_id);

          if(connected_to && (!type || connected_to.type === type)) {
            connected_to.connection_data = connection.data;
            connected.push(connected_to);
          }
        }.bind(this));

        return connected;
      };

      results.findConnectedTo = function(resource, types, children_only) {
        var connected_to = [];
        _.find(types, function(type) {
          connected_to = results.connectedTo(resource, type);
          return connected_to.length;
        });
        return connected_to;
      };

      results.getResourcesByType = function(type, parent) {
        var resources = (parent) ? this.connectedTo(parent, null) : this.resources;
        return _.filter(resources, function(s) { return s.type === type });
      };

      return results;
    }
  }
}]);

angular.module('report.export.options', [
  "reporter.state"
])
.directive('reportExportOptions', ["$rootScope", "ReporterState", function($rootScope, ReporterState) {
  return {
    templateUrl: '/designer/report/controls/export.options.html',
    replace: true,
    link: function (scope, element, attrs) {
      scope.exporting = null;
      scope.error = "";

      scope.export_options = [
        { id: "hide", name: "Hide", description: "Hide all"},
        { id: "expand", name: "Expand", description: "Expand all"},
        { id: "preselected", name: "Pre-selected", description: "As preselected in the current report"}
      ];
      scope.export_options.selected = scope.export_options[0].id;


      scope.export_report = function(format) {
        scope.error = "";
        scope.expanded_list = ReporterState.get("expandedList");
        
        scope.exporting = {
          format: format,
          state: "pending",
          type: scope.Reporter.model.type,
          token: (new Date).getTime(),
          download_path: null
        };

        $rootScope.$broadcast("report:export", {
          format: format,
          report: scope.Reporter.model,
          token: scope.exporting.token,
          export_option: scope.export_options.selected,
          expanded_list: scope.expanded_list
        });
      };

      scope.$on("report:export:complete", function() {
        scope.exporting.state = "queued";
      });

      scope.$on("report:export:cancelled", function() {
        scope.exporting = null;
      });

      scope.$on("report:export:error", function() {
        scope.exporting = null;
        scope.error = "Failed to contact the export server, please try again soon."
      });

      // Type coercion is expected for these token comparisons, don't make strict
      scope.$on("report:export:started", function(event, data) {
        if(data["token"] == scope.exporting.token) {
          scope.exporting.state = "exporting";
        }
      });

      scope.$on("report:export:finished", function(event, data) {
        if(data["token"] == scope.exporting.token) {
          scope.exporting.state = "finished";
          scope.exporting.download_path = data["url"];
        }
      });

      scope.$on("report:export:failed", function(event, data) {
        if(data["token"] == scope.exporting.token) {
          scope.exporting = null;
          scope.error = data["message"];
        }
      });
    }
  }
}]);

angular.module('report.exporter', [
  "designer.app-scope",
  "report.export.options"
])
.directive('reportExporter', ["$window", "$appScope", function($window, $appScope) {
return {
  templateUrl: '/designer/report/controls/exporter.html',
  replace: true,
  link: {
    post: function(scope, element, attrs, ctrl) {
      scope.show_export = false;

      scope.toggleExports = function() {
        scope.show_export = !scope.show_export;

        scope.show_export ?
          angular.element($window).on("click", scope.handleWindowClick) :
          angular.element($window).off("click", scope.handleWindowClick);
      };

      scope.upgradeAccount = function() {
        scope.$emit("trial:upgrade");
      };

      scope.handleWindowClick = function(event) {
        var target = $(event.target);

        if (!target.parents('#export-options').length) {
          $appScope.safeApply(function() {
            scope.toggleExports();
          }, scope);
        }
      }
    }
  }
}
}]);

angular.module("designer.model.helpers.ports", []).service("portMapper", [
  function () {
    return {
      'ALL': "ALL",
      1: "tcpmux",
      2: "compressnet",
      3: "compressnet",
      5: "rje",
      7: "echo",
      9: "discard",
      11: "systat",
      13: "daytime",
      17: "qotd",
      18: "msp",
      19: "chargen",
      20: "ftp-data",
      21: "ftp",
      22: "ssh",
      23: "telnet",
      25: "smtp",
      27: "nsw-fe",
      29: "msg-icp",
      31: "msg-auth",
      33: "dsp",
      37: "time",
      38: "rap",
      39: "rlp",
      41: "graphics",
      42: "nameserver",
      43: "nicname",
      44: "mpm-flags",
      45: "mpm",
      46: "mpm-snd",
      48: "auditd",
      49: "tacacs",
      50: "re-mail-ck",
      52: "xns-time",
      53: "domain",
      54: "xns-ch",
      55: "isi-gl",
      56: "xns-auth",
      58: "xns-mail",
      62: "acas",
      63: "whois++",
      64: "covia",
      65: "tacacs-ds",
      66: "sql*net",
      67: "bootps",
      68: "bootpc",
      69: "tftp",
      70: "gopher",
      71: "netrjs-1",
      72: "netrjs-2",
      73: "netrjs-3",
      74: "netrjs-4",
      76: "deos",
      78: "vettcp",
      79: "finger",
      80: "http",
      82: "xfer",
      83: "mit-ml-dev",
      84: "ctf",
      85: "mit-ml-dev",
      86: "mfcobol",
      88: "kerberos",
      89: "su-mit-tg",
      90: "dnsix",
      91: "mit-dov",
      92: "npp",
      93: "dcp",
      94: "objcall",
      95: "supdup",
      96: "dixie",
      97: "swift-rvf",
      98: "tacnews",
      99: "metagram",
      101: "hostname",
      102: "iso-tsap",
      103: "gppitnp",
      104: "acr-nema",
      105: "csnet-ns",
      106: "3com-tsmux",
      107: "rtelnet",
      108: "snagas",
      109: "pop2",
      110: "pop3",
      111: "sunrpc",
      112: "mcidas",
      113: "auth",
      115: "sftp",
      116: "ansanotify",
      117: "uucp-path",
      118: "sqlserv",
      119: "nntp",
      120: "cfdptkt",
      121: "erpc",
      122: "smakynet",
      123: "ntp",
      124: "ansatrader",
      125: "locus-map",
      126: "nxedit",
      127: "locus-con",
      128: "gss-xlicen",
      129: "pwdgen",
      130: "cisco-fna",
      131: "cisco-tna",
      132: "cisco-sys",
      133: "statsrv",
      134: "ingres-net",
      135: "epmap",
      136: "profile",
      137: "netbios-ns",
      138: "netbios-dgm",
      139: "netbios-ssn",
      140: "emfis-data",
      141: "emfis-cntl",
      142: "bl-idm",
      143: "imap",
      144: "uma",
      145: "uaac",
      146: "iso-tp0",
      147: "iso-ip",
      148: "jargon",
      149: "aed-512",
      150: "sql-net",
      151: "hems",
      152: "bftp",
      153: "sgmp",
      154: "netsc-prod",
      155: "netsc-dev",
      156: "sqlsrv",
      157: "knet-cmp",
      158: "pcmail-srv",
      159: "nss-routing",
      160: "sgmp-traps",
      161: "snmp",
      162: "snmptrap",
      163: "cmip-man",
      164: "cmip-agent",
      165: "xns-courier",
      166: "s-net",
      167: "namp",
      168: "rsvd",
      169: "send",
      170: "print-srv",
      171: "multiplex",
      172: "cl/1",
      173: "xyplex-mux",
      174: "mailq",
      175: "vmnet",
      176: "genrad-mux",
      177: "xdmcp",
      178: "nextstep",
      179: "bgp",
      180: "ris",
      181: "unify",
      182: "audit",
      183: "ocbinder",
      184: "ocserver",
      185: "remote-kis",
      186: "kis",
      187: "aci",
      188: "mumps",
      189: "qft",
      190: "gacp",
      191: "prospero",
      192: "osu-nms",
      193: "srmp",
      194: "irc",
      195: "dn6-nlm-aud",
      196: "dn6-smm-red",
      197: "dls",
      198: "dls-mon",
      199: "smux",
      200: "src",
      201: "at-rtmp",
      202: "at-nbp",
      203: "at-3",
      204: "at-echo",
      205: "at-5",
      206: "at-zis",
      207: "at-7",
      208: "at-8",
      209: "qmtp",
      210: "z39.50",
      211: "914c/g",
      212: "anet",
      213: "ipx",
      214: "vmpwscs",
      215: "softpc",
      216: "CAIlic",
      217: "dbase",
      218: "mpp",
      219: "uarps",
      220: "imap3",
      221: "fln-spx",
      222: "rsh-spx",
      223: "cdc",
      224: "masqdialer",
      242: "direct",
      243: "sur-meas",
      244: "inbusiness",
      245: "link",
      246: "dsp3270",
      247: "subntbcst_tftp",
      248: "bhfhs",
      256: "rap",
      257: "set",
      259: "esro-gen",
      260: "openport",
      261: "nsiiops",
      262: "arcisdms",
      263: "hdap",
      264: "bgmp",
      265: "x-bone-ctl",
      266: "sst",
      267: "td-service",
      268: "td-replica",
      269: "manet",
      270: "gist",
      271: "pt-tls",
      280: "http-mgmt",
      281: "personal-link",
      282: "cableport-ax",
      283: "rescap",
      284: "corerjd",
      286: "fxp",
      287: "k-block",
      308: "novastorbakcup",
      309: "entrusttime",
      310: "bhmds",
      311: "asip-webadmin",
      312: "vslmp",
      313: "magenta-logic",
      314: "opalis-robot",
      315: "dpsi",
      316: "decauth",
      317: "zannet",
      318: "pkix-timestamp",
      319: "ptp-event",
      320: "ptp-general",
      321: "pip",
      322: "rtsps",
      323: "rpki-rtr",
      324: "rpki-rtr-tls",
      333: "texar",
      344: "pdap",
      345: "pawserv",
      346: "zserv",
      347: "fatserv",
      348: "csi-sgwp",
      349: "mftp",
      350: "matip-type-a",
      351: "bhoetty",
      352: "bhoedap4",
      353: "ndsauth",
      354: "bh611",
      355: "datex-asn",
      356: "cloanto-net-1",
      357: "bhevent",
      358: "shrinkwrap",
      359: "nsrmp",
      360: "scoi2odialog",
      361: "semantix",
      362: "srssend",
      363: "rsvp_tunnel",
      364: "aurora-cmgr",
      365: "dtk",
      366: "odmr",
      367: "mortgageware",
      368: "qbikgdp",
      369: "rpc2portmap",
      370: "codaauth2",
      371: "clearcase",
      372: "ulistproc",
      373: "legent-1",
      374: "legent-2",
      375: "hassle",
      376: "nip",
      377: "tnETOS",
      378: "dsETOS",
      379: "is99c",
      380: "is99s",
      381: "hp-collector",
      382: "hp-managed-node",
      383: "hp-alarm-mgr",
      384: "arns",
      385: "ibm-app",
      386: "asa",
      387: "aurp",
      388: "unidata-ldm",
      389: "ldap",
      390: "uis",
      391: "synotics-relay",
      392: "synotics-broker",
      393: "meta5",
      394: "embl-ndt",
      395: "netcp",
      396: "netware-ip",
      397: "mptn",
      398: "kryptolan",
      399: "iso-tsap-c2",
      400: "osb-sd",
      401: "ups",
      402: "genie",
      403: "decap",
      404: "nced",
      405: "ncld",
      406: "imsp",
      407: "timbuktu",
      408: "prm-sm",
      409: "prm-nm",
      410: "decladebug",
      411: "rmt",
      412: "synoptics-trap",
      413: "smsp",
      414: "infoseek",
      415: "bnet",
      416: "silverplatter",
      417: "onmux",
      418: "hyper-g",
      419: "ariel1",
      420: "smpte",
      421: "ariel2",
      422: "ariel3",
      423: "opc-job-start",
      424: "opc-job-track",
      425: "icad-el",
      426: "smartsdp",
      427: "svrloc",
      428: "ocs_cmu",
      429: "ocs_amu",
      430: "utmpsd",
      431: "utmpcd",
      432: "iasd",
      433: "nnsp",
      434: "mobileip-agent",
      435: "mobilip-mn",
      436: "dna-cml",
      437: "comscm",
      438: "dsfgw",
      439: "dasp",
      440: "sgcp",
      441: "decvms-sysmgt",
      442: "cvc_hostd",
      443: "https",
      444: "snpp",
      445: "microsoft-ds",
      446: "ddm-rdb",
      447: "ddm-dfm",
      448: "ddm-ssl",
      449: "as-servermap",
      450: "tserver",
      451: "sfs-smp-net",
      452: "sfs-config",
      453: "creativeserver",
      454: "contentserver",
      455: "creativepartnr",
      456: "macon-udp",
      457: "scohelp",
      458: "appleqtc",
      459: "ampr-rcmd",
      460: "skronk",
      461: "datasurfsrv",
      462: "datasurfsrvsec",
      463: "alpes",
      464: "kpasswd",
      465: "igmpv3lite",
      466: "digital-vrc",
      467: "mylex-mapd",
      468: "photuris",
      469: "rcp",
      470: "scx-proxy",
      471: "mondex",
      472: "ljk-login",
      473: "hybrid-pop",
      474: "tn-tl-w2",
      475: "tcpnethaspsrv",
      476: "tn-tl-fd1",
      477: "ss7ns",
      478: "spsc",
      479: "iafserver",
      480: "iafdbase",
      481: "ph",
      482: "bgs-nsi",
      483: "ulpnet",
      484: "integra-sme",
      485: "powerburst",
      486: "avian",
      487: "saft",
      488: "gss-http",
      489: "nest-protocol",
      490: "micom-pfs",
      491: "go-login",
      492: "ticf-1",
      493: "ticf-2",
      494: "pov-ray",
      495: "intecourier",
      496: "pim-rp-disc",
      497: "retrospect",
      498: "siam",
      499: "iso-ill",
      500: "isakmp",
      501: "stmf",
      502: "mbap",
      503: "intrinsa",
      504: "citadel",
      505: "mailbox-lm",
      506: "ohimsrv",
      507: "crs",
      508: "xvttp",
      509: "snare",
      510: "fcp",
      511: "passgo",
      512: "biff",
      513: "who",
      514: "syslog",
      515: "printer",
      516: "videotex",
      517: "talk",
      518: "ntalk",
      519: "utime",
      520: "router",
      521: "ripng",
      522: "ulp",
      523: "ibm-db2",
      524: "ncp",
      525: "timed",
      526: "tempo",
      527: "stx",
      528: "custix",
      529: "irc-serv",
      530: "courier",
      531: "conference",
      532: "netnews",
      533: "netwall",
      534: "windream",
      535: "iiop",
      536: "opalis-rdv",
      537: "nmsp",
      538: "gdomap",
      539: "apertus-ldp",
      540: "uucp",
      541: "uucp-rlogin",
      542: "commerce",
      543: "klogin",
      544: "kshell",
      545: "appleqtcsrvr",
      546: "dhcpv6-client",
      547: "dhcpv6-server",
      548: "afpovertcp",
      549: "idfp",
      550: "new-rwho",
      551: "cybercash",
      552: "devshr-nts",
      553: "pirp",
      554: "rtsp",
      555: "dsf",
      556: "remotefs",
      557: "openvms-sysipc",
      558: "sdnskmp",
      559: "teedtap",
      560: "rmonitor",
      561: "monitor",
      562: "chshell",
      563: "nntps",
      564: "9pfs",
      565: "whoami",
      566: "streettalk",
      567: "banyan-rpc",
      568: "ms-shuttle",
      569: "ms-rome",
      570: "meter",
      571: "meter",
      572: "sonar",
      573: "banyan-vip",
      574: "ftp-agent",
      575: "vemmi",
      576: "ipcd",
      577: "vnas",
      578: "ipdd",
      579: "decbsrv",
      580: "sntp-heartbeat",
      581: "bdp",
      582: "scc-security",
      583: "philips-vc",
      584: "keyserver",
      586: "password-chg",
      587: "submission",
      588: "cal",
      589: "eyelink",
      590: "tns-cml",
      591: "http-alt",
      592: "eudora-set",
      593: "http-rpc-epmap",
      594: "tpip",
      595: "cab-protocol",
      596: "smsd",
      597: "ptcnameservice",
      598: "sco-websrvrmg3",
      599: "acp",
      600: "ipcserver",
      601: "syslog-conn",
      602: "xmlrpc-beep",
      603: "idxp",
      604: "tunnel",
      605: "soap-beep",
      606: "urm",
      607: "nqs",
      608: "sift-uft",
      609: "npmp-trap",
      610: "npmp-local",
      611: "npmp-gui",
      612: "hmmp-ind",
      613: "hmmp-op",
      614: "sshell",
      615: "sco-inetmgr",
      616: "sco-sysmgr",
      617: "sco-dtmgr",
      618: "dei-icda",
      619: "compaq-evm",
      620: "sco-websrvrmgr",
      621: "escp-ip",
      622: "collaborator",
      623: "asf-rmcp",
      624: "cryptoadmin",
      625: "dec_dlm",
      626: "asia",
      627: "passgo-tivoli",
      628: "qmqp",
      629: "3com-amp3",
      630: "rda",
      631: "ipps",
      632: "bmpp",
      633: "servstat",
      634: "ginad",
      635: "rlzdbase",
      636: "ldaps",
      637: "lanserver",
      638: "mcns-sec",
      639: "msdp",
      640: "entrust-sps",
      641: "repcmd",
      642: "esro-emsdp",
      643: "sanity",
      644: "dwr",
      645: "pssc",
      646: "ldp",
      647: "dhcp-failover",
      648: "rrp",
      649: "cadview-3d",
      650: "obex",
      651: "ieee-mms",
      652: "hello-port",
      653: "repscmd",
      654: "aodv",
      655: "tinc",
      656: "spmp",
      657: "rmc",
      658: "tenfold",
      660: "mac-srvr-admin",
      661: "hap",
      662: "pftp",
      663: "purenoise",
      664: "asf-secure-rmcp",
      665: "sun-dr",
      666: "doom",
      667: "disclose",
      668: "mecomm",
      669: "meregister",
      670: "vacdsm-sws",
      671: "vacdsm-app",
      672: "vpps-qua",
      673: "cimplex",
      674: "acap",
      675: "dctp",
      676: "vpps-via",
      677: "vpp",
      678: "ggf-ncp",
      679: "mrm",
      680: "entrust-aaas",
      681: "entrust-aams",
      682: "xfr",
      683: "corba-iiop",
      684: "corba-iiop-ssl",
      685: "mdc-portmapper",
      686: "hcp-wismar",
      687: "asipregistry",
      688: "realm-rusd",
      689: "nmap",
      690: "vatp",
      691: "msexch-routing",
      692: "hyperwave-isp",
      693: "connendp",
      694: "ha-cluster",
      695: "ieee-mms-ssl",
      696: "rushd",
      697: "uuidgen",
      698: "olsr",
      699: "accessnetwork",
      700: "epp",
      701: "lmp",
      702: "iris-beep",
      704: "elcsd",
      705: "agentx",
      706: "silc",
      707: "borland-dsj",
      709: "entrust-kmsh",
      710: "entrust-ash",
      711: "cisco-tdp",
      712: "tbrpf",
      713: "iris-xpc",
      714: "iris-xpcs",
      715: "iris-lwz",
      716: "pana",
      729: "netviewdm1",
      730: "netviewdm2",
      731: "netviewdm3",
      741: "netgw",
      742: "netrcs",
      744: "flexlm",
      747: "fujitsu-dev",
      748: "ris-cm",
      749: "kerberos-adm",
      750: "kerberos-iv",
      751: "pump",
      752: "qrh",
      753: "rrh",
      754: "tell",
      758: "nlogin",
      759: "con",
      760: "ns",
      761: "rxe",
      762: "quotad",
      763: "cycleserv",
      764: "omserv",
      765: "webster",
      767: "phonebook",
      769: "vid",
      770: "cadlock",
      771: "rtip",
      772: "cycleserv2",
      773: "notify",
      774: "acmaint_dbd",
      775: "acmaint_transd",
      776: "wpages",
      777: "multiling-http",
      780: "wpgs",
      800: "mdbs_daemon",
      801: "device",
      802: "mbap-s",
      810: "fcp-udp",
      828: "itm-mcell-s",
      829: "pkix-3-ca-ra",
      830: "netconf-ssh",
      831: "netconf-beep",
      832: "netconfsoaphttp",
      833: "netconfsoapbeep",
      847: "dhcp-failover2",
      848: "gdoi",
      853: "domain-s",
      854: "dlep",
      860: "iscsi",
      861: "owamp-test",
      862: "twamp-test",
      873: "rsync",
      886: "iclcnet-locate",
      887: "iclcnet_svinfo",
      888: "cddbp",
      900: "omginitialrefs",
      901: "smpnameres",
      902: "ideafarm-door",
      903: "ideafarm-panic",
      910: "kink",
      911: "xact-backup",
      912: "apex-mesh",
      913: "apex-edge",
      953: "rndc",
      989: "ftps-data",
      990: "ftps",
      991: "nas",
      992: "telnets",
      993: "imaps",
      995: "pop3s",
      996: "vsinet",
      997: "maitrd",
      998: "puparp",
      999: "puprouter",
      1000: "cadlock2",
      1001: "webpush",
      1010: "surf",
      1021: "exp1",
      1022: "exp2",
      1025: "blackjack",
      1026: "cap",
      1027: "6a44",
      1029: "solid-mux",
      1033: "netinfo-local",
      1034: "activesync",
      1035: "mxxrlogin",
      1036: "nsstp",
      1037: "ams",
      1038: "mtqp",
      1039: "sbl",
      1040: "netarx",
      1041: "danf-ak2",
      1042: "afrog",
      1043: "boinc-client",
      1044: "dcutility",
      1045: "fpitp",
      1046: "wfremotertm",
      1047: "neod1",
      1048: "neod2",
      1049: "td-postman",
      1050: "cma",
      1051: "optima-vnet",
      1052: "ddt",
      1053: "remote-as",
      1054: "brvread",
      1055: "ansyslmd",
      1056: "vfo",
      1057: "startron",
      1058: "nim",
      1059: "nimreg",
      1060: "polestar",
      1061: "kiosk",
      1062: "veracity",
      1063: "kyoceranetdev",
      1064: "jstel",
      1065: "syscomlan",
      1066: "fpo-fns",
      1067: "instl_boots",
      1068: "instl_bootc",
      1069: "cognex-insight",
      1070: "gmrupdateserv",
      1071: "bsquare-voip",
      1072: "cardax",
      1073: "bridgecontrol",
      1074: "warmspotMgmt",
      1075: "rdrmshc",
      1076: "dab-sti-c",
      1077: "imgames",
      1078: "avocent-proxy",
      1079: "asprovatalk",
      1080: "socks",
      1081: "pvuniwien",
      1082: "amt-esd-prot",
      1083: "ansoft-lm-1",
      1084: "ansoft-lm-2",
      1085: "webobjects",
      1086: "cplscrambler-lg",
      1087: "cplscrambler-in",
      1088: "cplscrambler-al",
      1089: "ff-annunc",
      1090: "ff-fms",
      1091: "ff-sm",
      1092: "obrpd",
      1093: "proofd",
      1094: "rootd",
      1095: "nicelink",
      1096: "cnrprotocol",
      1097: "sunclustermgr",
      1098: "rmiactivation",
      1099: "rmiregistry",
      1100: "mctp",
      1101: "pt2-discover",
      1102: "adobeserver-1",
      1103: "adobeserver-2",
      1104: "xrl",
      1105: "ftranhc",
      1106: "isoipsigport-1",
      1107: "isoipsigport-2",
      1108: "ratio-adp",
      1110: "nfsd-keepalive",
      1111: "lmsocialserver",
      1112: "icp",
      1113: "ltp-deepspace",
      1114: "mini-sql",
      1115: "ardus-trns",
      1116: "ardus-cntl",
      1117: "ardus-mtrns",
      1118: "sacred",
      1119: "bnetgame",
      1120: "bnetfile",
      1121: "rmpp",
      1122: "availant-mgr",
      1123: "murray",
      1124: "hpvmmcontrol",
      1125: "hpvmmagent",
      1126: "hpvmmdata",
      1127: "kwdb-commn",
      1128: "saphostctrl",
      1129: "saphostctrls",
      1130: "casp",
      1131: "caspssl",
      1132: "kvm-via-ip",
      1133: "dfn",
      1134: "aplx",
      1135: "omnivision",
      1136: "hhb-gateway",
      1137: "trim",
      1138: "encrypted_admin",
      1139: "evm",
      1140: "autonoc",
      1141: "mxomss",
      1142: "edtools",
      1143: "imyx",
      1144: "fuscript",
      1145: "x9-icue",
      1146: "audit-transfer",
      1147: "capioverlan",
      1148: "elfiq-repl",
      1149: "bvtsonar",
      1150: "blaze",
      1151: "unizensus",
      1152: "winpoplanmess",
      1153: "c1222-acse",
      1154: "resacommunity",
      1155: "nfa",
      1156: "iascontrol-oms",
      1157: "iascontrol",
      1158: "dbcontrol-oms",
      1159: "oracle-oms",
      1160: "olsv",
      1161: "health-polling",
      1162: "health-trap",
      1163: "sddp",
      1164: "qsm-proxy",
      1165: "qsm-gui",
      1166: "qsm-remote",
      1167: "cisco-ipsla",
      1168: "vchat",
      1169: "tripwire",
      1170: "atc-lm",
      1171: "atc-appserver",
      1172: "dnap",
      1173: "d-cinema-rrp",
      1174: "fnet-remote-ui",
      1175: "dossier",
      1176: "indigo-server",
      1177: "dkmessenger",
      1178: "sgi-storman",
      1179: "b2n",
      1180: "mc-client",
      1181: "3comnetman",
      1182: "accelenet-data",
      1183: "llsurfup-http",
      1184: "llsurfup-https",
      1185: "catchpole",
      1186: "mysql-cluster",
      1187: "alias",
      1188: "hp-webadmin",
      1189: "unet",
      1190: "commlinx-avl",
      1191: "gpfs",
      1192: "caids-sensor",
      1193: "fiveacross",
      1194: "openvpn",
      1195: "rsf-1",
      1196: "netmagic",
      1197: "carrius-rshell",
      1198: "cajo-discovery",
      1199: "dmidi",
      1200: "scol",
      1201: "nucleus-sand",
      1202: "caiccipc",
      1203: "ssslic-mgr",
      1204: "ssslog-mgr",
      1205: "accord-mgc",
      1206: "anthony-data",
      1207: "metasage",
      1208: "seagull-ais",
      1209: "ipcd3",
      1210: "eoss",
      1211: "groove-dpp",
      1212: "lupa",
      1213: "mpc-lifenet",
      1214: "kazaa",
      1215: "scanstat-1",
      1216: "etebac5",
      1217: "hpss-ndapi",
      1218: "aeroflight-ads",
      1219: "aeroflight-ret",
      1220: "qt-serveradmin",
      1221: "sweetware-apps",
      1222: "nerv",
      1223: "tgp",
      1224: "vpnz",
      1225: "slinkysearch",
      1226: "stgxfws",
      1227: "dns2go",
      1228: "florence",
      1229: "zented",
      1230: "periscope",
      1231: "menandmice-lpm",
      1232: "first-defense",
      1233: "univ-appserver",
      1234: "search-agent",
      1235: "mosaicsyssvc1",
      1236: "bvcontrol",
      1237: "tsdos390",
      1238: "hacl-qs",
      1239: "nmsd",
      1240: "instantia",
      1241: "nessus",
      1242: "nmasoverip",
      1243: "serialgateway",
      1244: "isbconference1",
      1245: "isbconference2",
      1246: "payrouter",
      1247: "visionpyramid",
      1248: "hermes",
      1249: "mesavistaco",
      1250: "swldy-sias",
      1251: "servergraph",
      1252: "bspne-pcc",
      1253: "q55-pcc",
      1254: "de-noc",
      1255: "de-cache-query",
      1256: "de-server",
      1257: "shockwave2",
      1258: "opennl",
      1259: "opennl-voice",
      1260: "ibm-ssd",
      1261: "mpshrsv",
      1262: "qnts-orb",
      1263: "dka",
      1264: "prat",
      1265: "dssiapi",
      1266: "dellpwrappks",
      1267: "epc",
      1268: "propel-msgsys",
      1269: "watilapp",
      1270: "opsmgr",
      1271: "excw",
      1272: "cspmlockmgr",
      1273: "emc-gateway",
      1274: "t1distproc",
      1275: "ivcollector",
      1277: "miva-mqs",
      1278: "dellwebadmin-1",
      1279: "dellwebadmin-2",
      1280: "pictrography",
      1281: "healthd",
      1282: "emperion",
      1283: "productinfo",
      1284: "iee-qfx",
      1285: "neoiface",
      1286: "netuitive",
      1287: "routematch",
      1288: "navbuddy",
      1289: "jwalkserver",
      1290: "winjaserver",
      1291: "seagulllms",
      1292: "dsdn",
      1293: "pkt-krb-ipsec",
      1294: "cmmdriver",
      1295: "ehtp",
      1296: "dproxy",
      1297: "sdproxy",
      1298: "lpcp",
      1299: "hp-sci",
      1300: "h323hostcallsc",
      1303: "sftsrv",
      1304: "boomerang",
      1305: "pe-mike",
      1306: "re-conn-proto",
      1307: "pacmand",
      1308: "odsi",
      1309: "jtag-server",
      1310: "husky",
      1311: "rxmon",
      1312: "sti-envision",
      1313: "bmc_patroldb",
      1314: "pdps",
      1315: "els",
      1316: "exbit-escp",
      1317: "vrts-ipcserver",
      1318: "krb5gatekeeper",
      1319: "amx-icsp",
      1320: "amx-axbnet",
      1321: "pip",
      1322: "novation",
      1323: "brcd",
      1324: "delta-mcp",
      1325: "dx-instrument",
      1326: "wimsic",
      1327: "ultrex",
      1328: "ewall",
      1329: "netdb-export",
      1330: "streetperfect",
      1331: "intersan",
      1332: "pcia-rxp-b",
      1333: "passwrd-policy",
      1334: "writesrv",
      1335: "digital-notary",
      1336: "ischat",
      1337: "menandmice-dns",
      1338: "wmc-log-svc",
      1339: "kjtsiteserver",
      1340: "naap",
      1341: "qubes",
      1342: "esbroker",
      1343: "re101",
      1344: "icap",
      1345: "vpjp",
      1346: "alta-ana-lm",
      1347: "bbn-mmc",
      1348: "bbn-mmx",
      1349: "sbook",
      1350: "editbench",
      1351: "equationbuilder",
      1352: "lotusnote",
      1353: "relief",
      1354: "XSIP-network",
      1355: "intuitive-edge",
      1356: "cuillamartin",
      1357: "pegboard",
      1358: "connlcli",
      1359: "ftsrv",
      1360: "mimer",
      1361: "linx",
      1362: "timeflies",
      1363: "ndm-requester",
      1364: "ndm-server",
      1365: "adapt-sna",
      1366: "netware-csp",
      1367: "dcs",
      1368: "screencast",
      1369: "gv-us",
      1370: "us-gv",
      1371: "fc-cli",
      1372: "fc-ser",
      1373: "chromagrafx",
      1374: "molly",
      1375: "bytex",
      1376: "ibm-pps",
      1377: "cichlid",
      1378: "elan",
      1379: "dbreporter",
      1380: "telesis-licman",
      1381: "apple-licman",
      1382: "udt_os",
      1383: "gwha",
      1384: "os-licman",
      1385: "atex_elmd",
      1386: "checksum",
      1387: "cadsi-lm",
      1388: "objective-dbc",
      1389: "iclpv-dm",
      1390: "iclpv-sc",
      1391: "iclpv-sas",
      1392: "iclpv-pm",
      1393: "iclpv-nls",
      1394: "iclpv-nlc",
      1395: "iclpv-wsm",
      1396: "dvl-activemail",
      1397: "audio-activmail",
      1398: "video-activmail",
      1399: "cadkey-licman",
      1400: "cadkey-tablet",
      1401: "goldleaf-licman",
      1402: "prm-sm-np",
      1403: "prm-nm-np",
      1404: "igi-lm",
      1405: "ibm-res",
      1406: "netlabs-lm",
      1407: "tibet-server",
      1408: "sophia-lm",
      1409: "here-lm",
      1410: "hiq",
      1411: "af",
      1412: "innosys",
      1413: "innosys-acl",
      1414: "ibm-mqseries",
      1415: "dbstar",
      1416: "novell-lu6.2",
      1417: "timbuktu-srv1",
      1418: "timbuktu-srv2",
      1419: "timbuktu-srv3",
      1420: "timbuktu-srv4",
      1421: "gandalf-lm",
      1422: "autodesk-lm",
      1423: "essbase",
      1424: "hybrid",
      1425: "zion-lm",
      1426: "sais",
      1427: "mloadd",
      1428: "informatik-lm",
      1429: "nms",
      1430: "tpdu",
      1431: "rgtp",
      1432: "blueberry-lm",
      1433: "ms-sql-s",
      1434: "ms-sql-m",
      1435: "ibm-cics",
      1436: "saism",
      1437: "tabula",
      1438: "eicon-server",
      1439: "eicon-x25",
      1440: "eicon-slp",
      1441: "cadis-1",
      1442: "cadis-2",
      1443: "ies-lm",
      1444: "marcam-lm",
      1445: "proxima-lm",
      1446: "ora-lm",
      1447: "apri-lm",
      1448: "oc-lm",
      1449: "peport",
      1450: "dwf",
      1451: "infoman",
      1452: "gtegsc-lm",
      1453: "genie-lm",
      1454: "interhdl_elmd",
      1455: "esl-lm",
      1456: "dca",
      1457: "valisys-lm",
      1458: "nrcabq-lm",
      1459: "proshare1",
      1460: "proshare2",
      1461: "ibm_wrless_lan",
      1462: "world-lm",
      1463: "nucleus",
      1464: "msl_lmd",
      1465: "pipes",
      1466: "oceansoft-lm",
      1467: "csdmbase",
      1468: "csdm",
      1469: "aal-lm",
      1470: "uaiact",
      1471: "csdmbase",
      1472: "csdm",
      1473: "openmath",
      1474: "telefinder",
      1475: "taligent-lm",
      1476: "clvm-cfg",
      1477: "ms-sna-server",
      1478: "ms-sna-base",
      1479: "dberegister",
      1480: "pacerforum",
      1481: "airs",
      1482: "miteksys-lm",
      1483: "afs",
      1484: "confluent",
      1485: "lansource",
      1486: "nms_topo_serv",
      1487: "localinfosrvr",
      1488: "docstor",
      1489: "dmdocbroker",
      1490: "insitu-conf",
      1492: "stone-design-1",
      1493: "netmap_lm",
      1494: "ica",
      1495: "cvc",
      1496: "liberty-lm",
      1497: "rfx-lm",
      1498: "sybase-sqlany",
      1499: "fhc",
      1500: "vlsi-lm",
      1501: "saiscm",
      1502: "shivadiscovery",
      1503: "imtc-mcs",
      1504: "evb-elm",
      1505: "funkproxy",
      1506: "utcd",
      1507: "symplex",
      1508: "diagmond",
      1509: "robcad-lm",
      1510: "mvx-lm",
      1511: "3l-l1",
      1512: "wins",
      1513: "fujitsu-dtc",
      1514: "fujitsu-dtcns",
      1515: "ifor-protocol",
      1516: "vpad",
      1517: "vpac",
      1518: "vpvd",
      1519: "vpvc",
      1520: "atm-zip-office",
      1521: "ncube-lm",
      1522: "ricardo-lm",
      1523: "cichild-lm",
      1524: "ingreslock",
      1525: "prospero-np",
      1526: "pdap-np",
      1527: "tlisrv",
      1528: "norp",
      1529: "coauthor",
      1530: "rap-service",
      1531: "rap-listen",
      1532: "miroconnect",
      1533: "virtual-places",
      1534: "micromuse-lm",
      1535: "ampr-info",
      1536: "ampr-inter",
      1537: "sdsc-lm",
      1538: "3ds-lm",
      1539: "intellistor-lm",
      1540: "rds",
      1541: "rds2",
      1542: "gridgen-elmd",
      1543: "simba-cs",
      1544: "aspeclmd",
      1545: "vistium-share",
      1546: "abbaccuray",
      1547: "laplink",
      1548: "axon-lm",
      1549: "shivasound",
      1550: "3m-image-lm",
      1551: "hecmtl-db",
      1552: "pciarray",
      1553: "sna-cs",
      1554: "caci-lm",
      1555: "livelan",
      1556: "veritas_pbx",
      1557: "arbortext-lm",
      1558: "xingmpeg",
      1559: "web2host",
      1560: "asci-val",
      1561: "facilityview",
      1562: "pconnectmgr",
      1563: "cadabra-lm",
      1564: "pay-per-view",
      1565: "winddlb",
      1566: "corelvideo",
      1567: "jlicelmd",
      1568: "tsspmap",
      1569: "ets",
      1570: "orbixd",
      1571: "rdb-dbs-disp",
      1572: "chip-lm",
      1573: "itscomm-ns",
      1574: "mvel-lm",
      1575: "oraclenames",
      1576: "moldflow-lm",
      1577: "hypercube-lm",
      1578: "jacobus-lm",
      1579: "ioc-sea-lm",
      1580: "tn-tl-r2",
      1581: "mil-2045-47001",
      1582: "msims",
      1583: "simbaexpress",
      1584: "tn-tl-fd2",
      1585: "intv",
      1586: "ibm-abtact",
      1587: "pra_elmd",
      1588: "triquest-lm",
      1589: "vqp",
      1590: "gemini-lm",
      1591: "ncpm-pm",
      1592: "commonspace",
      1593: "mainsoft-lm",
      1594: "sixtrak",
      1595: "radio",
      1596: "radio-bc",
      1597: "orbplus-iiop",
      1598: "picknfs",
      1599: "simbaservices",
      1600: "issd",
      1601: "aas",
      1602: "inspect",
      1603: "picodbc",
      1604: "icabrowser",
      1605: "slp",
      1606: "slm-api",
      1607: "stt",
      1608: "smart-lm",
      1609: "isysg-lm",
      1610: "taurus-wh",
      1611: "ill",
      1612: "netbill-trans",
      1613: "netbill-keyrep",
      1614: "netbill-cred",
      1615: "netbill-auth",
      1616: "netbill-prod",
      1617: "nimrod-agent",
      1618: "skytelnet",
      1619: "xs-openstorage",
      1620: "faxportwinport",
      1621: "softdataphone",
      1622: "ontime",
      1623: "jaleosnd",
      1624: "udp-sr-port",
      1625: "svs-omagent",
      1626: "shockwave",
      1627: "t128-gateway",
      1628: "lontalk-norm",
      1629: "lontalk-urgnt",
      1630: "oraclenet8cman",
      1631: "visitview",
      1632: "pammratc",
      1633: "pammrpc",
      1634: "loaprobe",
      1635: "edb-server1",
      1636: "isdc",
      1637: "islc",
      1638: "ismc",
      1639: "cert-initiator",
      1640: "cert-responder",
      1641: "invision",
      1642: "isis-am",
      1643: "isis-ambc",
      1644: "saiseh",
      1645: "sightline",
      1646: "sa-msg-port",
      1647: "rsap",
      1648: "concurrent-lm",
      1649: "kermit",
      1650: "nkd",
      1651: "shiva_confsrvr",
      1652: "xnmp",
      1653: "alphatech-lm",
      1654: "stargatealerts",
      1655: "dec-mbadmin",
      1656: "dec-mbadmin-h",
      1657: "fujitsu-mmpdc",
      1658: "sixnetudr",
      1659: "sg-lm",
      1660: "skip-mc-gikreq",
      1661: "netview-aix-1",
      1662: "netview-aix-2",
      1663: "netview-aix-3",
      1664: "netview-aix-4",
      1665: "netview-aix-5",
      1666: "netview-aix-6",
      1667: "netview-aix-7",
      1668: "netview-aix-8",
      1669: "netview-aix-9",
      1670: "netview-aix-10",
      1671: "netview-aix-11",
      1672: "netview-aix-12",
      1673: "proshare-mc-1",
      1674: "proshare-mc-2",
      1675: "pdp",
      1676: "netcomm2",
      1677: "groupwise",
      1678: "prolink",
      1679: "darcorp-lm",
      1680: "microcom-sbp",
      1681: "sd-elmd",
      1682: "lanyon-lantern",
      1683: "ncpm-hip",
      1684: "snaresecure",
      1685: "n2nremote",
      1686: "cvmon",
      1687: "nsjtp-ctrl",
      1688: "nsjtp-data",
      1689: "firefox",
      1690: "ng-umds",
      1691: "empire-empuma",
      1692: "sstsys-lm",
      1693: "rrirtr",
      1694: "rrimwm",
      1695: "rrilwm",
      1696: "rrifmm",
      1697: "rrisat",
      1698: "rsvp-encap-1",
      1699: "rsvp-encap-2",
      1700: "mps-raft",
      1701: "l2tp",
      1702: "deskshare",
      1703: "hb-engine",
      1704: "bcs-broker",
      1705: "slingshot",
      1706: "jetform",
      1707: "vdmplay",
      1708: "gat-lmd",
      1709: "centra",
      1710: "impera",
      1711: "pptconference",
      1712: "registrar",
      1713: "conferencetalk",
      1714: "sesi-lm",
      1715: "houdini-lm",
      1716: "xmsg",
      1717: "fj-hdnet",
      1718: "h323gatedisc",
      1719: "h323gatestat",
      1720: "h323hostcall",
      1721: "caicci",
      1722: "hks-lm",
      1723: "pptp",
      1724: "csbphonemaster",
      1725: "iden-ralp",
      1726: "iberiagames",
      1727: "winddx",
      1728: "telindus",
      1729: "citynl",
      1730: "roketz",
      1731: "msiccp",
      1732: "proxim",
      1733: "siipat",
      1734: "cambertx-lm",
      1735: "privatechat",
      1736: "street-stream",
      1737: "ultimad",
      1738: "gamegen1",
      1739: "webaccess",
      1740: "encore",
      1741: "cisco-net-mgmt",
      1742: "3Com-nsd",
      1743: "cinegrfx-lm",
      1744: "ncpm-ft",
      1745: "remote-winsock",
      1746: "ftrapid-1",
      1747: "ftrapid-2",
      1748: "oracle-em1",
      1749: "aspen-services",
      1750: "sslp",
      1751: "swiftnet",
      1752: "lofr-lm",
      1753: "predatar-comms",
      1754: "oracle-em2",
      1755: "ms-streaming",
      1756: "capfast-lmd",
      1757: "cnhrp",
      1758: "tftp-mcast",
      1759: "spss-lm",
      1760: "www-ldap-gw",
      1761: "cft-0",
      1762: "cft-1",
      1763: "cft-2",
      1764: "cft-3",
      1765: "cft-4",
      1766: "cft-5",
      1767: "cft-6",
      1768: "cft-7",
      1769: "bmc-net-adm",
      1770: "bmc-net-svc",
      1771: "vaultbase",
      1772: "essweb-gw",
      1773: "kmscontrol",
      1774: "global-dtserv",
      1775: "vdab",
      1776: "femis",
      1777: "powerguardian",
      1778: "prodigy-intrnet",
      1779: "pharmasoft",
      1780: "dpkeyserv",
      1781: "answersoft-lm",
      1782: "hp-hcip",
      1784: "finle-lm",
      1785: "windlm",
      1786: "funk-logger",
      1787: "funk-license",
      1788: "psmond",
      1789: "hello",
      1790: "nmsp",
      1791: "ea1",
      1792: "ibm-dt-2",
      1793: "rsc-robot",
      1794: "cera-bcm",
      1795: "dpi-proxy",
      1796: "vocaltec-admin",
      1797: "uma",
      1798: "etp",
      1799: "netrisk",
      1800: "ansys-lm",
      1801: "msmq",
      1802: "concomp1",
      1803: "hp-hcip-gwy",
      1804: "enl",
      1805: "enl-name",
      1806: "musiconline",
      1807: "fhsp",
      1808: "oracle-vp2",
      1809: "oracle-vp1",
      1810: "jerand-lm",
      1811: "scientia-sdb",
      1812: "radius",
      1813: "radius-acct",
      1814: "tdp-suite",
      1815: "mmpft",
      1816: "harp",
      1817: "rkb-oscs",
      1818: "etftp",
      1819: "plato-lm",
      1820: "mcagent",
      1821: "donnyworld",
      1822: "es-elmd",
      1823: "unisys-lm",
      1824: "metrics-pas",
      1825: "direcpc-video",
      1826: "ardt",
      1827: "asi",
      1828: "itm-mcell-u",
      1829: "optika-emedia",
      1830: "net8-cman",
      1831: "myrtle",
      1832: "tht-treasure",
      1833: "udpradio",
      1834: "ardusuni",
      1835: "ardusmul",
      1836: "ste-smsc",
      1837: "csoft1",
      1838: "talnet",
      1839: "netopia-vo1",
      1840: "netopia-vo2",
      1841: "netopia-vo3",
      1842: "netopia-vo4",
      1843: "netopia-vo5",
      1844: "direcpc-dll",
      1845: "altalink",
      1846: "tunstall-pnc",
      1847: "slp-notify",
      1848: "fjdocdist",
      1849: "alpha-sms",
      1850: "gsi",
      1851: "ctcd",
      1852: "virtual-time",
      1853: "vids-avtp",
      1854: "buddy-draw",
      1855: "fiorano-rtrsvc",
      1856: "fiorano-msgsvc",
      1857: "datacaptor",
      1858: "privateark",
      1859: "gammafetchsvr",
      1860: "sunscalar-svc",
      1861: "lecroy-vicp",
      1862: "mysql-cm-agent",
      1863: "msnp",
      1864: "paradym-31port",
      1865: "entp",
      1866: "swrmi",
      1867: "udrive",
      1868: "viziblebrowser",
      1869: "transact",
      1870: "sunscalar-dns",
      1871: "canocentral0",
      1872: "canocentral1",
      1873: "fjmpjps",
      1874: "fjswapsnp",
      1875: "westell-stats",
      1876: "ewcappsrv",
      1877: "hp-webqosdb",
      1878: "drmsmc",
      1879: "nettgain-nms",
      1880: "vsat-control",
      1881: "ibm-mqseries2",
      1882: "ecsqdmn",
      1883: "mqtt",
      1884: "idmaps",
      1885: "vrtstrapserver",
      1886: "leoip",
      1887: "filex-lport",
      1888: "ncconfig",
      1889: "unify-adapter",
      1890: "wilkenlistener",
      1891: "childkey-notif",
      1892: "childkey-ctrl",
      1893: "elad",
      1894: "o2server-port",
      1896: "b-novative-ls",
      1897: "metaagent",
      1898: "cymtec-port",
      1899: "mc2studios",
      1900: "ssdp",
      1901: "fjicl-tep-a",
      1902: "fjicl-tep-b",
      1903: "linkname",
      1904: "fjicl-tep-c",
      1905: "sugp",
      1906: "tpmd",
      1907: "intrastar",
      1908: "dawn",
      1909: "global-wlink",
      1910: "ultrabac",
      1911: "mtp",
      1912: "rhp-iibp",
      1913: "armadp",
      1914: "elm-momentum",
      1915: "facelink",
      1916: "persona",
      1917: "noagent",
      1918: "can-nds",
      1919: "can-dch",
      1920: "can-ferret",
      1921: "noadmin",
      1922: "tapestry",
      1923: "spice",
      1924: "xiip",
      1925: "discovery-port",
      1926: "egs",
      1927: "videte-cipc",
      1928: "emsd-port",
      1929: "bandwiz-system",
      1930: "driveappserver",
      1931: "amdsched",
      1932: "ctt-broker",
      1933: "xmapi",
      1934: "xaapi",
      1935: "macromedia-fcs",
      1936: "jetcmeserver",
      1937: "jwserver",
      1938: "jwclient",
      1939: "jvserver",
      1940: "jvclient",
      1941: "dic-aida",
      1942: "res",
      1943: "beeyond-media",
      1944: "close-combat",
      1945: "dialogic-elmd",
      1946: "tekpls",
      1947: "sentinelsrm",
      1948: "eye2eye",
      1949: "ismaeasdaqlive",
      1950: "ismaeasdaqtest",
      1951: "bcs-lmserver",
      1952: "mpnjsc",
      1953: "rapidbase",
      1954: "abr-api",
      1955: "abr-secure",
      1956: "vrtl-vmf-ds",
      1957: "unix-status",
      1958: "dxadmind",
      1959: "simp-all",
      1960: "nasmanager",
      1961: "bts-appserver",
      1962: "biap-mp",
      1963: "webmachine",
      1964: "solid-e-engine",
      1965: "tivoli-npm",
      1966: "slush",
      1967: "sns-quote",
      1968: "lipsinc",
      1969: "lipsinc1",
      1970: "netop-rc",
      1971: "netop-school",
      1972: "intersys-cache",
      1973: "dlsrap",
      1974: "drp",
      1975: "tcoflashagent",
      1976: "tcoregagent",
      1977: "tcoaddressbook",
      1978: "unisql",
      1979: "unisql-java",
      1980: "pearldoc-xact",
      1981: "p2pq",
      1982: "estamp",
      1983: "lhtp",
      1984: "bb",
      1985: "hsrp",
      1986: "licensedaemon",
      1987: "tr-rsrb-p1",
      1988: "tr-rsrb-p2",
      1989: "mshnet",
      1990: "stun-p1",
      1991: "stun-p2",
      1992: "ipsendmsg",
      1993: "snmp-tcp-port",
      1994: "stun-port",
      1995: "perf-port",
      1996: "tr-rsrb-port",
      1997: "gdp-port",
      1998: "x25-svc-port",
      1999: "tcp-id-port",
      2000: "cisco-sccp",
      2001: "wizard",
      2002: "globe",
      2003: "brutus",
      2004: "emce",
      2005: "oracle",
      2006: "raid-cd",
      2007: "raid-am",
      2008: "terminaldb",
      2009: "whosockami",
      2010: "pipe_server",
      2011: "servserv",
      2012: "raid-ac",
      2013: "raid-cd",
      2014: "raid-sf",
      2015: "raid-cs",
      2016: "bootserver",
      2017: "bootclient",
      2018: "rellpack",
      2019: "about",
      2020: "xinupageserver",
      2021: "xinuexpansion1",
      2022: "xinuexpansion2",
      2023: "xinuexpansion3",
      2024: "xinuexpansion4",
      2025: "xribs",
      2026: "scrabble",
      2027: "shadowserver",
      2028: "submitserver",
      2029: "hsrpv6",
      2030: "device2",
      2031: "mobrien-chat",
      2032: "blackboard",
      2033: "glogger",
      2034: "scoremgr",
      2035: "imsldoc",
      2036: "e-dpnet",
      2037: "applus",
      2038: "objectmanager",
      2039: "prizma",
      2040: "lam",
      2041: "interbase",
      2042: "isis",
      2043: "isis-bcast",
      2044: "rimsl",
      2045: "cdfunc",
      2046: "sdfunc",
      2047: "dls",
      2048: "dls-monitor",
      2049: "nfs",
      2050: "av-emb-config",
      2051: "epnsdp",
      2052: "clearvisn",
      2053: "lot105-ds-upd",
      2054: "weblogin",
      2055: "iop",
      2056: "omnisky",
      2057: "rich-cp",
      2058: "newwavesearch",
      2059: "bmc-messaging",
      2060: "teleniumdaemon",
      2061: "netmount",
      2062: "icg-swp",
      2063: "icg-bridge",
      2064: "icg-iprelay",
      2065: "dlsrpn",
      2066: "aura",
      2067: "dlswpn",
      2068: "avauthsrvprtcl",
      2069: "event-port",
      2070: "ah-esp-encap",
      2071: "acp-port",
      2072: "msync",
      2073: "gxs-data-port",
      2074: "vrtl-vmf-sa",
      2075: "newlixengine",
      2076: "newlixconfig",
      2077: "tsrmagt",
      2078: "tpcsrvr",
      2079: "idware-router",
      2080: "autodesk-nlm",
      2081: "kme-trap-port",
      2082: "infowave",
      2083: "radsec",
      2084: "sunclustergeo",
      2085: "ada-cip",
      2086: "gnunet",
      2087: "eli",
      2088: "ip-blf",
      2089: "sep",
      2090: "lrp",
      2091: "prp",
      2092: "descent3",
      2093: "nbx-cc",
      2094: "nbx-au",
      2095: "nbx-ser",
      2096: "nbx-dir",
      2097: "jetformpreview",
      2098: "dialog-port",
      2099: "h2250-annex-g",
      2100: "amiganetfs",
      2101: "rtcm-sc104",
      2102: "zephyr-srv",
      2103: "zephyr-clt",
      2104: "zephyr-hm",
      2105: "minipay",
      2106: "mzap",
      2107: "bintec-admin",
      2108: "comcam",
      2109: "ergolight",
      2110: "umsp",
      2111: "dsatp",
      2112: "idonix-metanet",
      2113: "hsl-storm",
      2114: "ariascribe",
      2115: "kdm",
      2116: "ccowcmr",
      2117: "mentaclient",
      2118: "mentaserver",
      2119: "gsigatekeeper",
      2120: "qencp",
      2121: "scientia-ssdb",
      2122: "caupc-remote",
      2123: "gtp-control",
      2124: "elatelink",
      2125: "lockstep",
      2126: "pktcable-cops",
      2127: "index-pc-wb",
      2128: "net-steward",
      2129: "cs-live",
      2130: "xds",
      2131: "avantageb2b",
      2132: "solera-epmap",
      2133: "zymed-zpp",
      2134: "avenue",
      2135: "gris",
      2136: "appworxsrv",
      2137: "connect",
      2138: "unbind-cluster",
      2139: "ias-auth",
      2140: "ias-reg",
      2141: "ias-admind",
      2142: "tdmoip",
      2143: "lv-jc",
      2144: "lv-ffx",
      2145: "lv-pici",
      2146: "lv-not",
      2147: "lv-auth",
      2148: "veritas-ucl",
      2149: "acptsys",
      2150: "dynamic3d",
      2151: "docent",
      2152: "gtp-user",
      2153: "ctlptc",
      2154: "stdptc",
      2155: "brdptc",
      2156: "trp",
      2157: "xnds",
      2158: "touchnetplus",
      2159: "gdbremote",
      2160: "apc-2160",
      2161: "apc-2161",
      2162: "navisphere",
      2163: "navisphere-sec",
      2164: "ddns-v3",
      2165: "x-bone-api",
      2166: "iwserver",
      2167: "raw-serial",
      2168: "easy-soft-mux",
      2169: "brain",
      2170: "eyetv",
      2171: "msfw-storage",
      2172: "msfw-s-storage",
      2173: "msfw-replica",
      2174: "msfw-array",
      2175: "airsync",
      2176: "rapi",
      2177: "qwave",
      2178: "bitspeer",
      2179: "vmrdp",
      2180: "mc-gt-srv",
      2181: "eforward",
      2182: "cgn-stat",
      2183: "cgn-config",
      2184: "nvd",
      2185: "onbase-dds",
      2186: "gtaua",
      2187: "ssmd",
      2188: "radware-rpm",
      2189: "radware-rpm-s",
      2190: "tivoconnect",
      2191: "tvbus",
      2192: "asdis",
      2193: "drwcs",
      2197: "mnp-exchange",
      2198: "onehome-remote",
      2199: "onehome-help",
      2201: "ats",
      2202: "imtc-map",
      2203: "b2-runtime",
      2204: "b2-license",
      2205: "jps",
      2206: "hpocbus",
      2207: "hpssd",
      2208: "hpiod",
      2209: "rimf-ps",
      2210: "noaaport",
      2211: "emwin",
      2212: "leecoposserver",
      2213: "kali",
      2214: "rpi",
      2215: "ipcore",
      2216: "vtu-comms",
      2217: "gotodevice",
      2218: "bounzza",
      2219: "netiq-ncap",
      2220: "netiq",
      2221: "ethernet-ip-s",
      2222: "EtherNet/IP-1",
      2223: "rockwell-csp2",
      2224: "efi-mg",
      2225: "rcip-itu",
      2226: "di-drm",
      2227: "di-msg",
      2228: "ehome-ms",
      2229: "datalens",
      2230: "queueadm",
      2231: "wimaxasncp",
      2232: "ivs-video",
      2233: "infocrypt",
      2234: "directplay",
      2235: "sercomm-wlink",
      2236: "nani",
      2237: "optech-port1-lm",
      2238: "aviva-sna",
      2239: "imagequery",
      2240: "recipe",
      2241: "ivsd",
      2242: "foliocorp",
      2243: "magicom",
      2244: "nmsserver",
      2245: "hao",
      2246: "pc-mta-addrmap",
      2247: "antidotemgrsvr",
      2248: "ums",
      2249: "rfmp",
      2250: "remote-collab",
      2251: "dif-port",
      2252: "njenet-ssl",
      2253: "dtv-chan-req",
      2254: "seispoc",
      2255: "vrtp",
      2256: "pcc-mfp",
      2257: "simple-tx-rx",
      2258: "rcts",
      2260: "apc-2260",
      2261: "comotionmaster",
      2262: "comotionback",
      2263: "ecwcfg",
      2264: "apx500api-1",
      2265: "apx500api-2",
      2266: "mfserver",
      2267: "ontobroker",
      2268: "amt",
      2269: "mikey",
      2270: "starschool",
      2271: "mmcals",
      2272: "mmcal",
      2273: "mysql-im",
      2274: "pcttunnell",
      2275: "ibridge-data",
      2276: "ibridge-mgmt",
      2277: "bluectrlproxy",
      2278: "s3db",
      2279: "xmquery",
      2280: "lnvpoller",
      2281: "lnvconsole",
      2282: "lnvalarm",
      2283: "lnvstatus",
      2284: "lnvmaps",
      2285: "lnvmailmon",
      2286: "nas-metering",
      2287: "dna",
      2288: "netml",
      2289: "dict-lookup",
      2290: "sonus-logging",
      2291: "eapsp",
      2292: "mib-streaming",
      2293: "npdbgmngr",
      2294: "konshus-lm",
      2295: "advant-lm",
      2296: "theta-lm",
      2297: "d2k-datamover1",
      2298: "d2k-datamover2",
      2299: "pc-telecommute",
      2300: "cvmmon",
      2301: "cpq-wbem",
      2302: "binderysupport",
      2303: "proxy-gateway",
      2304: "attachmate-uts",
      2305: "mt-scaleserver",
      2306: "tappi-boxnet",
      2307: "pehelp",
      2308: "sdhelp",
      2309: "sdserver",
      2310: "sdclient",
      2311: "messageservice",
      2312: "wanscaler",
      2313: "iapp",
      2314: "cr-websystems",
      2315: "precise-sft",
      2316: "sent-lm",
      2317: "attachmate-g32",
      2318: "cadencecontrol",
      2319: "infolibria",
      2320: "siebel-ns",
      2321: "rdlap",
      2322: "ofsd",
      2323: "3d-nfsd",
      2324: "cosmocall",
      2325: "ansysli",
      2326: "idcp",
      2327: "xingcsm",
      2328: "netrix-sftm",
      2329: "nvd",
      2330: "tscchat",
      2331: "agentview",
      2332: "rcc-host",
      2333: "snapp",
      2334: "ace-client",
      2335: "ace-proxy",
      2336: "appleugcontrol",
      2337: "ideesrv",
      2338: "norton-lambert",
      2339: "3com-webview",
      2340: "wrs_registry",
      2341: "xiostatus",
      2342: "manage-exec",
      2343: "nati-logos",
      2344: "fcmsys",
      2345: "dbm",
      2346: "redstorm_join",
      2347: "redstorm_find",
      2348: "redstorm_info",
      2349: "redstorm_diag",
      2350: "psbserver",
      2351: "psrserver",
      2352: "pslserver",
      2353: "pspserver",
      2354: "psprserver",
      2355: "psdbserver",
      2356: "gxtelmd",
      2357: "unihub-server",
      2358: "futrix",
      2359: "flukeserver",
      2360: "nexstorindltd",
      2361: "tl1",
      2362: "digiman",
      2363: "mediacntrlnfsd",
      2364: "oi-2000",
      2365: "dbref",
      2366: "qip-login",
      2367: "service-ctrl",
      2368: "opentable",
      2370: "l3-hbmon",
      2371: "rda",
      2372: "lanmessenger",
      2373: "remographlm",
      2374: "hydra",
      2375: "docker",
      2376: "docker-s",
      2377: "swarm",
      2378: "dali",
      2379: "etcd-client",
      2380: "etcd-server",
      2381: "compaq-https",
      2382: "ms-olap3",
      2383: "ms-olap4",
      2384: "sd-capacity",
      2385: "sd-data",
      2386: "virtualtape",
      2387: "vsamredirector",
      2388: "mynahautostart",
      2389: "ovsessionmgr",
      2390: "rsmtp",
      2391: "3com-net-mgmt",
      2392: "tacticalauth",
      2393: "ms-olap1",
      2394: "ms-olap2",
      2395: "lan900_remote",
      2396: "wusage",
      2397: "ncl",
      2398: "orbiter",
      2399: "fmpro-fdal",
      2400: "opequus-server",
      2401: "cvspserver",
      2402: "taskmaster2000",
      2403: "taskmaster2000",
      2404: "iec-104",
      2405: "trc-netpoll",
      2406: "jediserver",
      2407: "orion",
      2408: "railgun-webaccl",
      2409: "sns-protocol",
      2410: "vrts-registry",
      2411: "netwave-ap-mgmt",
      2412: "cdn",
      2413: "orion-rmi-reg",
      2414: "beeyond",
      2415: "codima-rtp",
      2416: "rmtserver",
      2417: "composit-server",
      2418: "cas",
      2419: "attachmate-s2s",
      2420: "dslremote-mgmt",
      2421: "g-talk",
      2422: "crmsbits",
      2423: "rnrp",
      2424: "kofax-svr",
      2425: "fjitsuappmgr",
      2426: "vcmp",
      2427: "mgcp-gateway",
      2428: "ott",
      2429: "ft-role",
      2430: "venus",
      2431: "venus-se",
      2432: "codasrv",
      2433: "codasrv-se",
      2434: "pxc-epmap",
      2435: "optilogic",
      2436: "topx",
      2437: "unicontrol",
      2438: "msp",
      2439: "sybasedbsynch",
      2440: "spearway",
      2441: "pvsw-inet",
      2442: "netangel",
      2443: "powerclientcsf",
      2444: "btpp2sectrans",
      2445: "dtn1",
      2446: "bues_service",
      2447: "ovwdb",
      2448: "hpppssvr",
      2449: "ratl",
      2450: "netadmin",
      2451: "netchat",
      2452: "snifferclient",
      2453: "madge-ltd",
      2454: "indx-dds",
      2455: "wago-io-system",
      2456: "altav-remmgt",
      2457: "rapido-ip",
      2458: "griffin",
      2459: "xrpl",
      2460: "ms-theater",
      2461: "qadmifoper",
      2462: "qadmifevent",
      2463: "lsi-raid-mgmt",
      2464: "direcpc-si",
      2465: "lbm",
      2466: "lbf",
      2467: "high-criteria",
      2468: "qip-msgd",
      2469: "mti-tcs-comm",
      2470: "taskman-port",
      2471: "seaodbc",
      2472: "c3",
      2473: "aker-cdp",
      2474: "vitalanalysis",
      2475: "ace-server",
      2476: "ace-svr-prop",
      2477: "ssm-cvs",
      2478: "ssm-cssps",
      2479: "ssm-els",
      2480: "powerexchange",
      2481: "giop",
      2482: "giop-ssl",
      2483: "ttc",
      2484: "ttc-ssl",
      2485: "netobjects1",
      2486: "netobjects2",
      2487: "pns",
      2488: "moy-corp",
      2489: "tsilb",
      2490: "qip-qdhcp",
      2491: "conclave-cpp",
      2492: "groove",
      2493: "talarian-mqs",
      2494: "bmc-ar",
      2495: "fast-rem-serv",
      2496: "dirgis",
      2497: "quaddb",
      2498: "odn-castraq",
      2499: "unicontrol",
      2500: "rtsserv",
      2501: "rtsclient",
      2502: "kentrox-prot",
      2503: "nms-dpnss",
      2504: "wlbs",
      2505: "ppcontrol",
      2506: "jbroker",
      2507: "spock",
      2508: "jdatastore",
      2509: "fjmpss",
      2510: "fjappmgrbulk",
      2511: "metastorm",
      2512: "citrixima",
      2513: "citrixadmin",
      2514: "facsys-ntp",
      2515: "facsys-router",
      2516: "maincontrol",
      2517: "call-sig-trans",
      2518: "willy",
      2519: "globmsgsvc",
      2520: "pvsw",
      2521: "adaptecmgr",
      2522: "windb",
      2523: "qke-llc-v3",
      2524: "optiwave-lm",
      2525: "ms-v-worlds",
      2526: "ema-sent-lm",
      2527: "iqserver",
      2528: "ncr_ccl",
      2529: "utsftp",
      2530: "vrcommerce",
      2531: "ito-e-gui",
      2532: "ovtopmd",
      2533: "snifferserver",
      2534: "combox-web-acc",
      2535: "madcap",
      2536: "btpp2audctr1",
      2537: "upgrade",
      2538: "vnwk-prapi",
      2539: "vsiadmin",
      2540: "lonworks",
      2541: "lonworks2",
      2542: "udrawgraph",
      2543: "reftek",
      2544: "novell-zen",
      2545: "sis-emt",
      2546: "vytalvaultbrtp",
      2547: "vytalvaultvsmp",
      2548: "vytalvaultpipe",
      2549: "ipass",
      2550: "ads",
      2551: "isg-uda-server",
      2552: "call-logging",
      2553: "efidiningport",
      2554: "vcnet-link-v10",
      2555: "compaq-wcp",
      2556: "nicetec-nmsvc",
      2557: "nicetec-mgmt",
      2558: "pclemultimedia",
      2559: "lstp",
      2560: "labrat",
      2561: "mosaixcc",
      2562: "delibo",
      2563: "cti-redwood",
      2564: "hp-3000-telnet",
      2565: "coord-svr",
      2566: "pcs-pcw",
      2567: "clp",
      2568: "spamtrap",
      2569: "sonuscallsig",
      2570: "hs-port",
      2571: "cecsvc",
      2572: "ibp",
      2573: "trustestablish",
      2574: "blockade-bpsp",
      2575: "hl7",
      2576: "tclprodebugger",
      2577: "scipticslsrvr",
      2578: "rvs-isdn-dcp",
      2579: "mpfoncl",
      2580: "tributary",
      2581: "argis-te",
      2582: "argis-ds",
      2583: "mon",
      2584: "cyaserv",
      2585: "netx-server",
      2586: "netx-agent",
      2587: "masc",
      2588: "privilege",
      2589: "quartus-tcl",
      2590: "idotdist",
      2591: "maytagshuffle",
      2592: "netrek",
      2593: "mns-mail",
      2594: "dts",
      2595: "worldfusion1",
      2596: "worldfusion2",
      2597: "homesteadglory",
      2598: "citriximaclient",
      2599: "snapd",
      2600: "hpstgmgr",
      2601: "discp-client",
      2602: "discp-server",
      2603: "servicemeter",
      2604: "nsc-ccs",
      2605: "nsc-posa",
      2606: "netmon",
      2607: "connection",
      2608: "wag-service",
      2609: "system-monitor",
      2610: "versa-tek",
      2611: "lionhead",
      2612: "qpasa-agent",
      2613: "smntubootstrap",
      2614: "neveroffline",
      2615: "firepower",
      2616: "appswitch-emp",
      2617: "cmadmin",
      2618: "priority-e-com",
      2619: "bruce",
      2620: "lpsrecommender",
      2621: "miles-apart",
      2622: "metricadbc",
      2623: "lmdp",
      2624: "aria",
      2625: "blwnkl-port",
      2626: "gbjd816",
      2627: "moshebeeri",
      2628: "dict",
      2629: "sitaraserver",
      2630: "sitaramgmt",
      2631: "sitaradir",
      2632: "irdg-post",
      2633: "interintelli",
      2634: "pk-electronics",
      2635: "backburner",
      2636: "solve",
      2637: "imdocsvc",
      2638: "sybaseanywhere",
      2639: "aminet",
      2640: "ami-control",
      2641: "hdl-srv",
      2642: "tragic",
      2643: "gte-samp",
      2644: "travsoft-ipx-t",
      2645: "novell-ipx-cmd",
      2646: "and-lm",
      2647: "syncserver",
      2648: "upsnotifyprot",
      2649: "vpsipport",
      2650: "eristwoguns",
      2651: "ebinsite",
      2652: "interpathpanel",
      2653: "sonus",
      2654: "corel_vncadmin",
      2655: "unglue",
      2656: "kana",
      2657: "sns-dispatcher",
      2658: "sns-admin",
      2659: "sns-query",
      2660: "gcmonitor",
      2661: "olhost",
      2662: "bintec-capi",
      2663: "bintec-tapi",
      2664: "patrol-mq-gm",
      2665: "patrol-mq-nm",
      2666: "extensis",
      2667: "alarm-clock-s",
      2668: "alarm-clock-c",
      2669: "toad",
      2670: "tve-announce",
      2671: "newlixreg",
      2672: "nhserver",
      2673: "firstcall42",
      2674: "ewnn",
      2675: "ttc-etap",
      2676: "simslink",
      2677: "gadgetgate1way",
      2678: "gadgetgate2way",
      2679: "syncserverssl",
      2680: "pxc-sapxom",
      2681: "mpnjsomb",
      2683: "ncdloadbalance",
      2684: "mpnjsosv",
      2685: "mpnjsocl",
      2686: "mpnjsomg",
      2687: "pq-lic-mgmt",
      2688: "md-cg-http",
      2689: "fastlynx",
      2690: "hp-nnm-data",
      2691: "itinternet",
      2692: "admins-lms",
      2694: "pwrsevent",
      2695: "vspread",
      2696: "unifyadmin",
      2697: "oce-snmp-trap",
      2698: "mck-ivpip",
      2699: "csoft-plusclnt",
      2700: "tqdata",
      2701: "sms-rcinfo",
      2702: "sms-xfer",
      2703: "sms-chat",
      2704: "sms-remctrl",
      2705: "sds-admin",
      2706: "ncdmirroring",
      2707: "emcsymapiport",
      2708: "banyan-net",
      2709: "supermon",
      2710: "sso-service",
      2711: "sso-control",
      2712: "aocp",
      2713: "raventbs",
      2714: "raventdm",
      2715: "hpstgmgr2",
      2716: "inova-ip-disco",
      2717: "pn-requester",
      2718: "pn-requester2",
      2719: "scan-change",
      2720: "wkars",
      2721: "smart-diagnose",
      2722: "proactivesrvr",
      2723: "watchdog-nt",
      2724: "qotps",
      2725: "msolap-ptp2",
      2726: "tams",
      2727: "mgcp-callagent",
      2728: "sqdr",
      2729: "tcim-control",
      2730: "nec-raidplus",
      2731: "fyre-messanger",
      2732: "g5m",
      2733: "signet-ctf",
      2734: "ccs-software",
      2735: "netiq-mc",
      2736: "radwiz-nms-srv",
      2737: "srp-feedback",
      2738: "ndl-tcp-ois-gw",
      2739: "tn-timing",
      2740: "alarm",
      2741: "tsb",
      2742: "tsb2",
      2743: "murx",
      2744: "honyaku",
      2745: "urbisnet",
      2746: "cpudpencap",
      2747: "fjippol-swrly",
      2748: "fjippol-polsvr",
      2749: "fjippol-cnsl",
      2750: "fjippol-port1",
      2751: "fjippol-port2",
      2752: "rsisysaccess",
      2753: "de-spot",
      2754: "apollo-cc",
      2755: "expresspay",
      2756: "simplement-tie",
      2757: "cnrp",
      2758: "apollo-status",
      2759: "apollo-gms",
      2760: "sabams",
      2761: "dicom-iscl",
      2762: "dicom-tls",
      2763: "desktop-dna",
      2764: "data-insurance",
      2765: "qip-audup",
      2766: "compaq-scp",
      2767: "uadtc",
      2768: "uacs",
      2769: "exce",
      2770: "veronica",
      2771: "vergencecm",
      2772: "auris",
      2773: "rbakcup1",
      2774: "rbakcup2",
      2775: "smpp",
      2776: "ridgeway1",
      2777: "ridgeway2",
      2778: "gwen-sonya",
      2779: "lbc-sync",
      2780: "lbc-control",
      2781: "whosells",
      2782: "everydayrc",
      2783: "aises",
      2784: "www-dev",
      2785: "aic-np",
      2786: "aic-oncrpc",
      2787: "piccolo",
      2788: "fryeserv",
      2789: "media-agent",
      2790: "plgproxy",
      2791: "mtport-regist",
      2792: "f5-globalsite",
      2793: "initlsmsad",
      2795: "livestats",
      2796: "ac-tech",
      2797: "esp-encap",
      2798: "tmesis-upshot",
      2799: "icon-discover",
      2800: "acc-raid",
      2801: "igcp",
      2802: "veritas-udp1",
      2803: "btprjctrl",
      2804: "dvr-esm",
      2805: "wta-wsp-s",
      2806: "cspuni",
      2807: "cspmulti",
      2808: "j-lan-p",
      2809: "corbaloc",
      2810: "netsteward",
      2811: "gsiftp",
      2812: "atmtcp",
      2813: "llm-pass",
      2814: "llm-csv",
      2815: "lbc-measure",
      2816: "lbc-watchdog",
      2817: "nmsigport",
      2818: "rmlnk",
      2819: "fc-faultnotify",
      2820: "univision",
      2821: "vrts-at-port",
      2822: "ka0wuc",
      2823: "cqg-netlan",
      2824: "cqg-netlan-1",
      2826: "slc-systemlog",
      2827: "slc-ctrlrloops",
      2828: "itm-lm",
      2829: "silkp1",
      2830: "silkp2",
      2831: "silkp3",
      2832: "silkp4",
      2833: "glishd",
      2834: "evtp",
      2835: "evtp-data",
      2836: "catalyst",
      2837: "repliweb",
      2838: "starbot",
      2839: "nmsigport",
      2840: "l3-exprt",
      2841: "l3-ranger",
      2842: "l3-hawk",
      2843: "pdnet",
      2844: "bpcp-poll",
      2845: "bpcp-trap",
      2846: "aimpp-hello",
      2847: "aimpp-port-req",
      2848: "amt-blc-port",
      2849: "fxp",
      2850: "metaconsole",
      2851: "webemshttp",
      2852: "bears-01",
      2853: "ispipes",
      2854: "infomover",
      2855: "msrp",
      2856: "cesdinv",
      2857: "simctlp",
      2858: "ecnp",
      2859: "activememory",
      2860: "dialpad-voice1",
      2861: "dialpad-voice2",
      2862: "ttg-protocol",
      2863: "sonardata",
      2864: "astronova-main",
      2865: "pit-vpn",
      2866: "iwlistener",
      2867: "esps-portal",
      2868: "npep-messaging",
      2869: "icslap",
      2870: "daishi",
      2871: "msi-selectplay",
      2872: "radix",
      2873: "psrt",
      2874: "dxmessagebase1",
      2875: "dxmessagebase2",
      2876: "sps-tunnel",
      2877: "bluelance",
      2878: "aap",
      2879: "ucentric-ds",
      2880: "synapse",
      2881: "ndsp",
      2882: "ndtp",
      2883: "ndnp",
      2884: "flashmsg",
      2885: "topflow",
      2886: "responselogic",
      2887: "aironetddp",
      2888: "spcsdlobby",
      2889: "rsom",
      2890: "cspclmulti",
      2891: "cinegrfx-elmd",
      2892: "snifferdata",
      2893: "vseconnector",
      2894: "abacus-remote",
      2895: "natuslink",
      2896: "ecovisiong6-1",
      2897: "citrix-rtmp",
      2898: "appliance-cfg",
      2899: "powergemplus",
      2900: "quicksuite",
      2901: "allstorcns",
      2902: "netaspi",
      2903: "suitcase",
      2904: "m2ua",
      2905: "m3ua",
      2906: "caller9",
      2907: "webmethods-b2b",
      2908: "mao",
      2909: "funk-dialout",
      2910: "tdaccess",
      2911: "blockade",
      2912: "epicon",
      2913: "boosterware",
      2914: "gamelobby",
      2915: "tksocket",
      2916: "elvin_server",
      2917: "elvin_client",
      2918: "kastenchasepad",
      2919: "roboer",
      2920: "roboeda",
      2921: "cesdcdman",
      2922: "cesdcdtrn",
      2923: "wta-wsp-wtp-s",
      2924: "precise-vip",
      2926: "mobile-file-dl",
      2927: "unimobilectrl",
      2928: "redstone-cpss",
      2929: "amx-webadmin",
      2930: "amx-weblinx",
      2931: "circle-x",
      2932: "incp",
      2933: "4-tieropmgw",
      2934: "4-tieropmcli",
      2935: "qtp",
      2936: "otpatch",
      2937: "pnaconsult-lm",
      2938: "sm-pas-1",
      2939: "sm-pas-2",
      2940: "sm-pas-3",
      2941: "sm-pas-4",
      2942: "sm-pas-5",
      2943: "ttnrepository",
      2944: "megaco-h248",
      2945: "h248-binary",
      2946: "fjsvmpor",
      2947: "gpsd",
      2948: "wap-push",
      2949: "wap-pushsecure",
      2950: "esip",
      2951: "ottp",
      2952: "mpfwsas",
      2953: "ovalarmsrv",
      2954: "ovalarmsrv-cmd",
      2955: "csnotify",
      2956: "ovrimosdbman",
      2957: "jmact5",
      2958: "jmact6",
      2959: "rmopagt",
      2960: "dfoxserver",
      2961: "boldsoft-lm",
      2962: "iph-policy-cli",
      2963: "iph-policy-adm",
      2964: "bullant-srap",
      2965: "bullant-rap",
      2966: "idp-infotrieve",
      2967: "ssc-agent",
      2968: "enpp",
      2969: "essp",
      2970: "index-net",
      2971: "netclip",
      2972: "pmsm-webrctl",
      2973: "svnetworks",
      2974: "signal",
      2975: "fjmpcm",
      2976: "cns-srv-port",
      2977: "ttc-etap-ns",
      2978: "ttc-etap-ds",
      2979: "h263-video",
      2980: "wimd",
      2981: "mylxamport",
      2982: "iwb-whiteboard",
      2983: "netplan",
      2984: "hpidsadmin",
      2985: "hpidsagent",
      2986: "stonefalls",
      2987: "identify",
      2988: "hippad",
      2989: "zarkov",
      2990: "boscap",
      2991: "wkstn-mon",
      2992: "avenyo",
      2993: "veritas-vis1",
      2994: "veritas-vis2",
      2995: "idrs",
      2996: "vsixml",
      2997: "rebol",
      2998: "realsecure",
      2999: "remoteware-un",
      3000: "remoteware-cl",
      3001: "origo-native",
      3002: "remoteware-srv",
      3003: "cgms",
      3004: "csoftragent",
      3005: "geniuslm",
      3006: "ii-admin",
      3007: "lotusmtap",
      3008: "midnight-tech",
      3009: "pxc-ntfy",
      3010: "ping-pong",
      3011: "trusted-web",
      3012: "twsdss",
      3013: "gilatskysurfer",
      3014: "broker_service",
      3015: "nati-dstp",
      3016: "notify_srvr",
      3017: "event_listener",
      3018: "srvc_registry",
      3019: "resource_mgr",
      3020: "cifs",
      3021: "agriserver",
      3022: "csregagent",
      3023: "magicnotes",
      3024: "nds_sso",
      3025: "arepa-raft",
      3026: "agri-gateway",
      3027: "LiebDevMgmt_C",
      3028: "LiebDevMgmt_DM",
      3029: "LiebDevMgmt_A",
      3030: "arepa-cas",
      3031: "eppc",
      3032: "redwood-chat",
      3033: "pdb",
      3034: "osmosis-aeea",
      3035: "fjsv-gssagt",
      3036: "hagel-dump",
      3037: "hp-san-mgmt",
      3038: "santak-ups",
      3039: "cogitate",
      3040: "tomato-springs",
      3041: "di-traceware",
      3042: "journee",
      3043: "brp",
      3044: "epp",
      3045: "responsenet",
      3046: "di-ase",
      3047: "hlserver",
      3048: "pctrader",
      3049: "nsws",
      3050: "gds_db",
      3051: "galaxy-server",
      3052: "apc-3052",
      3053: "dsom-server",
      3054: "amt-cnf-prot",
      3055: "policyserver",
      3056: "cdl-server",
      3057: "goahead-fldup",
      3058: "videobeans",
      3059: "qsoft",
      3060: "interserver",
      3061: "cautcpd",
      3062: "ncacn-ip-tcp",
      3063: "ncadg-ip-udp",
      3064: "rprt",
      3065: "slinterbase",
      3066: "netattachsdmp",
      3067: "fjhpjp",
      3068: "ls3bcast",
      3069: "ls3",
      3070: "mgxswitch",
      3071: "xplat-replicate",
      3072: "csd-monitor",
      3073: "vcrp",
      3074: "xbox",
      3075: "orbix-locator",
      3076: "orbix-config",
      3077: "orbix-loc-ssl",
      3078: "orbix-cfg-ssl",
      3079: "lv-frontpanel",
      3080: "stm_pproc",
      3081: "tl1-lv",
      3082: "tl1-raw",
      3083: "tl1-telnet",
      3084: "itm-mccs",
      3085: "pcihreq",
      3086: "jdl-dbkitchen",
      3087: "asoki-sma",
      3088: "xdtp",
      3089: "ptk-alink",
      3090: "stss",
      3091: "1ci-smcs",
      3093: "rapidmq-center",
      3094: "rapidmq-reg",
      3095: "panasas",
      3096: "ndl-aps",
      3097: "itu-bicc-stc",
      3098: "umm-port",
      3099: "chmd",
      3100: "opcon-xps",
      3101: "hp-pxpib",
      3102: "slslavemon",
      3103: "autocuesmi",
      3104: "autocuetime",
      3105: "cardbox",
      3106: "cardbox-http",
      3107: "business",
      3108: "geolocate",
      3109: "personnel",
      3110: "sim-control",
      3111: "wsynch",
      3112: "ksysguard",
      3113: "cs-auth-svr",
      3114: "ccmad",
      3115: "mctet-master",
      3116: "mctet-gateway",
      3117: "mctet-jserv",
      3118: "pkagent",
      3119: "d2000kernel",
      3120: "d2000webserver",
      3121: "pcmk-remote",
      3122: "vtr-emulator",
      3123: "edix",
      3124: "beacon-port",
      3125: "a13-an",
      3127: "ctx-bridge",
      3128: "ndl-aas",
      3129: "netport-id",
      3130: "icpv2",
      3131: "netbookmark",
      3132: "ms-rule-engine",
      3133: "prism-deploy",
      3134: "ecp",
      3135: "peerbook-port",
      3136: "grubd",
      3137: "rtnt-1",
      3138: "rtnt-2",
      3139: "incognitorv",
      3140: "ariliamulti",
      3141: "vmodem",
      3142: "rdc-wh-eos",
      3143: "seaview",
      3144: "tarantella",
      3145: "csi-lfap",
      3146: "bears-02",
      3147: "rfio",
      3148: "nm-game-admin",
      3149: "nm-game-server",
      3150: "nm-asses-admin",
      3151: "nm-assessor",
      3152: "feitianrockey",
      3153: "s8-client-port",
      3154: "ccmrmi",
      3155: "jpegmpeg",
      3156: "indura",
      3157: "e3consultants",
      3158: "stvp",
      3159: "navegaweb-port",
      3160: "tip-app-server",
      3161: "doc1lm",
      3162: "sflm",
      3163: "res-sap",
      3164: "imprs",
      3165: "newgenpay",
      3166: "sossecollector",
      3167: "nowcontact",
      3168: "poweronnud",
      3169: "serverview-as",
      3170: "serverview-asn",
      3171: "serverview-gf",
      3172: "serverview-rm",
      3173: "serverview-icc",
      3174: "armi-server",
      3175: "t1-e1-over-ip",
      3176: "ars-master",
      3177: "phonex-port",
      3178: "radclientport",
      3179: "h2gf-w-2m",
      3180: "mc-brk-srv",
      3181: "bmcpatrolagent",
      3182: "bmcpatrolrnvu",
      3183: "cops-tls",
      3184: "apogeex-port",
      3185: "smpppd",
      3186: "iiw-port",
      3187: "odi-port",
      3188: "brcm-comm-port",
      3189: "pcle-infex",
      3190: "csvr-proxy",
      3191: "csvr-sslproxy",
      3192: "firemonrcc",
      3193: "spandataport",
      3194: "magbind",
      3195: "ncu-1",
      3196: "ncu-2",
      3197: "embrace-dp-s",
      3198: "embrace-dp-c",
      3199: "dmod-workspace",
      3200: "tick-port",
      3201: "cpq-tasksmart",
      3202: "intraintra",
      3203: "netwatcher-mon",
      3204: "netwatcher-db",
      3205: "isns",
      3206: "ironmail",
      3207: "vx-auth-port",
      3208: "pfu-prcallback",
      3209: "netwkpathengine",
      3210: "flamenco-proxy",
      3211: "avsecuremgmt",
      3212: "surveyinst",
      3213: "neon24x7",
      3214: "jmq-daemon-1",
      3215: "jmq-daemon-2",
      3216: "ferrari-foam",
      3217: "unite",
      3218: "smartpackets",
      3219: "wms-messenger",
      3220: "xnm-ssl",
      3221: "xnm-clear-text",
      3222: "glbp",
      3223: "digivote",
      3224: "aes-discovery",
      3225: "fcip-port",
      3226: "isi-irp",
      3227: "dwnmshttp",
      3228: "dwmsgserver",
      3229: "global-cd-port",
      3230: "sftdst-port",
      3231: "vidigo",
      3232: "mdtp",
      3233: "whisker",
      3234: "alchemy",
      3235: "mdap-port",
      3236: "apparenet-ts",
      3237: "apparenet-tps",
      3238: "apparenet-as",
      3239: "apparenet-ui",
      3240: "triomotion",
      3241: "sysorb",
      3242: "sdp-id-port",
      3243: "timelot",
      3244: "onesaf",
      3245: "vieo-fe",
      3246: "dvt-system",
      3247: "dvt-data",
      3248: "procos-lm",
      3249: "ssp",
      3250: "hicp",
      3251: "sysscanner",
      3252: "dhe",
      3253: "pda-data",
      3254: "pda-sys",
      3255: "semaphore",
      3256: "cpqrpm-agent",
      3257: "cpqrpm-server",
      3258: "ivecon-port",
      3259: "epncdp2",
      3260: "iscsi-target",
      3261: "winshadow",
      3262: "necp",
      3263: "ecolor-imager",
      3264: "ccmail",
      3265: "altav-tunnel",
      3266: "ns-cfg-server",
      3267: "ibm-dial-out",
      3268: "msft-gc",
      3269: "msft-gc-ssl",
      3270: "verismart",
      3271: "csoft-prev",
      3272: "user-manager",
      3273: "sxmp",
      3274: "ordinox-server",
      3275: "samd",
      3276: "maxim-asics",
      3277: "awg-proxy",
      3278: "lkcmserver",
      3279: "admind",
      3280: "vs-server",
      3281: "sysopt",
      3282: "datusorb",
      3283: "Apple Remote Desktop (Net Assistant)",
      3284: "4talk",
      3285: "plato",
      3286: "e-net",
      3287: "directvdata",
      3288: "cops",
      3289: "enpc",
      3290: "caps-lm",
      3291: "sah-lm",
      3292: "cart-o-rama",
      3293: "fg-fps",
      3294: "fg-gip",
      3295: "dyniplookup",
      3296: "rib-slm",
      3297: "cytel-lm",
      3298: "deskview",
      3299: "pdrncs",
      3300: "ceph",
      3302: "mcs-fastmail",
      3303: "opsession-clnt",
      3304: "opsession-srvr",
      3305: "odette-ftp",
      3306: "mysql",
      3307: "opsession-prxy",
      3308: "tns-server",
      3309: "tns-adv",
      3310: "dyna-access",
      3311: "mcns-tel-ret",
      3312: "appman-server",
      3313: "uorb",
      3314: "uohost",
      3315: "cdid",
      3316: "aicc-cmi",
      3317: "vsaiport",
      3318: "ssrip",
      3319: "sdt-lmd",
      3320: "officelink2000",
      3321: "vnsstr",
      3322: "active-net",
      3323: "active-net",
      3324: "active-net",
      3325: "active-net",
      3326: "sftu",
      3327: "bbars",
      3328: "egptlm",
      3329: "hp-device-disc",
      3330: "mcs-calypsoicf",
      3331: "mcs-messaging",
      3332: "mcs-mailsvr",
      3333: "dec-notes",
      3334: "directv-web",
      3335: "directv-soft",
      3336: "directv-tick",
      3337: "directv-catlg",
      3338: "anet-b",
      3339: "anet-l",
      3340: "anet-m",
      3341: "anet-h",
      3342: "webtie",
      3343: "ms-cluster-net",
      3344: "bnt-manager",
      3345: "influence",
      3346: "trnsprntproxy",
      3347: "phoenix-rpc",
      3348: "pangolin-laser",
      3349: "chevinservices",
      3350: "findviatv",
      3351: "btrieve",
      3352: "ssql",
      3353: "fatpipe",
      3354: "suitjd",
      3355: "ordinox-dbase",
      3356: "upnotifyps",
      3357: "adtech-test",
      3358: "mpsysrmsvr",
      3359: "wg-netforce",
      3360: "kv-server",
      3361: "kv-agent",
      3362: "dj-ilm",
      3363: "nati-vi-server",
      3364: "creativeserver",
      3365: "contentserver",
      3366: "creativepartnr",
      3367: "satvid-datalnk",
      3368: "satvid-datalnk",
      3369: "satvid-datalnk",
      3370: "satvid-datalnk",
      3371: "satvid-datalnk",
      3372: "tip2",
      3373: "lavenir-lm",
      3374: "cluster-disc",
      3375: "vsnm-agent",
      3376: "cdbroker",
      3377: "cogsys-lm",
      3378: "wsicopy",
      3379: "socorfs",
      3380: "sns-channels",
      3381: "geneous",
      3382: "fujitsu-neat",
      3383: "esp-lm",
      3384: "hp-clic",
      3385: "qnxnetman",
      3386: "gprs-sig",
      3387: "backroomnet",
      3388: "cbserver",
      3389: "ms-wbt-server",
      3390: "dsc",
      3391: "savant",
      3392: "efi-lm",
      3393: "d2k-tapestry1",
      3394: "d2k-tapestry2",
      3395: "dyna-lm",
      3396: "printer_agent",
      3397: "cloanto-lm",
      3398: "mercantile",
      3399: "csms",
      3400: "csms2",
      3401: "filecast",
      3402: "fxaengine-net",
      3405: "nokia-ann-ch1",
      3406: "nokia-ann-ch2",
      3407: "ldap-admin",
      3408: "BESApi",
      3409: "networklens",
      3410: "networklenss",
      3411: "biolink-auth",
      3412: "xmlblaster",
      3413: "svnet",
      3414: "wip-port",
      3415: "bcinameservice",
      3416: "commandport",
      3417: "csvr",
      3418: "rnmap",
      3419: "softaudit",
      3420: "ifcp-port",
      3421: "bmap",
      3422: "rusb-sys-port",
      3423: "xtrm",
      3424: "xtrms",
      3425: "agps-port",
      3426: "arkivio",
      3427: "websphere-snmp",
      3428: "twcss",
      3429: "gcsp",
      3430: "ssdispatch",
      3431: "ndl-als",
      3432: "osdcp",
      3433: "opnet-smp",
      3434: "opencm",
      3435: "pacom",
      3436: "gc-config",
      3437: "autocueds",
      3438: "spiral-admin",
      3439: "hri-port",
      3440: "ans-console",
      3441: "connect-client",
      3442: "connect-server",
      3443: "ov-nnm-websrv",
      3444: "denali-server",
      3445: "monp",
      3446: "3comfaxrpc",
      3447: "directnet",
      3448: "dnc-port",
      3449: "hotu-chat",
      3450: "castorproxy",
      3451: "asam",
      3452: "sabp-signal",
      3453: "pscupd",
      3454: "mira",
      3455: "prsvp",
      3456: "vat",
      3457: "vat-control",
      3458: "d3winosfi",
      3459: "integral",
      3460: "edm-manager",
      3461: "edm-stager",
      3462: "edm-std-notify",
      3463: "edm-adm-notify",
      3464: "edm-mgr-sync",
      3465: "edm-mgr-cntrl",
      3466: "workflow",
      3467: "rcst",
      3468: "ttcmremotectrl",
      3469: "pluribus",
      3470: "jt400",
      3471: "jt400-ssl",
      3472: "jaugsremotec-1",
      3473: "jaugsremotec-2",
      3474: "ttntspauto",
      3475: "genisar-port",
      3476: "nppmp",
      3477: "ecomm",
      3478: "stun-behavior",
      3479: "twrpc",
      3480: "plethora",
      3481: "cleanerliverc",
      3482: "vulture",
      3483: "slim-devices",
      3484: "gbs-stp",
      3485: "celatalk",
      3486: "ifsf-hb-port",
      3487: "ltcudp",
      3488: "fs-rh-srv",
      3489: "dtp-dia",
      3490: "colubris",
      3491: "swr-port",
      3492: "tvdumtray-port",
      3493: "nut",
      3494: "ibm3494",
      3495: "seclayer-tcp",
      3496: "seclayer-tls",
      3497: "ipether232port",
      3498: "dashpas-port",
      3499: "sccip-media",
      3500: "rtmp-port",
      3501: "isoft-p2p",
      3502: "avinstalldisc",
      3503: "lsp-ping",
      3504: "ironstorm",
      3505: "ccmcomm",
      3506: "apc-3506",
      3507: "nesh-broker",
      3508: "interactionweb",
      3509: "vt-ssl",
      3510: "xss-port",
      3511: "webmail-2",
      3512: "aztec",
      3513: "arcpd",
      3514: "must-p2p",
      3515: "must-backplane",
      3516: "smartcard-port",
      3517: "802-11-iapp",
      3518: "artifact-msg",
      3519: "galileo",
      3520: "galileolog",
      3521: "mc3ss",
      3522: "nssocketport",
      3523: "odeumservlink",
      3524: "ecmport",
      3525: "eisport",
      3526: "starquiz-port",
      3527: "beserver-msg-q",
      3528: "jboss-iiop",
      3529: "jboss-iiop-ssl",
      3530: "gf",
      3531: "joltid",
      3532: "raven-rmp",
      3533: "raven-rdp",
      3534: "urld-port",
      3535: "ms-la",
      3536: "snac",
      3537: "ni-visa-remote",
      3538: "ibm-diradm",
      3539: "ibm-diradm-ssl",
      3540: "pnrp-port",
      3541: "voispeed-port",
      3542: "hacl-monitor",
      3543: "qftest-lookup",
      3544: "teredo",
      3545: "camac",
      3547: "symantec-sim",
      3548: "interworld",
      3549: "tellumat-nms",
      3550: "ssmpp",
      3551: "apcupsd",
      3552: "taserver",
      3553: "rbr-discovery",
      3554: "questnotify",
      3555: "razor",
      3556: "sky-transport",
      3557: "personalos-001",
      3558: "mcp-port",
      3559: "cctv-port",
      3560: "iniserve-port",
      3561: "bmc-onekey",
      3562: "sdbproxy",
      3563: "watcomdebug",
      3564: "esimport",
      3565: "m2pa",
      3566: "quest-data-hub",
      3567: "dof-eps",
      3568: "dof-tunnel-sec",
      3569: "mbg-ctrl",
      3570: "mccwebsvr-port",
      3571: "megardsvr-port",
      3572: "megaregsvrport",
      3573: "tag-ups-1",
      3574: "dmaf-caster",
      3575: "ccm-port",
      3576: "cmc-port",
      3577: "config-port",
      3578: "data-port",
      3579: "ttat3lb",
      3580: "nati-svrloc",
      3581: "kfxaclicensing",
      3582: "press",
      3583: "canex-watch",
      3584: "u-dbap",
      3585: "emprise-lls",
      3586: "emprise-lsc",
      3587: "p2pgroup",
      3588: "sentinel",
      3589: "isomair",
      3590: "wv-csp-sms",
      3591: "gtrack-server",
      3592: "gtrack-ne",
      3593: "bpmd",
      3594: "mediaspace",
      3595: "shareapp",
      3596: "iw-mmogame",
      3597: "a14",
      3598: "a15",
      3599: "quasar-server",
      3600: "trap-daemon",
      3601: "visinet-gui",
      3602: "infiniswitchcl",
      3603: "int-rcv-cntrl",
      3604: "bmc-jmx-port",
      3605: "comcam-io",
      3606: "splitlock",
      3607: "precise-i3",
      3608: "trendchip-dcp",
      3609: "cpdi-pidas-cm",
      3610: "echonet",
      3611: "six-degrees",
      3612: "dataprotector",
      3613: "alaris-disc",
      3614: "sigma-port",
      3615: "start-network",
      3616: "cd3o-protocol",
      3617: "sharp-server",
      3618: "aairnet-1",
      3619: "aairnet-2",
      3620: "ep-pcp",
      3621: "ep-nsp",
      3622: "ff-lr-port",
      3623: "haipe-discover",
      3624: "dist-upgrade",
      3625: "volley",
      3626: "bvcdaemon-port",
      3627: "jamserverport",
      3628: "ept-machine",
      3629: "escvpnet",
      3630: "cs-remote-db",
      3631: "cs-services",
      3632: "distcc",
      3633: "wacp",
      3634: "hlibmgr",
      3635: "sdo",
      3636: "servistaitsm",
      3637: "scservp",
      3638: "ehp-backup",
      3639: "xap-ha",
      3640: "netplay-port1",
      3641: "netplay-port2",
      3642: "juxml-port",
      3643: "audiojuggler",
      3644: "ssowatch",
      3645: "cyc",
      3646: "xss-srv-port",
      3647: "splitlock-gw",
      3648: "fjcp",
      3649: "nmmp",
      3650: "prismiq-plugin",
      3651: "xrpc-registry",
      3652: "vxcrnbuport",
      3653: "tsp",
      3654: "vaprtm",
      3655: "abatemgr",
      3656: "abatjss",
      3657: "immedianet-bcn",
      3658: "ps-ams",
      3659: "apple-sasl",
      3660: "can-nds-ssl",
      3661: "can-ferret-ssl",
      3662: "pserver",
      3663: "dtp",
      3664: "ups-engine",
      3665: "ent-engine",
      3666: "eserver-pap",
      3667: "infoexch",
      3668: "dell-rm-port",
      3669: "casanswmgmt",
      3670: "smile",
      3671: "efcp",
      3672: "lispworks-orb",
      3673: "mediavault-gui",
      3674: "wininstall-ipc",
      3675: "calltrax",
      3676: "va-pacbase",
      3677: "roverlog",
      3678: "ipr-dglt",
      3679: "Escale (Newton Dock)",
      3680: "npds-tracker",
      3681: "bts-x73",
      3682: "cas-mapi",
      3683: "bmc-ea",
      3684: "faxstfx-port",
      3685: "dsx-agent",
      3686: "tnmpv2",
      3687: "simple-push",
      3688: "simple-push-s",
      3689: "daap",
      3690: "svn",
      3691: "magaya-network",
      3692: "intelsync",
      3693: "easl",
      3695: "bmc-data-coll",
      3696: "telnetcpcd",
      3697: "nw-license",
      3698: "sagectlpanel",
      3699: "kpn-icw",
      3700: "lrs-paging",
      3701: "netcelera",
      3702: "ws-discovery",
      3703: "adobeserver-3",
      3704: "adobeserver-4",
      3705: "adobeserver-5",
      3706: "rt-event",
      3707: "rt-event-s",
      3708: "sun-as-iiops",
      3709: "ca-idms",
      3710: "portgate-auth",
      3711: "edb-server2",
      3712: "sentinel-ent",
      3713: "tftps",
      3714: "delos-dms",
      3715: "anoto-rendezv",
      3716: "wv-csp-sms-cir",
      3717: "wv-csp-udp-cir",
      3718: "opus-services",
      3719: "itelserverport",
      3720: "ufastro-instr",
      3721: "xsync",
      3722: "xserveraid",
      3723: "sychrond",
      3724: "blizwow",
      3725: "na-er-tip",
      3726: "array-manager",
      3727: "e-mdu",
      3728: "e-woa",
      3729: "fksp-audit",
      3730: "client-ctrl",
      3731: "smap",
      3732: "m-wnn",
      3733: "multip-msg",
      3734: "synel-data",
      3735: "pwdis",
      3736: "rs-rmi",
      3737: "xpanel",
      3738: "versatalk",
      3739: "launchbird-lm",
      3740: "heartbeat",
      3741: "wysdma",
      3742: "cst-port",
      3743: "ipcs-command",
      3744: "sasg",
      3745: "gw-call-port",
      3746: "linktest",
      3747: "linktest-s",
      3748: "webdata",
      3749: "cimtrak",
      3750: "cbos-ip-port",
      3751: "gprs-cube",
      3752: "vipremoteagent",
      3753: "nattyserver",
      3754: "timestenbroker",
      3755: "sas-remote-hlp",
      3756: "canon-capt",
      3757: "grf-port",
      3758: "apw-registry",
      3759: "exapt-lmgr",
      3760: "adtempusclient",
      3761: "gsakmp",
      3762: "gbs-smp",
      3763: "xo-wave",
      3764: "mni-prot-rout",
      3765: "rtraceroute",
      3766: "sitewatch-s",
      3767: "listmgr-port",
      3768: "rblcheckd",
      3769: "haipe-otnk",
      3770: "cindycollab",
      3771: "paging-port",
      3772: "ctp",
      3773: "ctdhercules",
      3774: "zicom",
      3775: "ispmmgr",
      3776: "dvcprov-port",
      3777: "jibe-eb",
      3778: "c-h-it-port",
      3779: "cognima",
      3780: "nnp",
      3781: "abcvoice-port",
      3782: "iso-tp0s",
      3783: "bim-pem",
      3784: "bfd-control",
      3785: "bfd-echo",
      3786: "upstriggervsw",
      3787: "fintrx",
      3788: "isrp-port",
      3789: "remotedeploy",
      3790: "quickbooksrds",
      3791: "tvnetworkvideo",
      3792: "sitewatch",
      3793: "dcsoftware",
      3794: "jaus",
      3795: "myblast",
      3796: "spw-dialer",
      3797: "idps",
      3798: "minilock",
      3799: "radius-dynauth",
      3800: "pwgpsi",
      3801: "ibm-mgr",
      3802: "vhd",
      3803: "soniqsync",
      3804: "iqnet-port",
      3805: "tcpdataserver",
      3806: "wsmlb",
      3807: "spugna",
      3808: "sun-as-iiops-ca",
      3809: "apocd",
      3810: "wlanauth",
      3811: "amp",
      3812: "neto-wol-server",
      3813: "rap-ip",
      3814: "neto-dcs",
      3815: "lansurveyorxml",
      3816: "sunlps-http",
      3817: "tapeware",
      3818: "crinis-hb",
      3819: "epl-slp",
      3820: "scp",
      3821: "pmcp",
      3822: "acp-discovery",
      3823: "acp-conduit",
      3824: "acp-policy",
      3825: "ffserver",
      3826: "warmux",
      3827: "netmpi",
      3828: "neteh",
      3829: "neteh-ext",
      3830: "cernsysmgmtagt",
      3831: "dvapps",
      3832: "xxnetserver",
      3833: "aipn-auth",
      3834: "spectardata",
      3835: "spectardb",
      3836: "markem-dcp",
      3837: "mkm-discovery",
      3838: "sos",
      3839: "amx-rms",
      3840: "flirtmitmir",
      3841: "shiprush-db-svr",
      3842: "nhci",
      3843: "quest-agent",
      3844: "rnm",
      3845: "v-one-spp",
      3846: "an-pcp",
      3847: "msfw-control",
      3848: "item",
      3849: "spw-dnspreload",
      3850: "qtms-bootstrap",
      3851: "spectraport",
      3852: "sse-app-config",
      3853: "sscan",
      3854: "stryker-com",
      3855: "opentrac",
      3856: "informer",
      3857: "trap-port",
      3858: "trap-port-mom",
      3859: "nav-port",
      3860: "sasp",
      3861: "winshadow-hd",
      3862: "giga-pocket",
      3863: "asap-sctp",
      3864: "asap-sctp-tls",
      3865: "xpl",
      3866: "dzdaemon",
      3867: "dzoglserver",
      3868: "diameter",
      3869: "ovsam-mgmt",
      3870: "ovsam-d-agent",
      3871: "avocent-adsap",
      3872: "oem-agent",
      3873: "fagordnc",
      3874: "sixxsconfig",
      3875: "pnbscada",
      3876: "dl_agent",
      3877: "xmpcr-interface",
      3878: "fotogcad",
      3879: "appss-lm",
      3880: "igrs",
      3881: "idac",
      3882: "msdts1",
      3883: "vrpn",
      3884: "softrack-meter",
      3885: "topflow-ssl",
      3886: "nei-management",
      3887: "ciphire-data",
      3888: "ciphire-serv",
      3889: "dandv-tester",
      3890: "ndsconnect",
      3891: "rtc-pm-port",
      3892: "pcc-image-port",
      3893: "cgi-starapi",
      3894: "syam-agent",
      3895: "syam-smc",
      3896: "sdo-tls",
      3897: "sdo-ssh",
      3898: "senip",
      3899: "itv-control",
      3900: "udt_os",
      3901: "nimsh",
      3902: "nimaux",
      3903: "charsetmgr",
      3904: "omnilink-port",
      3905: "mupdate",
      3906: "topovista-data",
      3907: "imoguia-port",
      3908: "hppronetman",
      3909: "surfcontrolcpa",
      3910: "prnrequest",
      3911: "prnstatus",
      3912: "gbmt-stars",
      3913: "listcrt-port",
      3914: "listcrt-port-2",
      3915: "agcat",
      3916: "wysdmc",
      3917: "aftmux",
      3918: "pktcablemmcops",
      3919: "hyperip",
      3920: "exasoftport1",
      3921: "herodotus-net",
      3922: "sor-update",
      3923: "symb-sb-port",
      3924: "mpl-gprs-port",
      3925: "zmp",
      3926: "winport",
      3927: "natdataservice",
      3928: "netboot-pxe",
      3929: "smauth-port",
      3930: "syam-webserver",
      3931: "msr-plugin-port",
      3932: "dyn-site",
      3933: "plbserve-port",
      3934: "sunfm-port",
      3935: "sdp-portmapper",
      3936: "mailprox",
      3937: "dvbservdsc",
      3938: "dbcontrol_agent",
      3939: "aamp",
      3940: "xecp-node",
      3941: "homeportal-web",
      3942: "srdp",
      3943: "tig",
      3944: "sops",
      3945: "emcads",
      3946: "backupedge",
      3947: "ccp",
      3948: "apdap",
      3949: "drip",
      3950: "namemunge",
      3951: "pwgippfax",
      3952: "i3-sessionmgr",
      3953: "xmlink-connect",
      3954: "adrep",
      3955: "p2pcommunity",
      3956: "gvcp",
      3957: "mqe-broker",
      3958: "mqe-agent",
      3959: "treehopper",
      3960: "bess",
      3961: "proaxess",
      3962: "sbi-agent",
      3963: "thrp",
      3964: "sasggprs",
      3965: "ati-ip-to-ncpe",
      3966: "bflckmgr",
      3967: "ppsms",
      3968: "ianywhere-dbns",
      3969: "landmarks",
      3970: "lanrevagent",
      3971: "lanrevserver",
      3972: "iconp",
      3973: "progistics",
      3974: "citysearch",
      3975: "airshot",
      3976: "opswagent",
      3977: "opswmanager",
      3978: "secure-cfg-svr",
      3979: "smwan",
      3981: "starfish",
      3982: "eis",
      3983: "eisp",
      3984: "mapper-nodemgr",
      3985: "mapper-mapethd",
      3986: "mapper-ws_ethd",
      3987: "centerline",
      3988: "dcs-config",
      3989: "bv-queryengine",
      3990: "bv-is",
      3991: "bv-smcsrv",
      3992: "bv-ds",
      3993: "bv-agent",
      3995: "iss-mgmt-ssl",
      3996: "abcsoftware",
      3997: "agentsease-db",
      3998: "dnx",
      3999: "nvcnet",
      4000: "terabase",
      4001: "newoak",
      4002: "pxc-spvr-ft",
      4003: "pxc-splr-ft",
      4004: "pxc-roid",
      4005: "pxc-pin",
      4006: "pxc-spvr",
      4007: "pxc-splr",
      4008: "netcheque",
      4009: "chimera-hwm",
      4010: "samsung-unidex",
      4011: "altserviceboot",
      4012: "pda-gate",
      4013: "acl-manager",
      4014: "taiclock",
      4015: "talarian-mcast1",
      4016: "talarian-mcast2",
      4017: "talarian-mcast3",
      4018: "talarian-mcast4",
      4019: "talarian-mcast5",
      4020: "trap",
      4021: "nexus-portal",
      4022: "dnox",
      4023: "esnm-zoning",
      4024: "tnp1-port",
      4025: "partimage",
      4026: "as-debug",
      4027: "bxp",
      4028: "dtserver-port",
      4029: "ip-qsig",
      4030: "jdmn-port",
      4031: "suucp",
      4032: "vrts-auth-port",
      4033: "sanavigator",
      4034: "ubxd",
      4035: "wap-push-http",
      4036: "wap-push-https",
      4037: "ravehd",
      4038: "fazzt-ptp",
      4039: "fazzt-admin",
      4040: "yo-main",
      4041: "houston",
      4042: "ldxp",
      4043: "nirp",
      4044: "ltp",
      4045: "npp",
      4046: "acp-proto",
      4047: "ctp-state",
      4049: "wafs",
      4050: "cisco-wafs",
      4051: "cppdp",
      4052: "interact",
      4053: "ccu-comm-1",
      4054: "ccu-comm-2",
      4055: "ccu-comm-3",
      4056: "lms",
      4057: "wfm",
      4058: "kingfisher",
      4059: "dlms-cosem",
      4060: "dsmeter_iatc",
      4061: "ice-location",
      4062: "ice-slocation",
      4063: "ice-router",
      4064: "ice-srouter",
      4065: "avanti_cdp",
      4066: "pmas",
      4067: "idp",
      4068: "ipfltbcst",
      4069: "minger",
      4070: "tripe",
      4071: "aibkup",
      4072: "zieto-sock",
      4073: "iRAPP",
      4074: "cequint-cityid",
      4075: "perimlan",
      4076: "seraph",
      4077: "ascomalarm",
      4078: "cssp",
      4079: "santools",
      4080: "lorica-in",
      4081: "lorica-in-sec",
      4082: "lorica-out",
      4083: "lorica-out-sec",
      4084: "fortisphere-vm",
      4085: "ezmessagesrv",
      4086: "ftsync",
      4087: "applusservice",
      4088: "npsp",
      4089: "opencore",
      4090: "omasgport",
      4091: "ewinstaller",
      4092: "ewdgs",
      4093: "pvxpluscs",
      4094: "sysrqd",
      4095: "xtgui",
      4096: "bre",
      4097: "patrolview",
      4098: "drmsfsd",
      4099: "dpcp",
      4100: "igo-incognito",
      4101: "brlp-0",
      4102: "brlp-1",
      4103: "brlp-2",
      4104: "brlp-3",
      4105: "shofar",
      4106: "synchronite",
      4107: "j-ac",
      4108: "accel",
      4109: "izm",
      4110: "g2tag",
      4111: "xgrid",
      4112: "apple-vpns-rp",
      4113: "aipn-reg",
      4114: "jomamqmonitor",
      4115: "cds",
      4116: "smartcard-tls",
      4117: "hillrserv",
      4118: "netscript",
      4119: "assuria-slm",
      4120: "minirem",
      4121: "e-builder",
      4122: "fprams",
      4123: "z-wave",
      4124: "tigv2",
      4125: "opsview-envoy",
      4126: "ddrepl",
      4127: "unikeypro",
      4128: "nufw",
      4129: "nuauth",
      4130: "fronet",
      4131: "stars",
      4132: "nuts_dem",
      4133: "nuts_bootp",
      4134: "nifty-hmi",
      4135: "cl-db-attach",
      4136: "cl-db-request",
      4137: "cl-db-remote",
      4138: "nettest",
      4139: "thrtx",
      4140: "cedros_fds",
      4141: "oirtgsvc",
      4142: "oidocsvc",
      4143: "oidsr",
      4145: "vvr-control",
      4146: "tgcconnect",
      4147: "vrxpservman",
      4148: "hhb-handheld",
      4149: "agslb",
      4150: "PowerAlert-nsa",
      4151: "menandmice_noh",
      4152: "idig_mux",
      4153: "mbl-battd",
      4154: "atlinks",
      4155: "bzr",
      4156: "stat-results",
      4157: "stat-scanner",
      4158: "stat-cc",
      4159: "nss",
      4160: "jini-discovery",
      4161: "omscontact",
      4162: "omstopology",
      4163: "silverpeakpeer",
      4164: "silverpeakcomm",
      4165: "altcp",
      4166: "joost",
      4167: "ddgn",
      4168: "pslicser",
      4169: "iadt-disc",
      4170: "d-cinema-csp",
      4171: "ml-svnet",
      4172: "pcoip",
      4173: "mma-discovery",
      4174: "sm-disc",
      4175: "bccp",
      4176: "tl-ipcproxy",
      4177: "wello",
      4178: "storman",
      4179: "MaxumSP",
      4180: "httpx",
      4181: "macbak",
      4182: "pcptcpservice",
      4183: "cyborgnet",
      4184: "universe_suite",
      4185: "wcpp",
      4186: "boxbackupstore",
      4187: "csc_proxy",
      4188: "vatata",
      4189: "pcep",
      4190: "sieve",
      4191: "dsmipv6",
      4192: "azeti-bd",
      4193: "pvxplusio",
      4195: "aws-wsp",
      4197: "hctl",
      4199: "eims-admin",
      4200: "vrml-multi-use",
      4201: "vrml-multi-use",
      4202: "vrml-multi-use",
      4203: "vrml-multi-use",
      4204: "vrml-multi-use",
      4205: "vrml-multi-use",
      4206: "vrml-multi-use",
      4207: "vrml-multi-use",
      4208: "vrml-multi-use",
      4209: "vrml-multi-use",
      4210: "vrml-multi-use",
      4211: "vrml-multi-use",
      4212: "vrml-multi-use",
      4213: "vrml-multi-use",
      4214: "vrml-multi-use",
      4215: "vrml-multi-use",
      4216: "vrml-multi-use",
      4217: "vrml-multi-use",
      4218: "vrml-multi-use",
      4219: "vrml-multi-use",
      4220: "vrml-multi-use",
      4221: "vrml-multi-use",
      4222: "vrml-multi-use",
      4223: "vrml-multi-use",
      4224: "vrml-multi-use",
      4225: "vrml-multi-use",
      4226: "vrml-multi-use",
      4227: "vrml-multi-use",
      4228: "vrml-multi-use",
      4229: "vrml-multi-use",
      4230: "vrml-multi-use",
      4231: "vrml-multi-use",
      4232: "vrml-multi-use",
      4233: "vrml-multi-use",
      4234: "vrml-multi-use",
      4235: "vrml-multi-use",
      4236: "vrml-multi-use",
      4237: "vrml-multi-use",
      4238: "vrml-multi-use",
      4239: "vrml-multi-use",
      4240: "vrml-multi-use",
      4241: "vrml-multi-use",
      4242: "vrml-multi-use",
      4243: "vrml-multi-use",
      4244: "vrml-multi-use",
      4245: "vrml-multi-use",
      4246: "vrml-multi-use",
      4247: "vrml-multi-use",
      4248: "vrml-multi-use",
      4249: "vrml-multi-use",
      4250: "vrml-multi-use",
      4251: "vrml-multi-use",
      4252: "vrml-multi-use",
      4253: "vrml-multi-use",
      4254: "vrml-multi-use",
      4255: "vrml-multi-use",
      4256: "vrml-multi-use",
      4257: "vrml-multi-use",
      4258: "vrml-multi-use",
      4259: "vrml-multi-use",
      4260: "vrml-multi-use",
      4261: "vrml-multi-use",
      4262: "vrml-multi-use",
      4263: "vrml-multi-use",
      4264: "vrml-multi-use",
      4265: "vrml-multi-use",
      4266: "vrml-multi-use",
      4267: "vrml-multi-use",
      4268: "vrml-multi-use",
      4269: "vrml-multi-use",
      4270: "vrml-multi-use",
      4271: "vrml-multi-use",
      4272: "vrml-multi-use",
      4273: "vrml-multi-use",
      4274: "vrml-multi-use",
      4275: "vrml-multi-use",
      4276: "vrml-multi-use",
      4277: "vrml-multi-use",
      4278: "vrml-multi-use",
      4279: "vrml-multi-use",
      4280: "vrml-multi-use",
      4281: "vrml-multi-use",
      4282: "vrml-multi-use",
      4283: "vrml-multi-use",
      4284: "vrml-multi-use",
      4285: "vrml-multi-use",
      4286: "vrml-multi-use",
      4287: "vrml-multi-use",
      4288: "vrml-multi-use",
      4289: "vrml-multi-use",
      4290: "vrml-multi-use",
      4291: "vrml-multi-use",
      4292: "vrml-multi-use",
      4293: "vrml-multi-use",
      4294: "vrml-multi-use",
      4295: "vrml-multi-use",
      4296: "vrml-multi-use",
      4297: "vrml-multi-use",
      4298: "vrml-multi-use",
      4299: "vrml-multi-use",
      4300: "corelccam",
      4301: "d-data",
      4302: "d-data-control",
      4303: "srcp",
      4304: "owserver",
      4305: "batman",
      4306: "pinghgl",
      4307: "trueconf",
      4308: "compx-lockview",
      4309: "dserver",
      4310: "mirrtex",
      4311: "p6ssmc",
      4312: "pscl-mgt",
      4313: "perrla",
      4314: "choiceview-agt",
      4316: "choiceview-clt",
      4317: "opentelemetry",
      4320: "fdt-rcatp",
      4321: "rwhois",
      4322: "trim-event",
      4323: "trim-ice",
      4325: "geognosisman",
      4326: "geognosis",
      4327: "jaxer-web",
      4328: "jaxer-manager",
      4329: "publiqare-sync",
      4330: "dey-sapi",
      4331: "ktickets-rest",
      4332: "getty-focus",
      4333: "ahsp",
      4334: "netconf-ch-ssh",
      4335: "netconf-ch-tls",
      4336: "restconf-ch-tls",
      4340: "gaia",
      4341: "lisp-data",
      4342: "lisp-control",
      4343: "unicall",
      4344: "vinainstall",
      4345: "m4-network-as",
      4346: "elanlm",
      4347: "lansurveyor",
      4348: "itose",
      4349: "fsportmap",
      4350: "net-device",
      4351: "plcy-net-svcs",
      4352: "pjlink",
      4353: "f5-iquery",
      4354: "qsnet-trans",
      4355: "qsnet-workst",
      4356: "qsnet-assist",
      4357: "qsnet-cond",
      4358: "qsnet-nucl",
      4359: "omabcastltkm",
      4360: "matrix_vnet",
      4361: "nacnl",
      4362: "afore-vdp-disc",
      4366: "shadowstream",
      4368: "wxbrief",
      4369: "epmd",
      4370: "elpro_tunnel",
      4371: "l2c-disc",
      4372: "l2c-data",
      4373: "remctl",
      4374: "psi-ptt",
      4375: "tolteces",
      4376: "bip",
      4377: "cp-spxsvr",
      4378: "cp-spxdpy",
      4379: "ctdb",
      4389: "xandros-cms",
      4390: "wiegand",
      4391: "apwi-imserver",
      4392: "apwi-rxserver",
      4393: "apwi-rxspooler",
      4394: "apwi-disc",
      4395: "omnivisionesx",
      4396: "fly",
      4400: "ds-srv",
      4401: "ds-srvr",
      4402: "ds-clnt",
      4403: "ds-user",
      4404: "ds-admin",
      4405: "ds-mail",
      4406: "ds-slp",
      4407: "nacagent",
      4408: "slscc",
      4409: "netcabinet-com",
      4410: "itwo-server",
      4411: "found",
      4412: "smallchat",
      4413: "avi-nms-disc",
      4414: "updog",
      4415: "brcd-vr-req",
      4416: "pjj-player-disc",
      4417: "workflowdir",
      4418: "axysbridge",
      4419: "cbp",
      4420: "nvme",
      4421: "scaleft",
      4422: "tsepisp",
      4423: "thingkit",
      4425: "netrockey6",
      4426: "beacon-port-2",
      4427: "drizzle",
      4428: "omviserver",
      4429: "omviagent",
      4430: "rsqlserver",
      4431: "wspipe",
      4432: "l-acoustics",
      4433: "vop",
      4441: "netblox",
      4442: "saris",
      4443: "pharos",
      4444: "nv-video",
      4445: "upnotifyp",
      4446: "n1-fwp",
      4447: "n1-rmgmt",
      4448: "asc-slmd",
      4449: "privatewire",
      4450: "camp",
      4451: "ctisystemmsg",
      4452: "ctiprogramload",
      4453: "nssalertmgr",
      4454: "nssagentmgr",
      4455: "prchat-user",
      4456: "prchat-server",
      4457: "prRegister",
      4458: "mcp",
      4460: "ntske",
      4484: "hpssmgmt",
      4485: "assyst-dr",
      4486: "icms",
      4487: "prex-tcp",
      4488: "awacs-ice",
      4500: "ipsec-nat-t",
      4502: "a25-fap-fgw",
      4534: "armagetronad",
      4535: "ehs",
      4536: "ehs-ssl",
      4537: "wssauthsvc",
      4538: "swx-gate",
      4545: "worldscores",
      4546: "sf-lm",
      4547: "lanner-lm",
      4548: "synchromesh",
      4549: "aegate",
      4550: "gds-adppiw-db",
      4551: "ieee-mih",
      4552: "menandmice-mon",
      4553: "icshostsvc",
      4554: "msfrs",
      4555: "rsip",
      4556: "dtn-bundle",
      4557: "mtcevrunqss",
      4558: "mtcevrunqman",
      4559: "hylafax",
      4563: "amahi-anywhere",
      4566: "kwtc",
      4567: "tram",
      4568: "bmc-reporting",
      4569: "iax",
      4570: "deploymentmap",
      4573: "cardifftec-back",
      4590: "rid",
      4591: "l3t-at-an",
      4592: "hrpd-ith-at-an",
      4593: "ipt-anri-anri",
      4594: "ias-session",
      4595: "ias-paging",
      4596: "ias-neighbor",
      4597: "a21-an-1xbs",
      4598: "a16-an-an",
      4599: "a17-an-an",
      4600: "piranha1",
      4601: "piranha2",
      4602: "mtsserver",
      4603: "menandmice-upg",
      4604: "irp",
      4605: "sixchat",
      4606: "sixid",
      4621: "ventoso",
      4646: "dots-signal",
      4658: "playsta2-app",
      4659: "playsta2-lob",
      4660: "smaclmgr",
      4661: "kar2ouche",
      4662: "oms",
      4663: "noteit",
      4664: "ems",
      4665: "contclientms",
      4666: "eportcomm",
      4667: "mmacomm",
      4668: "mmaeds",
      4669: "eportcommdata",
      4670: "light",
      4671: "acter",
      4672: "rfa",
      4673: "cxws",
      4674: "appiq-mgmt",
      4675: "dhct-status",
      4676: "dhct-alerts",
      4677: "bcs",
      4678: "traversal",
      4679: "mgesupervision",
      4680: "mgemanagement",
      4681: "parliant",
      4682: "finisar",
      4683: "spike",
      4684: "rfid-rp1",
      4685: "autopac",
      4686: "msp-os",
      4687: "nst",
      4688: "mobile-p2p",
      4689: "altovacentral",
      4690: "prelude",
      4691: "mtn",
      4692: "conspiracy",
      4700: "netxms-agent",
      4701: "netxms-mgmt",
      4702: "netxms-sync",
      4703: "npqes-test",
      4704: "assuria-ins",
      4711: "trinity-dist",
      4725: "truckstar",
      4726: "a26-fap-fgw",
      4727: "fcis-disc",
      4728: "capmux",
      4729: "gsmtap",
      4730: "gearman",
      4731: "remcap",
      4732: "ohmtrigger",
      4733: "resorcs",
      4737: "ipdr-sp",
      4738: "solera-lpn",
      4739: "ipfix",
      4740: "ipfixs",
      4741: "lumimgrd",
      4742: "sicct-sdp",
      4743: "openhpid",
      4744: "ifsp",
      4745: "fmp",
      4746: "intelliadm-disc",
      4747: "buschtrommel",
      4749: "profilemac",
      4750: "ssad",
      4751: "spocp",
      4752: "snap",
      4753: "simon-disc",
      4754: "gre-in-udp",
      4755: "gre-udp-dtls",
      4756: "RDCenter",
      4774: "converge",
      4784: "bfd-multi-ctl",
      4785: "cncp",
      4786: "smart-install",
      4787: "sia-ctrl-plane",
      4788: "xmcp",
      4789: "vxlan",
      4790: "vxlan-gpe",
      4791: "roce",
      4800: "iims",
      4801: "iwec",
      4802: "ilss",
      4803: "notateit-disc",
      4804: "aja-ntv4-disc",
      4827: "htcp",
      4837: "varadero-0",
      4838: "varadero-1",
      4839: "varadero-2",
      4840: "opcua-udp",
      4841: "quosa",
      4842: "gw-asv",
      4843: "opcua-tls",
      4844: "gw-log",
      4845: "wcr-remlib",
      4846: "contamac_icm",
      4847: "wfc",
      4848: "appserv-http",
      4849: "appserv-https",
      4850: "sun-as-nodeagt",
      4851: "derby-repli",
      4867: "unify-debug",
      4868: "phrelay",
      4869: "phrelaydbg",
      4870: "cc-tracking",
      4871: "wired",
      4876: "tritium-can",
      4877: "lmcs",
      4878: "inst-discovery",
      4879: "wsdl-event",
      4880: "hislip",
      4881: "socp-t",
      4882: "socp-c",
      4883: "wmlserver",
      4884: "hivestor",
      4885: "abbs",
      4888: "xcap-portal",
      4889: "xcap-control",
      4894: "lyskom",
      4899: "radmin-port",
      4900: "hfcs",
      4901: "flr_agent",
      4902: "magiccontrol",
      4912: "lutap",
      4913: "lutcp",
      4914: "bones",
      4915: "frcs",
      4936: "an-signaling",
      4937: "atsc-mh-ssc",
      4940: "eq-office-4940",
      4941: "eq-office-4941",
      4942: "eq-office-4942",
      4949: "munin",
      4950: "sybasesrvmon",
      4951: "pwgwims",
      4952: "sagxtsds",
      4953: "dbsyncarbiter",
      4969: "ccss-qmm",
      4970: "ccss-qsm",
      4971: "burp",
      4980: "ctxs-vpp",
      4984: "webyast",
      4985: "gerhcs",
      4986: "mrip",
      4987: "smar-se-port1",
      4988: "smar-se-port2",
      4989: "parallel",
      4990: "busycal",
      4991: "vrt",
      4999: "hfcs-manager",
      5000: "commplex-main",
      5001: "commplex-link",
      5002: "rfe",
      5003: "fmpro-internal",
      5004: "avt-profile-1",
      5005: "avt-profile-2",
      5006: "wsm-server",
      5007: "wsm-server-ssl",
      5008: "synapsis-edge",
      5009: "winfs",
      5010: "telelpathstart",
      5011: "telelpathattack",
      5012: "nsp",
      5013: "fmpro-v6",
      5014: "onpsocket",
      5015: "fmwp",
      5020: "zenginkyo-1",
      5021: "zenginkyo-2",
      5022: "mice",
      5023: "htuilsrv",
      5024: "scpi-telnet",
      5025: "scpi-raw",
      5026: "strexec-d",
      5027: "strexec-s",
      5028: "qvr",
      5029: "infobright",
      5030: "surfpass",
      5031: "dmp",
      5032: "signacert-agent",
      5033: "jtnetd-server",
      5034: "jtnetd-status",
      5042: "asnaacceler8db",
      5043: "swxadmin",
      5044: "lxi-evntsvc",
      5045: "osp",
      5046: "vpm-udp",
      5047: "iscape",
      5048: "texai",
      5049: "ivocalize",
      5050: "mmcc",
      5051: "ita-agent",
      5052: "ita-manager",
      5053: "rlm-disc",
      5054: "rlm-admin",
      5055: "unot",
      5056: "intecom-ps1",
      5057: "intecom-ps2",
      5058: "locus-disc",
      5059: "sds",
      5060: "sip",
      5061: "sips",
      5062: "na-localise",
      5063: "csrpc",
      5064: "ca-1",
      5065: "ca-2",
      5066: "stanag-5066",
      5067: "authentx",
      5068: "bitforestsrv",
      5069: "i-net-2000-npr",
      5070: "vtsas",
      5071: "powerschool",
      5072: "ayiya",
      5073: "tag-pm",
      5074: "alesquery",
      5075: "pvaccess",
      5078: "pixelpusher",
      5079: "cp-spxrpts",
      5080: "onscreen",
      5081: "sdl-ets",
      5082: "qcp",
      5083: "qfp",
      5084: "llrp",
      5085: "encrypted-llrp",
      5086: "aprigo-cs",
      5087: "biotic",
      5090: "car",
      5091: "cxtp",
      5092: "magpie",
      5093: "sentinel-lm",
      5094: "hart-ip",
      5099: "sentlm-srv2srv",
      5100: "socalia",
      5101: "talarian-udp",
      5102: "oms-nonsecure",
      5103: "actifio-c2c",
      5104: "tinymessage",
      5105: "hughes-ap",
      5106: "actifioudsagent",
      5107: "actifioreplic",
      5111: "taep-as-svc",
      5112: "pm-cmdsvr",
      5114: "ev-services",
      5115: "autobuild",
      5116: "emb-proj-cmd",
      5117: "gradecam",
      5120: "barracuda-bbs",
      5133: "nbt-pc",
      5134: "ppactivation",
      5135: "erp-scale",
      5136: "minotaur-sa",
      5137: "ctsd",
      5145: "rmonitor_secure",
      5146: "social-alarm",
      5150: "atmp",
      5151: "esri_sde",
      5152: "sde-discovery",
      5154: "bzflag",
      5155: "asctrl-agent",
      5156: "rugameonline",
      5157: "mediat",
      5161: "snmpssh",
      5162: "snmpssh-trap",
      5163: "sbackup",
      5164: "vpa-disc",
      5165: "ife_icorp",
      5166: "winpcs",
      5167: "scte104",
      5168: "scte30",
      5172: "pcoip-mgmt",
      5190: "aol",
      5191: "aol-1",
      5192: "aol-2",
      5193: "aol-3",
      5194: "cpscomm",
      5195: "ampl-lic",
      5196: "ampl-tableproxy",
      5197: "tunstall-lwp",
      5200: "targus-getdata",
      5201: "targus-getdata1",
      5202: "targus-getdata2",
      5203: "targus-getdata3",
      5209: "nomad",
      5215: "noteza",
      5221: "3exmp",
      5222: "xmpp-client",
      5223: "hpvirtgrp",
      5224: "hpvirtctrl",
      5225: "hp-server",
      5226: "hp-status",
      5227: "perfd",
      5228: "hpvroom",
      5229: "jaxflow",
      5230: "jaxflow-data",
      5231: "crusecontrol",
      5232: "csedaemon",
      5233: "enfs",
      5234: "eenet",
      5235: "galaxy-network",
      5236: "padl2sim",
      5237: "mnet-discovery",
      5245: "downtools-disc",
      5246: "capwap-control",
      5247: "capwap-data",
      5248: "caacws",
      5249: "caaclang2",
      5250: "soagateway",
      5251: "caevms",
      5252: "movaz-ssc",
      5253: "kpdp",
      5254: "logcabin",
      5264: "3com-njack-1",
      5265: "3com-njack-2",
      5269: "xmpp-server",
      5270: "cartographerxmp",
      5271: "cuelink-disc",
      5272: "pk",
      5280: "xmpp-bosh",
      5281: "undo-lm",
      5282: "transmit-port",
      5298: "presence",
      5299: "nlg-data",
      5300: "hacl-hb",
      5301: "hacl-gs",
      5302: "hacl-cfg",
      5303: "hacl-probe",
      5304: "hacl-local",
      5305: "hacl-test",
      5306: "sun-mc-grp",
      5307: "sco-aip",
      5308: "cfengine",
      5309: "jprinter",
      5310: "outlaws",
      5312: "permabit-cs",
      5313: "rrdp",
      5314: "opalis-rbt-ipc",
      5315: "hacl-poll",
      5316: "hpbladems",
      5317: "hpdevms",
      5318: "pkix-cmc",
      5320: "bsfserver-zn",
      5321: "bsfsvr-zn-ssl",
      5343: "kfserver",
      5344: "xkotodrcp",
      5349: "stun-behaviors",
      5350: "pcp-multicast",
      5351: "pcp",
      5352: "dns-llq",
      5353: "mdns",
      5354: "mdnsresponder",
      5355: "llmnr",
      5356: "ms-smlbiz",
      5357: "wsdapi",
      5358: "wsdapi-s",
      5359: "ms-alerter",
      5360: "ms-sideshow",
      5361: "ms-s-sideshow",
      5362: "serverwsd2",
      5363: "net-projection",
      5364: "kdnet",
      5397: "stresstester",
      5398: "elektron-admin",
      5399: "securitychase",
      5400: "excerpt",
      5401: "excerpts",
      5402: "mftp",
      5403: "hpoms-ci-lstn",
      5404: "hpoms-dps-lstn",
      5405: "netsupport",
      5406: "systemics-sox",
      5407: "foresyte-clear",
      5408: "foresyte-sec",
      5409: "salient-dtasrv",
      5410: "salient-usrmgr",
      5411: "actnet",
      5412: "continuus",
      5413: "wwiotalk",
      5414: "statusd",
      5415: "ns-server",
      5416: "sns-gateway",
      5417: "sns-agent",
      5418: "mcntp",
      5419: "dj-ice",
      5420: "cylink-c",
      5421: "netsupport2",
      5422: "salient-mux",
      5423: "virtualuser",
      5424: "beyond-remote",
      5425: "br-channel",
      5426: "devbasic",
      5427: "sco-peer-tta",
      5428: "telaconsole",
      5429: "base",
      5430: "radec-corp",
      5431: "park-agent",
      5432: "postgresql",
      5433: "pyrrho",
      5434: "sgi-arrayd",
      5435: "sceanics",
      5436: "pmip6-cntl",
      5437: "pmip6-data",
      5443: "spss",
      5445: "smbdirect",
      5450: "tiepie-disc",
      5453: "surebox",
      5454: "apc-5454",
      5455: "apc-5455",
      5456: "apc-5456",
      5461: "silkmeter",
      5462: "ttl-publisher",
      5463: "ttlpriceproxy",
      5464: "quailnet",
      5465: "netops-broker",
      5470: "apsolab-col",
      5471: "apsolab-cols",
      5472: "apsolab-tag",
      5473: "apsolab-tags",
      5474: "apsolab-rpc",
      5475: "apsolab-data",
      5500: "fcp-addr-srvr1",
      5501: "fcp-addr-srvr2",
      5502: "fcp-srvr-inst1",
      5503: "fcp-srvr-inst2",
      5504: "fcp-cics-gw1",
      5505: "checkoutdb",
      5506: "amc",
      5507: "psl-management",
      5540: "matter",
      5550: "cbus",
      5553: "sgi-eventmond",
      5554: "sgi-esphttp",
      5555: "personal-agent",
      5556: "freeciv",
      5557: "farenet",
      5565: "dp-bura",
      5566: "westec-connect",
      5567: "dof-dps-mc-sec",
      5568: "sdt",
      5569: "rdmnet-device",
      5573: "sdmmp",
      5574: "lsi-bobcat",
      5575: "ora-oap",
      5579: "fdtracks",
      5580: "tmosms0",
      5581: "tmosms1",
      5582: "fac-restore",
      5583: "tmo-icon-sync",
      5584: "bis-web",
      5585: "bis-sync",
      5586: "att-mt-sms",
      5597: "ininmessaging",
      5598: "mctfeed",
      5599: "esinstall",
      5600: "esmmanager",
      5601: "esmagent",
      5602: "a1-msc",
      5603: "a1-bs",
      5604: "a3-sdunode",
      5605: "a4-sdunode",
      5618: "efr",
      5627: "ninaf",
      5628: "htrust",
      5629: "symantec-sfdb",
      5630: "precise-comm",
      5631: "pcanywheredata",
      5632: "pcanywherestat",
      5633: "beorl",
      5634: "xprtld",
      5635: "sfmsso",
      5636: "sfm-db-server",
      5637: "cssc",
      5638: "flcrs",
      5639: "ics",
      5646: "vfmobile",
      5666: "nrpe",
      5670: "zre-disc",
      5671: "amqps",
      5672: "amqp",
      5673: "jms",
      5674: "hyperscsi-port",
      5675: "v5ua",
      5676: "raadmin",
      5677: "questdb2-lnchr",
      5678: "rrac",
      5679: "dccm",
      5680: "auriga-router",
      5681: "ncxcp",
      5682: "brightcore",
      5683: "coap",
      5684: "coaps",
      5687: "gog-multiplayer",
      5688: "ggz",
      5689: "qmvideo",
      5693: "rbsystem",
      5696: "kmip",
      5700: "supportassist",
      5705: "storageos",
      5713: "proshareaudio",
      5714: "prosharevideo",
      5715: "prosharedata",
      5716: "prosharerequest",
      5717: "prosharenotify",
      5718: "dpm",
      5719: "dpm-agent",
      5720: "ms-licensing",
      5721: "dtpt",
      5722: "msdfsr",
      5723: "omhs",
      5724: "omsdk",
      5725: "ms-ilm",
      5726: "ms-ilm-sts",
      5727: "asgenf",
      5728: "io-dist-group",
      5729: "openmail",
      5730: "unieng",
      5741: "ida-discover1",
      5742: "ida-discover2",
      5743: "watchdoc-pod",
      5744: "watchdoc",
      5745: "fcopy-server",
      5746: "fcopys-server",
      5747: "tunatic",
      5748: "tunalyzer",
      5750: "rscd",
      5755: "openmailg",
      5757: "x500ms",
      5766: "openmailns",
      5767: "s-openmail",
      5768: "openmailpxy",
      5769: "spramsca",
      5770: "spramsd",
      5771: "netagent",
      5777: "starfield-io",
      5780: "vts-rpc",
      5781: "3par-evts",
      5782: "3par-mgmt",
      5783: "3par-mgmt-ssl",
      5784: "ibar",
      5785: "3par-rcopy",
      5786: "cisco-redu",
      5787: "waascluster",
      5793: "xtreamx",
      5794: "spdp",
      5798: "enlabel-dpl",
      5813: "icmpd",
      5814: "spt-automation",
      5841: "shiprush-d-ch",
      5842: "reversion",
      5859: "wherehoo",
      5863: "ppsuitemsg",
      5868: "diameters",
      5883: "jute",
      5900: "rfb",
      5910: "cm",
      5911: "cpdlc",
      5912: "fis",
      5913: "ads-c",
      5963: "indy",
      5968: "mppolicy-v5",
      5969: "mppolicy-mgr",
      5984: "couchdb",
      5985: "wsman",
      5986: "wsmans",
      5987: "wbem-rmi",
      5988: "wbem-http",
      5989: "wbem-https",
      5990: "wbem-exp-https",
      5991: "nuxsl",
      5992: "consul-insight",
      5993: "cim-rs",
      5994: "rms-agent",
      5999: "cvsup",
      6000: "x11",
      6001: "x11",
      6002: "x11",
      6003: "x11",
      6004: "x11",
      6005: "x11",
      6006: "x11",
      6007: "x11",
      6008: "x11",
      6009: "x11",
      6010: "x11",
      6011: "x11",
      6012: "x11",
      6013: "x11",
      6014: "x11",
      6015: "x11",
      6016: "x11",
      6017: "x11",
      6018: "x11",
      6019: "x11",
      6020: "x11",
      6021: "x11",
      6022: "x11",
      6023: "x11",
      6024: "x11",
      6025: "x11",
      6026: "x11",
      6027: "x11",
      6028: "x11",
      6029: "x11",
      6030: "x11",
      6031: "x11",
      6032: "x11",
      6033: "x11",
      6034: "x11",
      6035: "x11",
      6036: "x11",
      6037: "x11",
      6038: "x11",
      6039: "x11",
      6040: "x11",
      6041: "x11",
      6042: "x11",
      6043: "x11",
      6044: "x11",
      6045: "x11",
      6046: "x11",
      6047: "x11",
      6048: "x11",
      6049: "x11",
      6050: "x11",
      6051: "x11",
      6052: "x11",
      6053: "x11",
      6054: "x11",
      6055: "x11",
      6056: "x11",
      6057: "x11",
      6058: "x11",
      6059: "x11",
      6060: "x11",
      6061: "x11",
      6062: "x11",
      6063: "x11",
      6064: "ndl-ahp-svc",
      6065: "winpharaoh",
      6066: "ewctsp",
      6068: "gsmp-ancp",
      6069: "trip",
      6070: "messageasap",
      6071: "ssdtp",
      6072: "diagnose-proc",
      6073: "directplay8",
      6074: "max",
      6075: "dpm-acm",
      6076: "msft-dpm-cert",
      6077: "iconstructsrv",
      6080: "gue",
      6081: "geneve",
      6082: "p25cai",
      6083: "miami-bcast",
      6084: "reload-config",
      6085: "konspire2b",
      6086: "pdtp",
      6087: "ldss",
      6088: "doglms-notify",
      6099: "raxa-mgmt",
      6100: "synchronet-db",
      6101: "synchronet-rtc",
      6102: "synchronet-upd",
      6103: "rets",
      6104: "dbdb",
      6105: "primaserver",
      6106: "mpsserver",
      6107: "etc-control",
      6108: "sercomm-scadmin",
      6109: "globecast-id",
      6110: "softcm",
      6111: "spc",
      6112: "dtspcd",
      6113: "dayliteserver",
      6114: "wrspice",
      6115: "xic",
      6116: "xtlserv",
      6117: "daylitetouch",
      6118: "tipc",
      6121: "spdy",
      6122: "bex-webadmin",
      6123: "backup-express",
      6124: "pnbs",
      6130: "damewaremobgtwy",
      6133: "nbt-wol",
      6140: "pulsonixnls",
      6141: "meta-corp",
      6142: "aspentec-lm",
      6143: "watershed-lm",
      6144: "statsci1-lm",
      6145: "statsci2-lm",
      6146: "lonewolf-lm",
      6147: "montage-lm",
      6148: "ricardo-lm",
      6149: "tal-pod",
      6159: "efb-aci",
      6160: "ecmp-data",
      6161: "patrol-ism",
      6162: "patrol-coll",
      6163: "pscribe",
      6200: "lm-x",
      6201: "thermo-calc",
      6209: "qmtps",
      6222: "radmind",
      6241: "jeol-nsddp-1",
      6242: "jeol-nsddp-2",
      6243: "jeol-nsddp-3",
      6244: "jeol-nsddp-4",
      6251: "tl1-raw-ssl",
      6252: "tl1-ssh",
      6253: "crip",
      6267: "gld",
      6268: "grid",
      6269: "grid-alt",
      6300: "bmc-grx",
      6301: "bmc_ctd_ldap",
      6306: "ufmp",
      6315: "scup-disc",
      6316: "abb-escp",
      6317: "nav-data",
      6320: "repsvc",
      6321: "emp-server1",
      6322: "emp-server2",
      6324: "hrd-ns-disc",
      6325: "dt-mgmtsvc",
      6326: "dt-vra",
      6343: "sflow",
      6344: "streletz",
      6346: "gnutella-svc",
      6347: "gnutella-rtr",
      6350: "adap",
      6355: "pmcs",
      6360: "metaedit-mu",
      6363: "ndn",
      6370: "metaedit-se",
      6379: "redis",
      6382: "metatude-mds",
      6389: "clariion-evr01",
      6390: "metaedit-ws",
      6400: "boe-cms",
      6401: "boe-was",
      6402: "boe-eventsrv",
      6403: "boe-cachesvr",
      6404: "boe-filesvr",
      6405: "boe-pagesvr",
      6406: "boe-processsvr",
      6407: "boe-resssvr1",
      6408: "boe-resssvr2",
      6409: "boe-resssvr3",
      6410: "boe-resssvr4",
      6417: "faxcomservice",
      6418: "syserverremote",
      6419: "svdrp-disc",
      6420: "nim-vdrshell",
      6421: "nim-wan",
      6432: "pgbouncer",
      6440: "heliosd",
      6442: "tarp",
      6443: "sun-sr-https",
      6444: "sge_qmaster",
      6445: "sge_execd",
      6446: "mysql-proxy",
      6455: "skip-cert-recv",
      6456: "skip-cert-send",
      6464: "ieee11073-20701",
      6471: "lvision-lm",
      6480: "sun-sr-http",
      6481: "servicetags",
      6482: "ldoms-mgmt",
      6483: "SunVTS-RMI",
      6484: "sun-sr-jms",
      6485: "sun-sr-iiop",
      6486: "sun-sr-iiops",
      6487: "sun-sr-iiop-aut",
      6488: "sun-sr-jmx",
      6489: "sun-sr-admin",
      6500: "boks",
      6501: "boks_servc",
      6502: "boks_servm",
      6503: "boks_clntd",
      6505: "badm_priv",
      6506: "badm_pub",
      6507: "bdir_priv",
      6508: "bdir_pub",
      6509: "mgcs-mfp-port",
      6510: "mcer-port",
      6511: "dccp-udp",
      6513: "netconf-tls",
      6514: "syslog-tls",
      6515: "elipse-rec",
      6543: "lds-distrib",
      6544: "lds-dump",
      6547: "apc-6547",
      6548: "apc-6548",
      6549: "apc-6549",
      6550: "fg-sysupdate",
      6551: "sum",
      6556: "checkmk-agent",
      6558: "xdsxdm",
      6566: "sane-port",
      6568: "rp-reputation",
      6579: "affiliate",
      6580: "parsec-master",
      6581: "parsec-peer",
      6582: "parsec-game",
      6583: "joaJewelSuite",
      6600: "mshvlm",
      6601: "mstmg-sstp",
      6602: "wsscomfrmwk",
      6619: "odette-ftps",
      6620: "kftp-data",
      6621: "kftp",
      6622: "mcftp",
      6623: "ktelnet",
      6624: "datascaler-db",
      6625: "datascaler-ctl",
      6626: "wago-service",
      6627: "nexgen",
      6628: "afesc-mc",
      6629: "nexgen-aux",
      6632: "mxodbc-connect",
      6633: "cisco-vpath-tun",
      6634: "mpls-pm",
      6635: "mpls-udp",
      6636: "mpls-udp-dtls",
      6640: "ovsdb",
      6653: "openflow",
      6655: "pcs-sf-ui-man",
      6656: "emgmsg",
      6657: "palcom-disc",
      6665: "ircu",
      6666: "ircu",
      6667: "ircu",
      6668: "ircu",
      6669: "ircu",
      6670: "vocaltec-gold",
      6671: "p4p-portal",
      6672: "vision_server",
      6673: "vision_elmd",
      6678: "vfbp-disc",
      6679: "osaut",
      6687: "clever-ctrace",
      6688: "clever-tcpip",
      6689: "tsa",
      6690: "cleverdetect",
      6696: "babel",
      6697: "ircs-u",
      6699: "babel-dtls",
      6701: "kti-icad-srvr",
      6702: "e-design-net",
      6703: "e-design-web",
      6704: "frc-hp",
      6705: "frc-mp",
      6706: "frc-lp",
      6714: "ibprotocol",
      6715: "fibotrader-com",
      6716: "princity-agent",
      6767: "bmc-perf-agent",
      6768: "bmc-perf-mgrd",
      6769: "adi-gxp-srvprt",
      6770: "plysrv-http",
      6771: "plysrv-https",
      6777: "ntz-tracker",
      6778: "ntz-p2p-storage",
      6784: "bfd-lag",
      6785: "dgpf-exchg",
      6786: "smc-jmx",
      6787: "smc-admin",
      6788: "smc-http",
      6789: "radg",
      6790: "hnmp",
      6791: "hnm",
      6801: "acnet",
      6817: "pentbox-sim",
      6831: "ambit-lm",
      6841: "netmo-default",
      6842: "netmo-http",
      6850: "iccrushmore",
      6868: "acctopus-st",
      6888: "muse",
      6900: "rtimeviewer",
      6901: "jetstream",
      6924: "split-ping",
      6935: "ethoscan",
      6936: "xsmsvc",
      6946: "bioserver",
      6951: "otlp",
      6961: "jmact3",
      6962: "jmevt2",
      6963: "swismgr1",
      6964: "swismgr2",
      6965: "swistrap",
      6966: "swispol",
      6969: "acmsoda",
      6970: "conductor-mpx",
      6997: "MobilitySrv",
      6998: "iatp-highpri",
      6999: "iatp-normalpri",
      7000: "afs3-fileserver",
      7001: "afs3-callback",
      7002: "afs3-prserver",
      7003: "afs3-vlserver",
      7004: "afs3-kaserver",
      7005: "afs3-volser",
      7006: "afs3-errors",
      7007: "afs3-bos",
      7008: "afs3-update",
      7009: "afs3-rmtsys",
      7010: "ups-onlinet",
      7011: "talon-disc",
      7012: "talon-engine",
      7013: "microtalon-dis",
      7014: "microtalon-com",
      7015: "talon-webserver",
      7016: "spg",
      7017: "grasp",
      7018: "fisa-svc",
      7019: "doceri-view",
      7020: "dpserve",
      7021: "dpserveadmin",
      7022: "ctdp",
      7023: "ct2nmcs",
      7024: "vmsvc",
      7025: "vmsvc-2",
      7026: "loreji-panel",
      7030: "op-probe",
      7031: "iposplanet",
      7040: "quest-disc",
      7070: "arcp",
      7071: "iwg1",
      7072: "iba-cfg-disc",
      7073: "martalk",
      7080: "empowerid",
      7088: "zixi-transport",
      7095: "jdp-disc",
      7099: "lazy-ptop",
      7100: "font-service",
      7101: "elcn",
      7107: "aes-x170",
      7117: "rothaga",
      7121: "virprot-lm",
      7128: "scenidm",
      7129: "scenccs",
      7161: "cabsm-comm",
      7162: "caistoragemgr",
      7163: "cacsambroker",
      7164: "fsr",
      7165: "doc-server",
      7166: "aruba-server",
      7167: "casrmagent",
      7168: "cnckadserver",
      7169: "ccag-pib",
      7170: "nsrp",
      7171: "drm-production",
      7172: "metalbend",
      7173: "zsecure",
      7174: "clutild",
      7181: "janus-disc",
      7200: "fodms",
      7201: "dlip",
      7202: "pon-ictp",
      7215: "PS-Server",
      7216: "PS-Capture-Pro",
      7227: "ramp",
      7228: "citrixupp",
      7229: "citrixuppg",
      7234: "asa-gateways",
      7235: "aspcoordination",
      7236: "display",
      7237: "pads",
      7244: "frc-hicp-disc",
      7262: "cnap",
      7272: "watchme-7272",
      7273: "oma-rlp",
      7274: "oma-rlp-s",
      7275: "oma-ulp",
      7276: "oma-ilp",
      7277: "oma-ilp-s",
      7278: "oma-dcdocbs",
      7279: "ctxlic",
      7280: "itactionserver1",
      7281: "itactionserver2",
      7282: "mzca-alert",
      7283: "genstat",
      7300: "swx",
      7301: "swx",
      7302: "swx",
      7303: "swx",
      7304: "swx",
      7305: "swx",
      7306: "swx",
      7307: "swx",
      7308: "swx",
      7309: "swx",
      7310: "swx",
      7311: "swx",
      7312: "swx",
      7313: "swx",
      7314: "swx",
      7315: "swx",
      7316: "swx",
      7317: "swx",
      7318: "swx",
      7319: "swx",
      7320: "swx",
      7321: "swx",
      7322: "swx",
      7323: "swx",
      7324: "swx",
      7325: "swx",
      7326: "swx",
      7327: "swx",
      7328: "swx",
      7329: "swx",
      7330: "swx",
      7331: "swx",
      7332: "swx",
      7333: "swx",
      7334: "swx",
      7335: "swx",
      7336: "swx",
      7337: "swx",
      7338: "swx",
      7339: "swx",
      7340: "swx",
      7341: "swx",
      7342: "swx",
      7343: "swx",
      7344: "swx",
      7345: "swx",
      7346: "swx",
      7347: "swx",
      7348: "swx",
      7349: "swx",
      7350: "swx",
      7351: "swx",
      7352: "swx",
      7353: "swx",
      7354: "swx",
      7355: "swx",
      7356: "swx",
      7357: "swx",
      7358: "swx",
      7359: "swx",
      7365: "lcm-server",
      7391: "mindfilesys",
      7392: "mrssrendezvous",
      7393: "nfoldman",
      7394: "fse",
      7395: "winqedit",
      7397: "hexarc",
      7400: "rtps-discovery",
      7401: "rtps-dd-ut",
      7402: "rtps-dd-mt",
      7410: "ionixnetmon",
      7411: "daqstream",
      7420: "ipluminary",
      7421: "mtportmon",
      7426: "pmdmgr",
      7427: "oveadmgr",
      7428: "ovladmgr",
      7429: "opi-sock",
      7430: "xmpv7",
      7431: "pmd",
      7437: "faximum",
      7443: "oracleas-https",
      7471: "sttunnel",
      7473: "rise",
      7474: "neo4j",
      7478: "openit",
      7491: "telops-lmd",
      7500: "silhouette",
      7501: "ovbus",
      7508: "adcp",
      7509: "acplt",
      7510: "ovhpas",
      7511: "pafec-lm",
      7542: "saratoga",
      7543: "atul",
      7544: "nta-ds",
      7545: "nta-us",
      7546: "cfs",
      7547: "cwmp",
      7548: "tidp",
      7549: "nls-tl",
      7550: "cloudsignaling",
      7551: "controlone-con",
      7560: "sncp",
      7563: "cfw",
      7566: "vsi-omega",
      7569: "dell-eql-asm",
      7570: "aries-kfinder",
      7574: "coherence-disc",
      7588: "sun-lm",
      7606: "mipi-debug",
      7624: "indi",
      7626: "simco",
      7627: "soap-http",
      7628: "zen-pawn",
      7629: "xdas",
      7630: "hawk",
      7631: "tesla-sys-msg",
      7633: "pmdfmgt",
      7648: "cuseeme",
      7663: "rome",
      7672: "imqstomp",
      7673: "imqstomps",
      7674: "imqtunnels",
      7675: "imqtunnel",
      7676: "imqbrokerd",
      7677: "sun-user-https",
      7680: "pando-pub",
      7683: "dmt",
      7687: "bolt",
      7689: "collaber",
      7697: "klio",
      7700: "em7-secom",
      7701: "nfapi",
      7707: "sync-em7",
      7708: "scinet",
      7720: "medimageportal",
      7724: "nsdeepfreezectl",
      7725: "nitrogen",
      7726: "freezexservice",
      7727: "trident-data",
      7728: "osvr",
      7734: "smip",
      7738: "aiagent",
      7741: "scriptview",
      7742: "msss",
      7743: "sstp-1",
      7744: "raqmon-pdu",
      7747: "prgp",
      7775: "inetfs",
      7777: "cbt",
      7778: "interwise",
      7779: "vstat",
      7781: "accu-lmgr",
      7784: "s-bfd",
      7786: "minivend",
      7787: "popup-reminders",
      7789: "office-tools",
      7794: "q3ade",
      7797: "pnet-conn",
      7798: "pnet-enc",
      7799: "altbsdp",
      7800: "asr",
      7801: "ssp-client",
      7802: "vns-tp",
      7810: "rbt-wanopt",
      7845: "apc-7845",
      7846: "apc-7846",
      7847: "csoauth",
      7869: "mobileanalyzer",
      7870: "rbt-smc",
      7871: "mdm",
      7872: "mipv6tls",
      7878: "owms",
      7880: "pss",
      7887: "ubroker",
      7900: "mevent",
      7901: "tnos-sp",
      7902: "tnos-dp",
      7903: "tnos-dps",
      7913: "qo-secure",
      7932: "t2-drm",
      7933: "t2-brm",
      7962: "generalsync",
      7967: "supercell",
      7979: "micromuse-ncps",
      7980: "quest-vista",
      7981: "sossd-collect",
      7982: "sossd-disc",
      7997: "pushns",
      7998: "usicontentpush",
      7999: "irdmi2",
      8000: "irdmi",
      8001: "vcom-tunnel",
      8002: "teradataordbms",
      8003: "mcreport",
      8004: "p2pevolvenet",
      8005: "mxi",
      8006: "wpl-disc",
      8007: "warppipe",
      8008: "http-alt",
      8009: "nvme-disc",
      8015: "cfg-cloud",
      8016: "ads-s",
      8017: "cisco-cloudsec",
      8019: "qbdb",
      8020: "intu-ec-svcdisc",
      8021: "intu-ec-client",
      8022: "oa-system",
      8023: "arca-api",
      8025: "ca-audit-da",
      8026: "ca-audit-ds",
      8027: "papachi-p2p-srv",
      8032: "pro-ed",
      8033: "mindprint",
      8034: "vantronix-mgmt",
      8040: "ampify",
      8041: "enguity-xccetp",
      8042: "fs-agent",
      8043: "fs-server",
      8044: "fs-mgmt",
      8051: "rocrail",
      8052: "senomix01",
      8053: "senomix02",
      8054: "senomix03",
      8055: "senomix04",
      8056: "senomix05",
      8057: "senomix06",
      8058: "senomix07",
      8059: "senomix08",
      8060: "aero",
      8066: "toad-bi-appsrvr",
      8067: "infi-async",
      8070: "ucs-isc",
      8074: "gadugadu",
      8077: "mles",
      8080: "http-alt",
      8081: "sunproxyadmin",
      8082: "us-cli",
      8083: "us-srv",
      8084: "websnp",
      8086: "d-s-n",
      8087: "simplifymedia",
      8088: "radan-http",
      8090: "opsmessaging",
      8091: "jamlink",
      8097: "sac",
      8100: "xprint-server",
      8101: "ldoms-migr",
      8102: "kz-migr",
      8111: "skynetflow",
      8115: "mtl8000-matrix",
      8116: "cp-cluster",
      8117: "purityrpc",
      8118: "privoxy",
      8121: "apollo-data",
      8122: "apollo-admin",
      8128: "paycash-online",
      8129: "paycash-wbp",
      8130: "indigo-vrmi",
      8131: "indigo-vbcp",
      8132: "dbabble",
      8140: "puppet",
      8148: "isdd",
      8149: "eor-game",
      8153: "quantastor",
      8160: "patrol",
      8161: "patrol-snmp",
      8162: "lpar2rrd",
      8181: "intermapper",
      8182: "vmware-fdm",
      8183: "proremote",
      8184: "itach",
      8190: "gcp-rphy",
      8191: "limnerpressure",
      8192: "spytechphone",
      8194: "blp1",
      8195: "blp2",
      8199: "vvr-data",
      8200: "trivnet1",
      8201: "trivnet2",
      8202: "aesop",
      8204: "lm-perfworks",
      8205: "lm-instmgr",
      8206: "lm-dta",
      8207: "lm-sserver",
      8208: "lm-webwatcher",
      8211: "aruba-papi",
      8230: "rexecj",
      8231: "hncp-udp-port",
      8232: "hncp-dtls-port",
      8243: "synapse-nhttps",
      8266: "espeasy-p2p",
      8270: "robot-remote",
      8276: "pando-sec",
      8280: "synapse-nhttp",
      8282: "libelle-disc",
      8292: "blp3",
      8293: "hiperscan-id",
      8294: "blp4",
      8300: "tmi",
      8301: "amberon",
      8313: "hub-open-net",
      8320: "tnp-discover",
      8321: "tnp",
      8322: "garmin-marine",
      8351: "server-find",
      8376: "cruise-enum",
      8377: "cruise-swroute",
      8378: "cruise-config",
      8379: "cruise-diags",
      8380: "cruise-update",
      8383: "m2mservices",
      8384: "marathontp",
      8400: "cvd",
      8401: "sabarsd",
      8402: "abarsd",
      8403: "admind",
      8404: "svcloud",
      8405: "svbackup",
      8415: "dlpx-sp",
      8416: "espeech",
      8417: "espeech-rtp",
      8423: "aritts",
      8442: "cybro-a-bus",
      8443: "pcsync-https",
      8444: "pcsync-http",
      8445: "copy-disc",
      8450: "npmp",
      8457: "nexentamv",
      8470: "cisco-avp",
      8471: "pim-port",
      8472: "otv",
      8473: "vp2p",
      8474: "noteshare",
      8500: "fmtp",
      8501: "cmtp-av",
      8502: "ftnmtp",
      8503: "lsp-self-ping",
      8554: "rtsp-alt",
      8555: "d-fence",
      8567: "dof-tunnel",
      8600: "asterix",
      8609: "canon-cpp-disc",
      8610: "canon-mfnp",
      8611: "canon-bjnp1",
      8612: "canon-bjnp2",
      8613: "canon-bjnp3",
      8614: "canon-bjnp4",
      8615: "imink",
      8665: "monetra",
      8666: "monetra-admin",
      8675: "msi-cps-rm-disc",
      8686: "sun-as-jmxrmi",
      8688: "openremote-ctrl",
      8699: "vnyx",
      8710: "semi-grpc",
      8711: "nvc",
      8732: "dtp-net",
      8733: "ibus",
      8750: "dey-keyneg",
      8763: "mc-appserver",
      8764: "openqueue",
      8765: "ultraseek-http",
      8766: "amcs",
      8767: "core-of-source",
      8768: "sandpolis",
      8769: "oktaauthenticat",
      8770: "dpap",
      8778: "uec",
      8786: "msgclnt",
      8787: "msgsrvr",
      8793: "acd-pm",
      8800: "sunwebadmin",
      8804: "truecm",
      8805: "pfcp",
      8807: "hes-clip",
      8808: "ssports-bcast",
      8809: "3gpp-monp",
      8873: "dxspider",
      8880: "cddbp-alt",
      8881: "galaxy4d",
      8883: "secure-mqtt",
      8888: "ddi-udp-1",
      8889: "ddi-udp-2",
      8890: "ddi-udp-3",
      8891: "ddi-udp-4",
      8892: "ddi-udp-5",
      8893: "ddi-udp-6",
      8894: "ddi-udp-7",
      8899: "ospf-lite",
      8900: "jmb-cds1",
      8901: "jmb-cds2",
      8908: "dpp",
      8910: "manyone-http",
      8911: "manyone-xml",
      8912: "wcbackup",
      8913: "dragonfly",
      8937: "twds",
      8953: "ub-dns-control",
      8954: "cumulus-admin",
      8980: "nod-provider",
      8981: "nod-client",
      8989: "sunwebadmins",
      8990: "http-wmap",
      8991: "https-wmap",
      8997: "oracle-ms-ens",
      8998: "canto-roboflow",
      8999: "bctp",
      9000: "cslistener",
      9001: "etlservicemgr",
      9002: "dynamid",
      9005: "golem",
      9007: "ogs-client",
      9008: "ogs-server",
      9009: "pichat",
      9010: "sdr",
      9011: "d-star",
      9020: "tambora",
      9021: "panagolin-ident",
      9022: "paragent",
      9023: "swa-1",
      9024: "swa-2",
      9025: "swa-3",
      9026: "swa-4",
      9050: "versiera",
      9051: "fio-cmgmt",
      9060: "CardWeb-RT",
      9080: "glrpc",
      9081: "cisco-aqos",
      9082: "lcs-ap",
      9083: "emc-pp-mgmtsvc",
      9084: "aurora",
      9085: "ibm-rsyscon",
      9086: "net2display",
      9087: "classic",
      9088: "sqlexec",
      9089: "sqlexec-ssl",
      9090: "websm",
      9091: "xmltec-xmlmail",
      9092: "XmlIpcRegSvc",
      9093: "copycat",
      9100: "pdl-datastream",
      9101: "bacula-dir",
      9102: "bacula-fd",
      9103: "bacula-sd",
      9104: "peerwire",
      9105: "xadmin",
      9106: "astergate-disc",
      9107: "astergatefax",
      9111: "hexxorecore",
      9119: "mxit",
      9122: "grcmp",
      9123: "grcp",
      9131: "dddp",
      9160: "apani1",
      9161: "apani2",
      9162: "apani3",
      9163: "apani4",
      9164: "apani5",
      9191: "sun-as-jpda",
      9200: "wap-wsp",
      9201: "wap-wsp-wtp",
      9202: "wap-wsp-s",
      9203: "wap-wsp-wtp-s",
      9204: "wap-vcard",
      9205: "wap-vcal",
      9206: "wap-vcard-s",
      9207: "wap-vcal-s",
      9208: "rjcdb-vcards",
      9209: "almobile-system",
      9210: "oma-mlp",
      9211: "oma-mlp-s",
      9212: "serverviewdbms",
      9213: "serverstart",
      9214: "ipdcesgbs",
      9215: "insis",
      9216: "acme",
      9217: "fsc-port",
      9222: "teamcoherence",
      9255: "mon",
      9277: "traingpsdata",
      9278: "pegasus",
      9279: "pegasus-ctl",
      9280: "pgps",
      9281: "swtp-port1",
      9282: "swtp-port2",
      9283: "callwaveiam",
      9284: "visd",
      9285: "n2h2server",
      9286: "n2receive",
      9287: "cumulus",
      9292: "armtechdaemon",
      9293: "storview",
      9294: "armcenterhttp",
      9295: "armcenterhttps",
      9300: "vrace",
      9306: "sphinxql",
      9310: "sapms",
      9312: "sphinxapi",
      9318: "secure-ts",
      9321: "guibase",
      9339: "gnmi-gnoi",
      9343: "mpidcmgr",
      9344: "mphlpdmc",
      9345: "rancher",
      9346: "ctechlicensing",
      9374: "fjdmimgr",
      9380: "boxp",
      9387: "d2dconfig",
      9388: "d2ddatatrans",
      9389: "adws",
      9390: "otp",
      9396: "fjinvmgr",
      9397: "mpidcagt",
      9400: "sec-t4net-srv",
      9401: "sec-t4net-clt",
      9402: "sec-pc2fax-srv",
      9418: "git",
      9443: "tungsten-https",
      9444: "wso2esb-console",
      9445: "mindarray-ca",
      9450: "sntlkeyssrvr",
      9500: "ismserver",
      9522: "sma-spw",
      9535: "mngsuite",
      9536: "laes-bf",
      9555: "trispen-sra",
      9559: "p4runtime",
      9592: "ldgateway",
      9593: "cba8",
      9594: "msgsys",
      9595: "pds",
      9596: "mercury-disc",
      9597: "pd-admin",
      9598: "vscp",
      9599: "robix",
      9600: "micromuse-ncpw",
      9612: "streamcomm-ds",
      9614: "iadt-tls",
      9616: "erunbook_agent",
      9617: "erunbook_server",
      9618: "condor",
      9628: "odbcpathway",
      9629: "uniport",
      9630: "peoctlr",
      9631: "peocoll",
      9632: "mc-comm",
      9640: "pqsflows",
      9666: "zoomcp",
      9667: "xmms2",
      9668: "tec5-sdctp",
      9694: "client-wakeup",
      9695: "ccnx",
      9700: "board-roar",
      9747: "l5nas-parchan",
      9750: "board-voip",
      9753: "rasadv",
      9762: "tungsten-http",
      9800: "davsrc",
      9801: "sstp-2",
      9802: "davsrcs",
      9875: "sapv1",
      9876: "sd",
      9877: "x510",
      9878: "kca-service",
      9888: "cyborg-systems",
      9889: "gt-proxy",
      9898: "monkeycom",
      9899: "sctp-tunneling",
      9900: "iua",
      9901: "enrp-sctp",
      9902: "enrp-sctp-tls",
      9903: "multicast-ping",
      9909: "domaintime",
      9911: "sype-transport",
      9925: "xybrid-cloud",
      9950: "apc-9950",
      9951: "apc-9951",
      9952: "apc-9952",
      9953: "acis",
      9954: "hinp",
      9955: "alljoyn-mcm",
      9956: "alljoyn",
      9966: "odnsp",
      9978: "xybrid-rt",
      9979: "visweather",
      9981: "pumpkindb",
      9987: "dsm-scm-target",
      9988: "nsesrvr",
      9990: "osm-appsrvr",
      9991: "osm-oev",
      9992: "palace-1",
      9993: "palace-2",
      9994: "palace-3",
      9995: "palace-4",
      9996: "palace-5",
      9997: "palace-6",
      9998: "distinct32",
      9999: "distinct",
      10000: "ndmp",
      10001: "scp-config",
      10002: "documentum",
      10003: "documentum_s",
      10004: "emcrmirccd",
      10005: "emcrmird",
      10006: "netapp-sync",
      10007: "mvs-capacity",
      10008: "octopus",
      10009: "swdtp-sv",
      10010: "rxapi",
      10020: "abb-hw",
      10023: "cefd-vmp",
      10050: "zabbix-agent",
      10051: "zabbix-trapper",
      10055: "qptlmd",
      10080: "amanda",
      10081: "famdc",
      10100: "itap-ddtp",
      10101: "ezmeeting-2",
      10102: "ezproxy-2",
      10103: "ezrelay",
      10104: "swdtp",
      10107: "bctp-server",
      10110: "nmea-0183",
      10111: "nmea-onenet",
      10113: "netiq-endpoint",
      10114: "netiq-qcheck",
      10115: "netiq-endpt",
      10116: "netiq-voipa",
      10117: "iqrm",
      10125: "cimple",
      10128: "bmc-perf-sd",
      10129: "bmc-gms",
      10160: "qb-db-server",
      10161: "snmpdtls",
      10162: "snmpdtls-trap",
      10200: "trisoap",
      10201: "rscs",
      10252: "apollo-relay",
      10253: "eapol-relay",
      10260: "axis-wimp-port",
      10261: "tile-ml",
      10288: "blocks",
      10321: "cosir",
      10439: "bngsync",
      10443: "cirrossp",
      10500: "hip-nat-t",
      10540: "MOS-lower",
      10541: "MOS-upper",
      10542: "MOS-aux",
      10543: "MOS-soap",
      10544: "MOS-soap-opt",
      10548: "serverdocs",
      10631: "printopia",
      10800: "gap",
      10805: "lpdg",
      10809: "nbd",
      10810: "nmc-disc",
      10860: "helix",
      10880: "bveapi",
      10933: "octopustentacle",
      10990: "rmiaux",
      11000: "irisa",
      11001: "metasys",
      11095: "weave",
      11103: "origo-sync",
      11104: "netapp-icmgmt",
      11105: "netapp-icdata",
      11106: "sgi-lk",
      11108: "myq-termlink",
      11109: "sgi-dmfmgr",
      11110: "sgi-soap",
      11111: "vce",
      11112: "dicom",
      11161: "suncacao-snmp",
      11162: "suncacao-jmxmp",
      11163: "suncacao-rmi",
      11164: "suncacao-csa",
      11165: "suncacao-websvc",
      11171: "snss",
      11172: "oemcacao-jmxmp",
      11173: "t5-straton",
      11174: "oemcacao-rmi",
      11175: "oemcacao-websvc",
      11201: "smsqp",
      11202: "dcsl-backup",
      11208: "wifree",
      11211: "memcache",
      11235: "xcompute",
      11319: "imip",
      11320: "imip-channels",
      11321: "arena-server",
      11367: "atm-uhas",
      11371: "hkp",
      11430: "lsdp",
      11489: "asgcypresstcps",
      11600: "tempest-port",
      11623: "emc-xsw-dconfig",
      11720: "h323callsigalt",
      11723: "emc-xsw-dcache",
      11751: "intrepid-ssl",
      11796: "lanschool-mpt",
      11876: "xoraya",
      11877: "x2e-disc",
      11967: "sysinfo-sp",
      11971: "tibsd",
      11997: "wmereceiving",
      11998: "wmedistribution",
      11999: "wmereporting",
      12000: "entextxid",
      12001: "entextnetwk",
      12002: "entexthigh",
      12003: "entextmed",
      12004: "entextlow",
      12005: "dbisamserver1",
      12006: "dbisamserver2",
      12007: "accuracer",
      12008: "accuracer-dbms",
      12009: "ghvpn",
      12010: "edbsrvr",
      12012: "vipera",
      12013: "vipera-ssl",
      12109: "rets-ssl",
      12121: "nupaper-ss",
      12168: "cawas",
      12172: "hivep",
      12300: "linogridengine",
      12302: "rads",
      12321: "warehouse-sss",
      12322: "warehouse",
      12345: "italk",
      12753: "tsaf",
      12865: "netperf",
      13160: "i-zipqd",
      13216: "bcslogc",
      13217: "rs-pias",
      13218: "emc-vcas-udp",
      13223: "powwow-client",
      13224: "powwow-server",
      13400: "doip-disc",
      13720: "bprd",
      13721: "bpdbm",
      13722: "bpjava-msvc",
      13724: "vnetd",
      13782: "bpcd",
      13783: "vopied",
      13785: "nbdb",
      13786: "nomdb",
      13818: "dsmcc-config",
      13819: "dsmcc-session",
      13820: "dsmcc-passthru",
      13821: "dsmcc-download",
      13822: "dsmcc-ccp",
      13823: "bmdss",
      13894: "ucontrol",
      13929: "dta-systems",
      13930: "medevolve",
      14000: "scotty-ft",
      14001: "sua",
      14002: "scotty-disc",
      14033: "sage-best-com1",
      14034: "sage-best-com2",
      14141: "vcs-app",
      14142: "icpp",
      14143: "icpps",
      14145: "gcm-app",
      14149: "vrts-tdd",
      14150: "vcscmd",
      14154: "vad",
      14250: "cps",
      14414: "ca-web-update",
      14500: "xpra",
      14936: "hde-lcesrvr-1",
      14937: "hde-lcesrvr-2",
      15000: "hydap",
      15002: "onep-tls",
      15118: "v2g-secc",
      15345: "xpilot",
      15363: "3link",
      15555: "cisco-snat",
      15660: "bex-xr",
      15740: "ptp",
      15998: "2ping",
      15999: "programmar",
      16000: "fmsas",
      16001: "fmsascon",
      16002: "gsms",
      16003: "alfin",
      16020: "jwpc",
      16021: "jwpc-bin",
      16161: "sun-sea-port",
      16162: "solaris-audit",
      16309: "etb4j",
      16310: "pduncs",
      16311: "pdefmns",
      16360: "netserialext1",
      16361: "netserialext2",
      16367: "netserialext3",
      16368: "netserialext4",
      16384: "connected",
      16385: "rdgs",
      16619: "xoms",
      16665: "axon-tunnel",
      16666: "vtp",
      16789: "cadsisvr",
      16900: "newbay-snc-mc",
      16950: "sgcip",
      16991: "intel-rci-mp",
      16992: "amt-soap-http",
      16993: "amt-soap-https",
      16994: "amt-redir-tcp",
      16995: "amt-redir-tls",
      17007: "isode-dua",
      17184: "vestasdlp",
      17185: "soundsvirtual",
      17219: "chipper",
      17220: "avtp",
      17221: "avdecc",
      17222: "cpsp",
      17223: "isa100-gci",
      17224: "trdp-pd",
      17225: "trdp-md",
      17234: "integrius-stp",
      17235: "ssh-mgmt",
      17500: "db-lsp-disc",
      17555: "ailith",
      17729: "ea",
      17754: "zep",
      17755: "zigbee-ip",
      17756: "zigbee-ips",
      17777: "sw-orion",
      18000: "biimenu",
      18104: "radpdf",
      18136: "racf",
      18181: "opsec-cvp",
      18182: "opsec-ufp",
      18183: "opsec-sam",
      18184: "opsec-lea",
      18185: "opsec-omi",
      18186: "ohsc",
      18187: "opsec-ela",
      18241: "checkpoint-rtm",
      18242: "iclid",
      18243: "clusterxl",
      18262: "gv-pf",
      18463: "ac-cluster",
      18516: "heythings",
      18634: "rds-ib",
      18635: "rds-ip",
      18668: "vdmmesh-disc",
      18769: "ique",
      18881: "infotos",
      18888: "apc-necmp",
      19000: "igrid",
      19007: "scintilla",
      19020: "j-link",
      19191: "opsec-uaa",
      19194: "ua-secureagent",
      19220: "cora-disc",
      19283: "keysrvr",
      19315: "keyshadow",
      19398: "mtrgtrans",
      19410: "hp-sco",
      19411: "hp-sca",
      19412: "hp-sessmon",
      19539: "fxuptp",
      19540: "sxuptp",
      19541: "jcp",
      19788: "mle",
      19790: "faircom-db",
      19998: "iec-104-sec",
      19999: "dnp-sec",
      20000: "dnp",
      20001: "microsan",
      20002: "commtact-http",
      20003: "commtact-https",
      20005: "openwebnet",
      20012: "ss-idi-disc",
      20013: "ss-idi",
      20014: "opendeploy",
      20034: "nburn_id",
      20046: "tmophl7mts",
      20048: "mountd",
      20049: "nfsrdma",
      20057: "avesterra",
      20167: "tolfab",
      20202: "ipdtp-port",
      20222: "ipulse-ics",
      20480: "emwavemsg",
      20670: "track",
      20810: "crtech-nlm",
      20999: "athand-mmp",
      21000: "irtrans",
      21010: "notezilla-lan",
      21212: "trinket-agent",
      21213: "cohesity-agent",
      21221: "aigairserver",
      21553: "rdm-tfs",
      21554: "dfserver",
      21590: "vofr-gateway",
      21800: "tvpm",
      21845: "webphone",
      21846: "netspeak-is",
      21847: "netspeak-cs",
      21848: "netspeak-acd",
      21849: "netspeak-cps",
      22000: "snapenetio",
      22001: "optocontrol",
      22002: "optohost002",
      22003: "optohost003",
      22004: "optohost004",
      22005: "optohost004",
      22125: "dcap",
      22128: "gsidcap",
      22222: "easyengine",
      22273: "wnn6",
      22305: "cis",
      22333: "showcockpit-net",
      22335: "shrewd-stream",
      22343: "cis-secure",
      22347: "wibukey",
      22350: "codemeter",
      22351: "codemeter-cmwan",
      22537: "caldsoft-backup",
      22555: "vocaltec-phone",
      22763: "talikaserver",
      22800: "aws-brf",
      22951: "brf-gw",
      23000: "inovaport1",
      23001: "inovaport2",
      23002: "inovaport3",
      23003: "inovaport4",
      23004: "inovaport5",
      23005: "inovaport6",
      23053: "gntp",
      23272: "s102",
      23294: "5afe-disc",
      23333: "elxmgmt",
      23400: "novar-dbase",
      23401: "novar-alarm",
      23402: "novar-global",
      23456: "aequus",
      23457: "aequus-alt",
      23546: "areaguard-neo",
      24000: "med-ltp",
      24001: "med-fsp-rx",
      24002: "med-fsp-tx",
      24003: "med-supp",
      24004: "med-ovw",
      24005: "med-ci",
      24006: "med-net-svc",
      24242: "filesphere",
      24249: "vista-4gl",
      24321: "ild",
      24322: "hid",
      24323: "vrmg-ip",
      24386: "intel_rci",
      24465: "tonidods",
      24554: "binkp",
      24577: "bilobit-update",
      24666: "sdtvwcam",
      24676: "canditv",
      24677: "flashfiler",
      24678: "proactivate",
      24680: "tcc-http",
      24754: "cslg",
      24850: "assoc-disc",
      24922: "find",
      25000: "icl-twobase1",
      25001: "icl-twobase2",
      25002: "icl-twobase3",
      25003: "icl-twobase4",
      25004: "icl-twobase5",
      25005: "icl-twobase6",
      25006: "icl-twobase7",
      25007: "icl-twobase8",
      25008: "icl-twobase9",
      25009: "icl-twobase10",
      25471: "rna",
      25576: "sauterdongle",
      25604: "idtp",
      25793: "vocaltec-hos",
      25900: "tasp-net",
      25901: "niobserver",
      25902: "nilinkanalyst",
      25903: "niprobe",
      25954: "bf-game",
      25955: "bf-master",
      26000: "quake",
      26133: "scscp",
      26208: "wnn6-ds",
      26257: "cockroach",
      26260: "ezproxy",
      26261: "ezmeeting",
      26262: "k3software-svr",
      26263: "k3software-cli",
      26486: "exoline-udp",
      26487: "exoconfig",
      26489: "exonet",
      27000: "flex-lm",
      27001: "flex-lm",
      27002: "flex-lm",
      27003: "flex-lm",
      27004: "flex-lm",
      27005: "flex-lm",
      27006: "flex-lm",
      27007: "flex-lm",
      27008: "flex-lm",
      27009: "flex-lm",
      27010: "flex-lmadmin",
      27017: "mongodb",
      27345: "imagepump",
      27442: "jesmsjc",
      27504: "kopek-httphead",
      27782: "ars-vista",
      27876: "astrolink",
      27999: "tw-auth-key",
      28000: "nxlmd",
      28001: "pqsp",
      28010: "gruber-cashreg",
      28080: "thor-engine",
      28119: "a27-ran-ran",
      28200: "voxelstorm",
      28240: "siemensgsm",
      28589: "bosswave",
      29000: "saltd-licensing",
      29118: "sgsap",
      29167: "otmp",
      29168: "sbcap",
      29169: "iuhsctpassoc",
      29999: "bingbang",
      30000: "ndmps",
      30001: "pago-services1",
      30002: "pago-services2",
      30003: "amicon-fpsu-ra",
      30004: "amicon-fpsu-s",
      30100: "rwp",
      30260: "kingdomsonline",
      30400: "gs-realtime",
      30832: "samsung-disc",
      30999: "ovobs",
      31016: "ka-kdp",
      31020: "autotrac-acp",
      31029: "yawn",
      31337: "eldim",
      31400: "pace-licensed",
      31416: "xqosd",
      31457: "tetrinet",
      31620: "lm-mon",
      31685: "dsx_monitor",
      31765: "gamesmith-port",
      31948: "iceedcp_tx",
      31949: "iceedcp_rx",
      32034: "iracinghelper",
      32249: "t1distproc60",
      32400: "plex",
      32483: "apm-link",
      32635: "sec-ntb-clnt",
      32636: "DMExpress",
      32767: "filenet-powsrm",
      32768: "filenet-tms",
      32769: "filenet-rpc",
      32770: "filenet-nch",
      32771: "filenet-rmi",
      32772: "filenet-pa",
      32773: "filenet-cm",
      32774: "filenet-re",
      32775: "filenet-pch",
      32776: "filenet-peior",
      32777: "filenet-obrok",
      32801: "mlsn",
      32811: "retp",
      32896: "idmgratm",
      33000: "wg-endpt-comms",
      33060: "mysqlx",
      33123: "aurora-balaena",
      33331: "diamondport",
      33333: "dgi-serv",
      33334: "speedtrace-disc",
      33434: "traceroute",
      33435: "mtrace",
      33656: "snip-slave",
      33890: "digilent-adept",
      34249: "turbonote-2",
      34378: "p-net-local",
      34379: "p-net-remote",
      34567: "edi_service",
      34962: "profinet-rt",
      34963: "profinet-rtm",
      34964: "profinet-cm",
      34980: "ethercat",
      35000: "heathview",
      35001: "rt-viewer",
      35002: "rt-sound",
      35003: "rt-devicemapper",
      35004: "rt-classmanager",
      35005: "rt-labtracker",
      35006: "rt-helper",
      35100: "axio-disc",
      35354: "kitim",
      35355: "altova-lm-disc",
      35356: "guttersnex",
      35357: "openstack-id",
      36001: "allpeers",
      36411: "wlcp",
      36412: "s1-control",
      36422: "x2-control",
      36423: "slmap",
      36424: "nq-ap",
      36443: "m2ap",
      36444: "m3ap",
      36462: "xw-control",
      36524: "febooti-aw",
      36602: "observium-agent",
      36700: "mapx",
      36865: "kastenxpipe",
      37472: "3gpp-w1ap",
      37475: "neckar",
      37483: "gdrive-sync",
      37601: "eftp",
      37654: "unisys-eportal",
      38000: "ivs-database",
      38001: "ivs-insertion",
      38002: "crescoctrl-disc",
      38201: "galaxy7-data",
      38202: "fairview",
      38203: "agpolicy",
      38412: "ng-control",
      38422: "xn-control",
      38462: "e1-interface",
      38472: "f1-control",
      38800: "sruth",
      38865: "secrmmsafecopya",
      39063: "vroa",
      39681: "turbonote-1",
      40000: "safetynetp",
      40023: "k-patentssensor",
      40404: "sptx",
      40841: "cscp",
      40842: "csccredir",
      40843: "csccfirewall",
      40853: "ortec-disc",
      41111: "fs-qos",
      41121: "tentacle",
      41230: "z-wave-s",
      41794: "crestron-cip",
      41795: "crestron-ctp",
      41796: "crestron-cips",
      41797: "crestron-ctps",
      42508: "candp",
      42509: "candrp",
      42510: "caerpc",
      43000: "recvr-rc-disc",
      43188: "reachout",
      43189: "ndm-agent-port",
      43190: "ip-provision",
      43191: "noit-transport",
      43210: "shaperai-disc",
      43438: "hmip-routing",
      43439: "eq3-config",
      43440: "ew-disc-cmd",
      43441: "ciscocsdb",
      44123: "z-wave-tunnel",
      44321: "pmcd",
      44322: "pmcdproxy",
      44323: "pmwebapi",
      44444: "cognex-dataman",
      44445: "acronis-backup",
      44544: "domiq",
      44553: "rbr-debug",
      44600: "asihpi",
      44818: "EtherNet/IP-2",
      44900: "m3da-disc",
      45000: "asmp-mon",
      45001: "asmps",
      45002: "rs-status",
      45045: "synctest",
      45054: "invision-ag",
      45514: "cloudcheck-ping",
      45678: "eba",
      45824: "dai-shell",
      45825: "qdb2service",
      45966: "ssr-servermgr",
      46336: "inedo",
      46998: "spremotetablet",
      46999: "mediabox",
      47000: "mbus",
      47001: "winrm",
      47100: "jvl-mactalk",
      47557: "dbbrowse",
      47624: "directplaysrvr",
      47806: "ap",
      47808: "bacnet",
      47809: "presonus-ucnet",
      48000: "nimcontroller",
      48001: "nimspooler",
      48002: "nimhub",
      48003: "nimgtw",
      48004: "nimbusdb",
      48005: "nimbusdbctrl",
      48048: "juka",
      48049: "3gpp-cbsp",
      48050: "weandsf",
      48128: "isnetserv",
      48129: "blp5",
      48556: "com-bardac-dw",
      48619: "iqobject",
      48653: "robotraconteur",
      49000: "matahari",
      49001: "nusdp-disc",
      49150: "inspider",
    };
  },
]);

angular.module('designer.model.helpers.protocols', [])
.service('ProtocolHelpers', [function() {
  return {
    protocols_numbers: {"0":"HOPOPT","1":"ICMP","2":"IGMP","3":"GGP","4":"IPv4","5":"ST","6":"TCP","7":"CBT","8":"EGP","9":"IGP","10":"BBN-RCC-MON","11":"NVP-II","12":"PUP","13":"ARGUS (deprecated)","14":"EMCON","15":"XNET","16":"CHAOS","17":"UDP","18":"MUX","19":"DCN-MEAS","20":"HMP","21":"PRM","22":"XNS-IDP","23":"TRUNK-1","24":"TRUNK-2","25":"LEAF-1","26":"LEAF-2","27":"RDP","28":"IRTP","29":"ISO-TP4","30":"NETBLT","31":"MFE-NSP","32":"MERIT-INP","33":"DCCP","34":"3PC","35":"IDPR","36":"XTP","37":"DDP","38":"IDPR-CMTP","39":"TP++","40":"IL","41":"IPv6","42":"SDRP","43":"IPv6-Route","44":"IPv6-Frag","45":"IDRP","46":"RSVP","47":"GRE","48":"DSR","49":"BNA","50":"ESP","51":"AH","52":"I-NLSP","53":"SWIPE (deprecated)","54":"NARP","55":"MOBILE","56":"TLSP","57":"SKIP","58":"IPv6-ICMP","59":"IPv6-NoNxt","60":"IPv6-Opts","61":null,"62":"CFTP","63":null,"64":"SAT-EXPAK","65":"KRYPTOLAN","66":"RVD","67":"IPPC","68":null,"69":"SAT-MON","70":"VISA","71":"IPCV","72":"CPNX","73":"CPHB","74":"WSN","75":"PVP","76":"BR-SAT-MON","77":"SUN-ND","78":"WB-MON","79":"WB-EXPAK","80":"ISO-IP","81":"VMTP","82":"SECURE-VMTP","83":"VINES","84":"IPTM","85":"NSFNET-IGP","86":"DGP","87":"TCF","88":"EIGRP","89":"OSPFIGP","90":"Sprite-RPC","91":"LARP","92":"MTP","93":"AX.25","94":"IPIP","95":"MICP (deprecated)","96":"SCC-SP","97":"ETHERIP","98":"ENCAP","99":null,"100":"GMTP","101":"IFMP","102":"PNNI","103":"PIM","104":"ARIS","105":"SCPS","106":"QNX","107":"A/N","108":"IPComp","109":"SNP","110":"Compaq-Peer","111":"IPX-in-IP","112":"VRRP","113":"PGM","114":null,"115":"L2TP","116":"DDX","117":"IATP","118":"STP","119":"SRP","120":"UTI","121":"SMP","122":"SM (deprecated)","123":"PTP","124":"ISIS over IPv4","125":"FIRE","126":"CRTP","127":"CRUDP","128":"SSCOPMCE","129":"IPLT","130":"SPS","131":"PIPE","132":"SCTP","133":"FC","134":"RSVP-E2E-IGNORE","135":"Mobility Header","136":"UDPLite","137":"MPLS-in-IP","138":"manet","139":"HIP","140":"Shim6","141":"WESP","142":"ROHC","143":"Ethernet","144-252":null,"253":null,"254":null,"255":"Reserved"},

    protocolNumberToName: function (protocol) {
      // noinspection EqualityComparisonWithCoercionJS
      if (protocol == -1) {
        return "all";
      }

      return this.protocols_numbers[protocol] || protocol;
    }
  }
}]);




angular.module('designer.model.images.aws_20180222_simple', [])
  .service('AWS_20180222SimpleImages', [function() {
    return {
      "list" : [ 
        "resources.aws.ec2.networkinterface",
        "resources.aws.ec2.vpc",
        "resources.aws.ec2.subnet",
        "resources.aws.ec2.instance",
        "resources.aws.ec2.routetable",
        "resources.aws.ec2.internetgateway",
        "resources.aws.ec2.egressonlyinternetgateway",
        "resources.aws.ec2.address",
        "resources.aws.ec2.customergateway",
        "resources.aws.ec2.vpcendpoint",
        "resources.aws.ec2.vpcpeeringconnection",
        "resources.aws.ec2.vpnconnection",
        "resources.aws.ec2.vpngateway",
        "resources.aws.ec2.natgateway",
        "resources.aws.ec2.volume",
        "resources.aws.ec2.transitgateway",
        "resources.aws.ec2.transitgatewayattachment",
        "resources.aws.ec2.transitgatewayroutetable",
        "resources.aws.ec2.transitgatewayvpcattachment",
        "resources.aws.ec2.networkacl",

        "resources.aws.cloudfront.distribution",
        "resources.aws.cloudfront.streamingdistribution",

        "resources.aws.ecs.cluster",
        "resources.aws.ecs.container",
        "resources.aws.ecs.containerinstance",
        "resources.aws.ecs.deployment",
        "resources.aws.ecs.service",
        "resources.aws.ecs.task",
        "resources.aws.ecs.taskdefinition",

        "resources.aws.directconnect.connection",
        "resources.aws.directconnect.directconnectgateway",
        "resources.aws.directconnect.directconnectgatewayassociation",
        "resources.aws.directconnect.lag",
        "resources.aws.directconnect.virtualinterface",

        "resources.aws.directoryservice.directory",
        "resources.aws.directoryservice.domaincontroller",
        "resources.aws.directoryservice.trust",

        "resources.aws.efs.filesystem",
        "resources.aws.efs.mounttarget",

        "resources.aws.elasticbeanstalk.application",
        "resources.aws.elasticbeanstalk.applicationversion",
        "resources.aws.elasticbeanstalk.environment",

        "resources.aws.s3.bucket",

        "resources.aws.sqs.queue",

        "resources.aws.dynamodb.table",

        "resources.aws.route53.hostedzone",

        "resources.aws.redshift.cluster",
        "resources.aws.redshift.clusternode",
        "resources.aws.redshift.clustersubnetgroup",

        "resources.aws.rds.dbsubnetgroup",
        "resources.aws.rds.dbcluster",
        "resources.aws.rds.dbinstance",

        "resources.aws.elasticloadbalancing.loadbalancer",
        "resources.aws.elasticloadbalancingv2.applicationloadbalancer",
        "resources.aws.elasticloadbalancingv2.networkloadbalancer",
        "resources.aws.elasticloadbalancingv2.targetgroup",

        "resources.aws.apigateway.apikey",
        "resources.aws.apigateway.authorizer",
        "resources.aws.apigateway.deployment",
        "resources.aws.apigateway.domain",
        "resources.aws.apigateway.method",
        "resources.aws.apigateway.model",
        "resources.aws.apigateway.resource",
        "resources.aws.apigateway.restapi",
        "resources.aws.apigateway.stage",
        "resources.aws.apigateway.usageplan",
        "resources.aws.apigateway.vpclink",

        "resources.aws.lambda.function",
        "resources.aws.lambda.functionversion",
        "resources.aws.lambda.layerversion",
        "resources.aws.lambda.eventsourcemapping",
        "resources.aws.lambda.function",
        "resources.aws.lambda.layer",
        "resources.aws.lambda.lambdaalias",

        "resources.aws.elasticache.cachesubnetgroup",
        "resources.aws.elasticache.cachenode",
        "resources.aws.elasticache.cachecluster",

        "resources.aws.autoscaling.autoscalinggroup",
        "resources.aws.autoscaling.launchconfiguration",

        "resources.aws.waf.ratebasedrule",
        "resources.aws.waf.rule",
        "resources.aws.waf.webacl",

        "resources.aws.wafv2.webacl",

        "resources.aws.workspaces.directory",
        "resources.aws.workspaces.ipgroup",
        "resources.aws.workspaces.workspace",

        "resources.aws.generic.globalresource",
        "resources.aws.generic.subnetresource",
        "resources.aws.generic.vpcresource",
      ]
    };
  }]);

angular.module('designer.model.images.aws_20181009_arch_light', [])
  .service('AWS_20181009ArchLightImages', [function() {
    return {
      "list" : [ 
        "resources.aws.ec2.networkinterface",
        "resources.aws.ec2.vpc",
        "resources.aws.ec2.subnet",
        "resources.aws.ec2.securitygroup",
        "resources.aws.ec2.instance",
        "resources.aws.ec2.routetable",
        "resources.aws.ec2.internetgateway",
        "resources.aws.ec2.egressonlyinternetgateway",
        "resources.aws.ec2.address",
        "resources.aws.ec2.customergateway",
        "resources.aws.ec2.vpcendpoint",
        "resources.aws.ec2.vpcpeeringconnection",
        "resources.aws.ec2.vpnconnection",
        "resources.aws.ec2.vpngateway",
        "resources.aws.ec2.natgateway",
        "resources.aws.ec2.volume",
        "resources.aws.ec2.transitgateway",
        "resources.aws.ec2.transitgatewayattachment",
        "resources.aws.ec2.transitgatewayroutetable",
        "resources.aws.ec2.transitgatewayvpcattachment",
        "resources.aws.ec2.networkacl",

        "resources.aws.cloudfront.distribution",
        "resources.aws.cloudfront.streamingdistribution",

        "resources.aws.ecs.cluster",
        "resources.aws.ecs.container",
        "resources.aws.ecs.containerinstance",
        "resources.aws.ecs.deployment",
        "resources.aws.ecs.service",
        "resources.aws.ecs.task",
        "resources.aws.ecs.taskdefinition",

        "resources.aws.directconnect.connection",
        "resources.aws.directconnect.directconnectgateway",
        "resources.aws.directconnect.directconnectgatewayassociation",
        "resources.aws.directconnect.lag",
        "resources.aws.directconnect.virtualinterface",

        "resources.aws.directoryservice.directory",
        "resources.aws.directoryservice.domaincontroller",
        "resources.aws.directoryservice.trust",

        "resources.aws.efs.filesystem",
        "resources.aws.efs.mounttarget",

        "resources.aws.elasticbeanstalk.application",
        "resources.aws.elasticbeanstalk.applicationversion",
        "resources.aws.elasticbeanstalk.environment",

        "resources.aws.s3.bucket",

        "resources.aws.sqs.queue",

        "resources.aws.dynamodb.table",

        "resources.aws.route53.hostedzone",

        "resources.aws.redshift.cluster",
        "resources.aws.redshift.clusternode",
        "resources.aws.redshift.clustersubnetgroup",

        "resources.aws.rds.dbsubnetgroup",
        "resources.aws.rds.dbcluster",
        "resources.aws.rds.dbinstance",

        "resources.aws.elasticloadbalancing.loadbalancer",
        "resources.aws.elasticloadbalancingv2.applicationloadbalancer",
        "resources.aws.elasticloadbalancingv2.networkloadbalancer",
        "resources.aws.elasticloadbalancingv2.targetgroup",

        "resources.aws.apigateway.apikey",
        "resources.aws.apigateway.authorizer",
        "resources.aws.apigateway.deployment",
        "resources.aws.apigateway.domain",
        "resources.aws.apigateway.method",
        "resources.aws.apigateway.model",
        "resources.aws.apigateway.resource",
        "resources.aws.apigateway.restapi",
        "resources.aws.apigateway.stage",
        "resources.aws.apigateway.usageplan",
        "resources.aws.apigateway.vpclink",

        "resources.aws.lambda.function",
        "resources.aws.lambda.functionversion",
        "resources.aws.lambda.layerversion",
        "resources.aws.lambda.eventsourcemapping",
        "resources.aws.lambda.function",
        "resources.aws.lambda.layer",
        "resources.aws.lambda.lambdaalias",

        "resources.aws.elasticache.cachesubnetgroup",
        "resources.aws.elasticache.cachenode",
        "resources.aws.elasticache.cachecluster",

        "resources.aws.autoscaling.autoscalinggroup",
        "resources.aws.autoscaling.launchconfiguration",

        "resources.aws.waf.ratebasedrule",
        "resources.aws.waf.rule",
        "resources.aws.waf.webacl",

        "resources.aws.wafv2.webacl",

        "resources.aws.workspaces.directory",
        "resources.aws.workspaces.ipgroup",
        "resources.aws.workspaces.workspace",

        "resources.aws.generic.subnetresource",
        "resources.aws.generic.vpcresource",
        "resources.aws.generic.globalresource"
      ]
    };
  }]);

angular.module('designer.model.images.azure_vendor', [])
  .service('Azure_VendorImages', [function() {
    return {
      "list" : [
        "resources.azure.compute.availabilityset",
        "resources.azure.compute.virtualmachinescaleset",
        "resources.azure.compute.virtualmachine",
        "resources.azure.compute.virtualmachineextension",

        "resources.azure.batch.application",
        "resources.azure.batch.applicationpackage",
        "resources.azure.batch.batchaccount",
        "resources.azure.batch.pool",

        "resources.azure.dns.recordset",
        "resources.azure.dns.zone",

        "resources.azure.eventhub.eventhub",
        "resources.azure.eventhub.namespace",
  
        "resources.azure.mariadb.server",
  
        "resources.azure.mysql.server",

        "resources.azure.network.applicationgateway",
        "resources.azure.network.applicationsecuritygroup",
        "resources.azure.network.expressroutecircuit",
        "resources.azure.network.expressroutecircuit.peering",
        "resources.azure.network.firewall",
        "resources.azure.network.loadbalancer",
        "resources.azure.network.networkinterface",
        "resources.azure.network.localnetworkgateway",
        "resources.azure.network.networksecuritygroup",
        "resources.azure.network.privateendpoint",
        "resources.azure.network.privatelinkservice",
        "resources.azure.network.publicipaddress",
        "resources.azure.network.route",
        "resources.azure.network.routetable",
        "resources.azure.network.securityrule",
        "resources.azure.network.subnet",
        "resources.azure.network.virtualnetwork",
        "resources.azure.network.virtualnetworkpeering",
        "resources.azure.network.virtualnetworkgateway",
        "resources.azure.network.virtualnetworkgatewayconnection",
        "resources.azure.network.webapplicationfirewallpolicy",
        
        "resources.azure.postgresql.server",
       
        "resources.azure.redis.rediscache",
      
        "resources.azure.resources.resource",
        "resources.azure.resources.resourcegroup",

        "resources.azure.servicebus.namespace",
        "resources.azure.servicebus.queue",
        "resources.azure.servicebus.subscription",
        "resources.azure.servicebus.topic",

        "resources.azure.storage.storageaccount",
      
        "resources.azure.generic.globalresource",
        
        "resources.azure.sql.server",
        "resources.azure.sql.database"
      ]
    };
  }]);

angular.module('designer.model.images.gcp_classic', [])
  .service('GCP_ClassicImages', [function() {
    return {
      "list" : [
        "resources.gcp.compute.address",
        "resources.gcp.compute.backendbucket",
        "resources.gcp.compute.backendservice",
        "resources.gcp.compute.disk",
        "resources.gcp.compute.disktype",
        "resources.gcp.compute.externalvpngateway",
        "resources.gcp.compute.firewall",
        "resources.gcp.compute.forwardingrule",
        "resources.gcp.compute.globaladdress",
        "resources.gcp.compute.globalforwardingrule",
        "resources.gcp.compute.globalnetworkendpointgroup",
        "resources.gcp.compute.healthcheck",
        "resources.gcp.compute.httphealthcheck",
        "resources.gcp.compute.httpshealthcheck",
        "resources.gcp.compute.instance",
        "resources.gcp.compute.instancegroup",
        "resources.gcp.compute.instancegroupmanager",
        "resources.gcp.compute.interconnect",
        "resources.gcp.compute.interconnectattachment",
        "resources.gcp.compute.natgateway",
        "resources.gcp.compute.network",
        "resources.gcp.compute.networkendpointgroup",
        "resources.gcp.compute.nodegroup",
        "resources.gcp.compute.packetmirroring",
        "resources.gcp.compute.regionautoscaler",
        "resources.gcp.compute.regionbackendservice",
        "resources.gcp.compute.regiondisk",
        "resources.gcp.compute.regionhealthcheck",
        "resources.gcp.compute.regioninstancegroup",
        "resources.gcp.compute.regioninstancegroupmanager",
        "resources.gcp.compute.regionnetworkendpointgroup",
        "resources.gcp.compute.regionsslcertificate",
        "resources.gcp.compute.regiontargethttpproxy",
        "resources.gcp.compute.regiontargethttpsproxy",
        "resources.gcp.compute.route",
        "resources.gcp.compute.router",
        "resources.gcp.compute.securitypolicy",
        "resources.gcp.compute.sslcertificate",
        "resources.gcp.compute.sslpolicy",
        "resources.gcp.compute.subnetwork",
        "resources.gcp.compute.targethttpproxy",
        "resources.gcp.compute.targethttpsproxy",
        "resources.gcp.compute.targetinstance",
        "resources.gcp.compute.targetpool",
        "resources.gcp.compute.targetsslproxy",
        "resources.gcp.compute.targettcpproxy",
        "resources.gcp.compute.targetvpngateway",
        "resources.gcp.compute.urlmap",
        "resources.gcp.compute.vpngateway",
        "resources.gcp.compute.vpntunnel",
        "resources.gcp.dns.managedzone",
        "resources.gcp.memorystore.instance",
        "resources.gcp.sql.instance",
        "resources.gcp.storage.bucket",
        "resources.gcp.compute.regionurlmap",
        "resources.gcp.generic.globalresource",
      ]
    };
  }]);

angular.module('designer.model.images.ibm_classic', [])
.service('IBM_ClassicImages', [function() {
  return {
    "list" : [
      "resources.ibm.ec2.networkinterface",
      "resources.ibm.ec2.vpc",
      "resources.ibm.ec2.subnet",
      "resources.ibm.ec2.instance",
      "resources.ibm.ec2.routetable",
      "resources.ibm.ec2.internetgateway",
      "resources.ibm.ec2.egressonlyinternetgateway",
      "resources.ibm.ec2.address",
      "resources.ibm.ec2.customergateway",
      "resources.ibm.ec2.vpcendpoint",
      "resources.ibm.ec2.vpcpeeringconnection",
      "resources.ibm.ec2.vpnconnection",
      "resources.ibm.ec2.vpngateway",
      "resources.ibm.ec2.natgateway",
      "resources.ibm.ec2.volume",
      "resources.ibm.ec2.transitgateway",
      "resources.ibm.ec2.transitgatewayattachment",
      "resources.ibm.ec2.transitgatewayroutetable",
      "resources.ibm.ec2.transitgatewayvpcattachment",

      // "resources.ibm.cloudfront.distribution",
      // "resources.ibm.cloudfront.streamingdistribution",

      // "resources.ibm.ecs.cluster",
      // "resources.ibm.ecs.container",
      // "resources.ibm.ecs.containerinstance",
      // "resources.ibm.ecs.deployment",
      // "resources.ibm.ecs.service",
      // "resources.ibm.ecs.task",
      // "resources.ibm.ecs.taskdefinition",

      "resources.ibm.directconnect.connection",
      "resources.ibm.directconnect.directconnectgateway",
      "resources.ibm.directconnect.directconnectgatewayassociation",
      "resources.ibm.directconnect.lag",
      "resources.ibm.directconnect.virtualinterface",

      // "resources.ibm.directoryservice.directory",
      // "resources.ibm.directoryservice.domaincontroller",
      // "resources.ibm.directoryservice.trust",

      // TODO: possibly?
      // "resources.ibm.efs.filesystem",
      // "resources.ibm.efs.mounttarget",

      // "resources.ibm.elasticbeanstalk.application",
      // "resources.ibm.elasticbeanstalk.applicationversion",
      // "resources.ibm.elasticbeanstalk.environment",

      "resources.ibm.s3.bucket",

      // "resources.ibm.sqs.queue",

      // "resources.ibm.dynamodb.table",

      // TODO: ??
      // "resources.ibm.route53.hostedzone",

      // "resources.ibm.redshift.cluster",
      // "resources.ibm.redshift.clusternode",
      // "resources.ibm.redshift.clustersubnetgroup",

      // "resources.ibm.rds.dbsubnetgroup",
      "resources.ibm.rds.dbinstance",

      "resources.ibm.elasticloadbalancing.loadbalancer",
      // "resources.ibm.elasticloadbalancingv2.applicationloadbalancer",
      // "resources.ibm.elasticloadbalancingv2.networkloadbalancer",
      // "resources.ibm.elasticloadbalancingv2.targetgroup",

      // "resources.ibm.apigateway.apikey",
      // "resources.ibm.apigateway.authorizer",
      // "resources.ibm.apigateway.deployment",
      // "resources.ibm.apigateway.domain",
      // "resources.ibm.apigateway.method",
      // "resources.ibm.apigateway.model",
      // "resources.ibm.apigateway.resource",
      // "resources.ibm.apigateway.restapi",
      // "resources.ibm.apigateway.stage",
      // "resources.ibm.apigateway.usageplan",
      // "resources.ibm.apigateway.vpclink",

      // "resources.ibm.lambda.function",
      // "resources.ibm.lambda.functionversion",
      // "resources.ibm.lambda.layerversion",
      // "resources.ibm.lambda.eventsourcemapping",
      // "resources.ibm.lambda.function",
      // "resources.ibm.lambda.layer",
      // "resources.ibm.lambda.lambdaalias",

      // "resources.ibm.elasticache.cachesubnetgroup",
      "resources.ibm.elasticache.cachenode",
      "resources.ibm.elasticache.cachecluster",

      // "resources.ibm.autoscaling.autoscalinggroup",
      // "resources.ibm.autoscaling.launchconfiguration",

      // TODO: ???
      "resources.ibm.waf.ratebasedrule",
      "resources.ibm.waf.rule",
      "resources.ibm.waf.webacl",

      // "resources.ibm.workspaces.directory",
      // "resources.ibm.workspaces.ipgroup",
      // "resources.ibm.workspaces.workspace"
    ]
  };
}]);

angular.module('designer.model.images.kubernetes_classic', [])
.service('Kubernetes_ClassicImages', [function() {
  return {
    "list" : [
      "resources.kubernetes.cluster.cluster",
      "resources.kubernetes.cluster.daemonset",
      "resources.kubernetes.cluster.deployment",
      "resources.kubernetes.cluster.namespace",
      "resources.kubernetes.cluster.node",
      "resources.kubernetes.cluster.persistentvolume",
      "resources.kubernetes.cluster.persistentvolumeclaim",
      "resources.kubernetes.cluster.pod",
      "resources.kubernetes.cluster.replicaset",
      "resources.kubernetes.cluster.service",
      "resources.kubernetes.cluster.statefulset"
    ]
  };
}]);

angular.module("report.graphs.bar-chart", [])
.directive("barChart", [function() {
  return {
    templateUrl: "/designer/report/graphs/chart.html",
    scope:{
      data:"="
    },   
    replace: true,
    link: function (scope, element, attrs, ctrl) {
      var el = document.getElementById('chart-area');
      var data = {
        categories: scope.data.categories,
        series: scope.data.series
      };
      var options = {
        chart: {
          width: 900,
          height: 650,
          title: scope.data.title,
          'format': '1,000'
        },
        yAxis: {
          title: 'Group'
        },
        xAxis: {
          title: 'Total',
          max: scope.data.max+1
        },
        series: {
          showLegend: true,
          showLabel: true,
          labelAlign: 'center'
        },
        legend: {
          align: 'bottom',
          visible: true
        },
        theme: {
          colors: [
            '#4bc0c0', '#36a2eb', '#f27173', '#ffcd56', '#289399',
            '#60ca87', '#617178', '#8a9a9a', '#516f7d', '#dddddd'
          ]
        }
      };
      if(scope.data.stack) options.series.stack = 'normal';

      toastui.Chart.barChart({el, data, options});
    }
  }
}]);

angular.module("report.graphs.column-chart", [])
.directive("columnChart", [function() {
  return {
    templateUrl: "/designer/report/graphs/chart.html",
    scope:{
      data:"="
    },   
    replace: true,
    link: function (scope, element, attrs, ctrl) {
      var el = document.getElementById('chart-area');
      var data = {
        categories: scope.data.categories,
        series: scope.data.series
      };
      var options = {
        chart: {
          width: 900,
          height: 650,
          title: scope.data.title,
          format: '1,000'
        },
        yAxis: {
          title: 'Total',
          min: 0,
          max: scope.data.max
        },
        xAxis: {
          title: 'Group'
        },
        series: {
          showLegend: true,
          showLabel: true,
          labelAlign: 'center'
        },
        legend: {
          align: 'bottom',
          visible: true
        },
        theme: {
          colors: [
            '#4bc0c0', '#36a2eb', '#f27173', '#ffcd56', '#289399',
            '#60ca87', '#617178', '#8a9a9a', '#516f7d', '#dddddd'
          ]
        }
      };
      if(scope.data.stack) options.series["stack"] = 'normal';

      toastui.Chart.columnChart({el, data, options});
    }
  }
}]);

angular.module("report.graphs.combo-chart", [])
.directive("comboChart", [function() {
  return {
    templateUrl: "/designer/report/graphs/chart.html",
    scope: {
      data:"="
    },   
    replace: true,
    link: function (scope, element, attrs, ctrl) {

      scope.rgbToHex = function(r) {
        return "#" + ((1 << 24) + (r[0] << 16) + (r[1] << 8) + r[2]).toString(16).slice(1);
      };

      var severity_list_rgb = {
        "Critical": [196,63,42],
        "High": [255,90,70],
        "Medium": [251,151,2],
        "Low": [55, 161, 235],
        "Info": [51,202,178],
        "Verbose": [0,169,255]
      };
      var inside_colors = [];
      var outside_colors = [];

      _.each(scope.data.severity_total_resources, function(total, severity) {
        var rgb = severity_list_rgb[severity];
        inside_colors.push(scope.rgbToHex(rgb));
        for(var i = 0; i < total; i++){
          rgb = _.map(rgb, function(j) { var r = j+(10*1); return r<256 ? r : 255});
          outside_colors.push(scope.rgbToHex(rgb));
        }
      });

      var el = document.getElementById('chart-area');
      var data = {
        categories: scope.data.categories,
        seriesAlias: {
          pie1: 'pie',
          pie2: 'pie'
        },

        series: scope.data.series
      };
      var options = {
        chart: {
          width: 700,
          height: 700,
          title: scope.data.title
        },
        series: {
          dataLabels: {
            visible: true,
            pieSeriesName: {
              visible: true,
              anchor: 'center'
            }
          },
          pie1: {
            radiusRange: { inner: '57%' },
          },
          pie2: {
            radiusRange: { inner: '70%', outer: '100%' },
          }
        },
        legend: {
          visible: false
        },
        theme: {
          series: {
            pie1: {
              colors: inside_colors
            },
            pie2: {
              colors: outside_colors
            }
          }
        }
      };

      toastui.Chart.nestedPieChart({el, data, options});
    }
  }
}]);

angular.module("report.graphs.report-map", [])
.directive("reportMap", [function() {
  return {
    templateUrl: "/designer/report/graphs/report-map.html",
    scope:{
      data:"="
    },   
    replace: true,
    link: function (scope, element, attrs, ctrl) {
      scope.path = scope.$parent.Reporter.path || "assets";

      scope.region_location = {
        "eu-north-1": {name:"Stockholm", m: {x:47, y:438}, s: {x:19, y:240}},
        "ap-south-1": {name:"Mumbai", m: {x:175, y:606}, s: {x:92, y:335}},
        "eu-west-3": {name:"Paris", m: {x:80, y:406}, s: {x:49, y:232}},
        "eu-west-2": {name:"London", m: {x:68, y:394}, s: {x:31, y:217}},
        "eu-west-1": {name:"Ireland", m: {x:66, y:378}, s: {x:28, y:207}},
        "ap-northeast-2": {name:"Seoul", m: {x:112, y:744}, s: {x:58, y:412}},
        "ap-northeast-1": {name:"Tokyo", m: {x:120, y:781}, s: {x:60, y:430}},
        "sa-east-1": {name:"São Paulo", m: {x:305, y:266}, s: {x:162, y:146}},
        "ca-central-1": {name:"Canada Central", m: {x:105, y:138}, s: {x:48, y:64}},
        "ap-southeast-1": {name:"Singapore", m: {x:224, y:695}, s: {x:116, y:384}},
        "ap-southeast-2": {name:"Sydney", m: {x:341, y:817}, s: {x:178, y:457}},
        "eu-central-1": {name:"Frankfurt", m: {x:93, y:451}, s: {x:43, y:251}},
        "us-east-1": {name:"N. Virginia", m: {x:117, y:181}, s: {x:61, y:95}},
        "us-east-2": {name:"Ohio", m: {x:106, y:167}, s: {x:51, y:83}},
        "us-west-1": {name:"N. California", m: {x:124, y:69}, s: {x:64, y:40}},
        "us-west-2": {name:"Oregon", m: {x:98, y:64}, s: {x:55, y:32}},
        "eu-south-1": {name:"Milan", m: {x:93, y:427}, s: {x:38, y:227}},
        "af-south-1": {name:"Cape Town", m:{x:341, y:445}, s: {x:181, y:245}}
      };

      var used_regions = _.keys(_.pickBy(scope.data, function(v,r) {return v=="Y"}));
      scope.regions = _.pickBy(scope.region_location, function(v,r) {return used_regions.indexOf(r) !== -1 });
    }
  }
}]);

angular.module('designer.workspace.layout.container', [
  "designer.state",
  "designer.workspace.layout.container.ecs.cluster",
  "designer.workspace.layout.container.kubernetes.cluster",
  "designer.workspace.layout.container.position.grid",
  "designer.workspace.layout.container.position.hex",
  "designer.workspace.layout.container.cell",
  "designer.workspace.layout.container.hexgrid"
])
.directive('containerLayout',
  ["DesignerState", "$timeout", "ContainerLayoutECSCluster", "ContainerLayoutKubernetesCluster", "ContainerLayoutGridPosition", "ContainerLayoutHexPosition",
    function(DesignerState, $timeout, ContainerLayoutECSCluster, ContainerLayoutKubernetesCluster, ContainerLayoutGridPosition, ContainerLayoutHexPosition) {
      return {
        templateUrl: '/designer/workspace/layout/layout.container.html',
        controllerAs: "ContainerLayout",
        bindToController: true,
        scope: {
          environment: "="
        },
        controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
          this.positions = [];

          this.loadContainers = function() {
            this.positions = [];

            if (this.environment.current_view.type === "Views::Container") {
              let ecs_clusters = _.filter(this.environment.facet.resources, function(r) { return r.type === "Resources::AWS::ECS::Cluster" });
              ecs_clusters = _.map(ecs_clusters, function(r) { return ContainerLayoutECSCluster.load(r, this.environment).getData() }.bind(this));

              let kubernetes_clusters = _.filter(this.environment.facet.resources, function(r) { return r.type === "Resources::Kubernetes::Cluster::Cluster" });
              kubernetes_clusters = _.map(kubernetes_clusters, function(r) { return ContainerLayoutKubernetesCluster.load(r, this.environment).getData() }.bind(this));

              return ecs_clusters.concat(kubernetes_clusters);
            }
          }

          this.layout = function() {
            if (_.includes(['Views::Container'], this.environment.current_view.type)) {
              let ecs_clusters = _.filter(this.environment.facet.resources, function(r) { return r.type === "Resources::AWS::ECS::Cluster" });
              ecs_clusters = _.map(ecs_clusters, function(r) { return ContainerLayoutECSCluster.load(r, this.environment).getData() }.bind(this));

              let kubernetes_clusters = _.filter(this.environment.facet.resources, function(r) { return r.type === "Resources::Kubernetes::Cluster::Cluster" });
              kubernetes_clusters = _.map(kubernetes_clusters, function(r) { return ContainerLayoutKubernetesCluster.load(r, this.environment).getData() }.bind(this));

              let containers = ecs_clusters.concat(kubernetes_clusters);

              _.each(containers, function(container) {
                this.layoutContainer(container);
              }.bind(this));

              console.log("Containers!", containers);

              $scope.view = {};
              $scope.view.containers = containers;
            }
          };

          this.layoutContainer = function(container) {
            _.each(container.cells, function(cell) {
              if(cell["tasks"]) {
                this.layoutHex(cell);
              }
              else {
                this.layoutContainer(cell)
              }
            }.bind(this));

            ContainerLayoutGridPosition.position(container, { min_width: 346.4 });
          }

          this.layoutHex = function(container) {
            var hex_cell = { id: null, type: "hex", cells: container.tasks };
            ContainerLayoutHexPosition.position(hex_cell, container.max_tasks, { min_width: 346.4 });

            // Now layout the whole container as a one column grid
            container.cells = [];
            container.cells = container.cells.concat(_.map(container.load_balancers, function(lb) { return { id: lb.id, fit_to_width: true, x: 0, y: 0, w: 0, h: 50 } }));
            container.cells.push(hex_cell);
            container.cells = container.cells.concat(_.map(container.volumes, function(v) { return { id: v.id, fit_to_width: true, x: 0, y: 0, w: 0, h: 50 } }));

            ContainerLayoutGridPosition.position(container, { max_columns: 1 })
          }

          this.savePositions = function(container) {
            this.addPosition(container)

            if(container["cells"]) {
              _.each(container.cells, function(c) { this.savePositions(c) }.bind(this));
            }
          };

          this.addPosition = function(container) {
            this.positions.push({
              id: container.id,
              x: container.x,
              y: container.y,
              w: container.w,
              h: container.h,
            })
          }
        }],
        link: function(scope, element, attrs, ctrl) {
          // var containers = ctrl.loadContainers();
          //
          // $timeout(function() {
          //   // TODO: new logic
          //   ctrl.layout();
          //
          //   // Position everything relative to the lowest cell
          //   _.each(containers, function(container) {
          //     ctrl.layoutContainer(container);
          //   });
          //
          //   ContainerLayoutGridPosition.position({ cells: containers }, { max_rows: 1, container_spacing: 75 });
          //
          //   // Now grab all the positions!
          //   _.each(containers, function(c) { ctrl.savePositions(c) });
          //
          //   scope.$emit("view:positioned", ctrl.environment.current_view.type, ctrl.positions);
          // });

          // NEW LAYOUT
          ctrl.layout();

          $timeout(function() {
            var coordinates = [];
            var services = document.querySelectorAll(".positionable");
            for (var i = 0; i < services.length; ++i) {
              var service = services[i];
              var bounds  = service.getBoundingClientRect();
              coordinates.push({
                id: service.id,
                x: bounds.left,
                y: bounds.top,
                w: bounds.width,
                h: bounds.height
              });
            }

            scope.$emit("view:positioned", ctrl.environment.current_view.type, coordinates);
          });
        }
      }
    }]);

angular.module('designer.workspace.layout.infrastructure', [
  "designer.workspace.layout.infrastructure.aws.global",
  "designer.workspace.layout.infrastructure.azure.resource_group",
  "designer.workspace.layout.infrastructure.gcp.network",
  "designer.workspace.layout.infrastructure.ibm.global",
  'designer.workspace.layout.infrastructure.container',
  'designer.workspace.layout.infrastructure.parent',
  "designer.state"
])
.directive('infrastructureLayout',
  ["DesignerState", "InfrastructureLayoutAWSGlobal", "InfrastructureLayoutAzureResourceGroup", "InfrastructureLayoutGCPNetwork", "InfrastructureLayoutIBMGlobal", "$timeout",
    function(DesignerState, InfrastructureLayoutAWSGlobal, InfrastructureLayoutAzureResourceGroup, InfrastructureLayoutGCPNetwork, InfrastructureLayoutIBMGlobal, $timeout) {
    return {
      templateUrl: '/designer/workspace/layout/layout.infrastructure.html',
      controllerAs: "InfrastructureLayout",
      bindToController: true,
      scope: {
        environment: "="
      },
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        this.layout = function() {
          if (_.includes(['Views::Infrastructure', 'Views::Infrastructure::Extended'], this.environment.current_view.type)) {
            // AWS
            var aws_global = InfrastructureLayoutAWSGlobal.load(this.environment).getData();

            // Azure
            var resource_groups = _.filter(this.environment.facet.resources, function(r) { return r.type === "Resources::Azure::Resources::ResourceGroup" });
            resource_groups = _.map(resource_groups, function(r) { return InfrastructureLayoutAzureResourceGroup.load(r, this.environment).getData() }.bind(this));

            // GCP
            var networks = _.filter(this.environment.facet.resources, function(r) { return r.type === "Resources::GCP::Compute::Network" });
            var network_containers = _.map(networks, function(r) { return InfrastructureLayoutGCPNetwork.load(r, this.environment).getData() }.bind(this));
            var gcp_global = this.getParent(networks, network_containers);

            // IBM
            var ibm_global = InfrastructureLayoutIBMGlobal.load(this.environment).getData();

            var containers = [aws_global, ibm_global, gcp_global].concat(resource_groups)

            $scope.view = {};
            $scope.view.containers = containers;
            $scope.view.dimensions = this.dimensions(containers);
            $scope.view.styles = this.styles($scope.view.dimensions);
          }
        }

        this.getParent = function(networks, network_containers) {
          var bottom = _.uniq(_.flatten(networks.map((c) => c.getGenericResources())));
          return {
            id: null,
            parent: true,
            center: network_containers,
            bottom: bottom
          }
        }

        this.styles = function(dimensions) {
          var values = {};
          var layout = DesignerState.get("layout")[this.environment.current_view.type];

          // Handle extended infra differently
          if(this.environment.current_view.type === 'Views::Infrastructure') {
            values.service = {
              margin: [16, layout.resource_width, layout.resource_height, layout.resource_width].join("px ") + "px"
            }

            values.load_balancer = values.service;
            values.subnet_service = values.service;

            values.left_column = function(container) {
              return { 'min-width': (Math.ceil((container.left.length || 0 )/dimensions[container.id].max_height) * (layout.resource_width*2+100)) + 'px' };
            }

            values.right_column = function(container) {
              return { 'min-width': (Math.ceil((container.right.length || 0 )/dimensions[container.id].max_height) * (layout.resource_width*2+100)) + 'px' };
            }

            values.subnet = function(container_id) {
              return { width: ((dimensions[container_id].max_size + layout.subnet_width) * (layout.resource_width*2+64)) + "px" }
            }
          }
          else {
            values.service = {
              margin: [16, layout.resource_width, layout.resource_height, layout.resource_width].join("px ") + "px"
            }

            values.load_balancer = {
              margin: [16, 77 + layout.resource_width, layout.resource_height, 77 + layout.resource_width].join("px ") + "px"
            }

            values.left_column = function(container) {
              return { 'min-width': (Math.ceil((container.left.length || 0 )/dimensions[container.id].max_height) * (layout.resource_width*2+100)) + 'px' };
            }

            values.right_column = function(container) {
              return { 'min-width': (Math.ceil((container.right.length || 0 )/dimensions[container.id].max_height) * (layout.resource_width*2+100)) + 'px' };
            }

            values.subnet_service = {
              margin: [16, 112 + layout.resource_width, layout.resource_height, 16].join("px ") + "px"
            }

            values.subnet = function(container_id) {
              return { width: ((dimensions[container_id].max_size + layout.subnet_width + 2) * (layout.resource_width+112+16)) + "px" }
            }
          }

          return values;
        };

        this.dimensions = function(containers) {
          var dimensions = {};

          var subnet_size = function(resources) {
            var length = _.min([_.ceil((resources.length/6)+2), 10]);

            return length < 4 ? 4 : length;
          };

          var subnet_height = function(resources) {
            return _.ceil(resources.length / subnet_size(resources)) || 1;
          };

          _.each(containers, function(container) {
            if(container["parent"]) {
              dimensions = Object.assign({}, dimensions, this.dimensions(container["center"]))
            }
            else {
              var max_size = 0;
              var total_height = 0;
              _.each(container["center"], function(row) {
                if(row["type"] === "subnet") {
                  _.each(row["columns"], function(subnet) {
                    if (!subnet) return;

                    if (subnet["zone_columns"]) {
                      if (!dimensions[subnet["id"]])
                        dimensions[subnet["id"]] = {};

                      _.each(subnet["zone_columns"], function (zone_data) {
                        var size = subnet_size(zone_data["resources"]);
                        var height = subnet_height(zone_data["resources"]);

                        if (size > max_size)
                          max_size = size;

                        total_height += height;

                        dimensions[subnet["id"]] = { size: size, height: height };
                      });
                    } else {
                      var size = subnet_size(subnet["resources"]);
                      var height = subnet_height(subnet["resources"]);

                      if (size > max_size)
                        max_size = size;

                      total_height += height;

                      dimensions[subnet["id"]] = { size: size, height: height };
                    }
                  });
                }
                else {
                  // Load balancer row, add some height
                  total_height += 1;
                }
              });

              dimensions[container["id"]] = {
                max_size: _.max([max_size, 1]),
                max_height: _.max([total_height, 1]),
                colspan: _.max(_.map(container["center"], function(r) { return (r["columns"] || r["zone_columns"] || []).length } ))
              }
            }
          }.bind(this));

          return dimensions;
        }
      }],
      link: function(scope, element, attrs, ctrl) {
        ctrl.layout();

        $timeout(function() {
          var coordinates = [];
          var services = document.querySelectorAll(".positionable");
          for (var i = 0; i < services.length; ++i) {
            var service = services[i];
            var bounds  = service.getBoundingClientRect();
            coordinates.push({
              id: service.id,
              x: bounds.left,
              y: bounds.top,
              w: bounds.width,
              h: bounds.height
            });
          }

          scope.$emit("view:positioned", ctrl.environment.current_view.type, coordinates);
        });
      }
    }
  }]);

angular.module('designer.workspace.layout', [
  'designer.workspace.layout.container',
  'designer.workspace.layout.infrastructure',
  'designer.workspace.layout.security',
])
.directive('designerLayout',
  [function() {
    return {
      templateUrl: '/designer/workspace/layout/layout.html',
      controllerAs: "DesignerLayout",
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        this.environment = $scope.Designer.environment;
      }],
      link: function(scope, element, attrs, ctrl) {
        scope.$on("view:positioned", function(e, view_id, positions) {
          ctrl.environment = null;
        });

        scope.$on("environment:reloaded", function() {
          ctrl.environment = scope.Designer.environment;
        });

        scope.$on("view:selected", function() {
          if(!scope.Designer.environment.current_view.positioned)
            ctrl.environment = scope.Designer.environment;
        });

        scope.$on("view:reposition", function() {
          ctrl.environment = scope.Designer.environment;
        });
      }
    }
  }]);

angular
  .module("designer.workspace.layout.security", [
    "designer.configuration",
    "designer.workspace.layout.security.azure",
    "designer.workspace.layout.security.aws",
    "designer.configuration",
    "designer.state",
  ])
  .directive("securityLayout", ["$timeout", "SecurityLayoutAzure", "SecurityLayoutAWS", "DesignerConfig", "DesignerState", "$rootScope",
    function ($timeout, SecurityLayoutAzure, SecurityLayoutAWS, DesignerConfig, DesignerState, $rootScope) {
      return {
        controllerAs: "SecurityLayoutAzure",
        bindToController: true,
        scope: {
          environment: "=",
        },
        controller: [
          "$scope",
          "$element",
          "$attrs",
          function ($scope) {
            this.layout = function () {
              if (this.environment.current_view.type === "Views::Security") {
                var views = [];

                var Strategies = [SecurityLayoutAWS, SecurityLayoutAzure];

                Strategies.forEach((Strategy) => {
                  var { rows, arrows } = Strategy.load(
                    this.environment
                  ).getData();

                  if (!_.isEmpty(rows) && !_.isEmpty(arrows)) {
                    views.push({ rows, arrows });
                  }
                });

                $scope.views = views;
              }
            };
          },
        ],
        link: function (scope, element, attrs, ctrl) {
          // Get the model
          ctrl.layout();
          ctrl.hidden = false;
          ctrl.position = function () {
            let { views } = scope;
            let all_rows = [];
            let all_arrows = [];
            let all_nsg_blocks = [];
            let view_height = 0;
            let view_padding = 200;

            views.forEach((view, view_index) => {
              let { rows, arrows } = view;

              var hideDefaultArrows = DesignerState.get("hideDefaultArrows");
              ctrl.hidden = hideDefaultArrows;
              if (hideDefaultArrows) {
                arrows = arrows.filter((arrow) => {
                  const { dst, ports } = arrow;

                  const internet = dst === "internet";
                  return _.every(ports, (port) => {
                    const { protocol, from_port, to_port, direction } = port;
                    const egress = direction === "egress";
                    const r = new Set([protocol, from_port, to_port]);
                    const defaultRule = r.size == 1 && r.has("ALL") && egress;
                    return !(internet && defaultRule);
                  });
                });
              }

              // Security layout configs
              const offset = 500;
              const arrow_width = 150;
              const flat_arrow_width = 200;
              const row_height = 125;

              // Calculate how many flat and normal arrows we have
              const f_arrows = arrows.filter((a) => a.size === 0).length;
              const n_arrows = arrows.filter((a) => a.size !== 0).length;

              // Offset by some and we have flat arrows and normal arrows
              // Combine all of them and calculate final length
              let row_width = offset;
              row_width += flat_arrow_width * f_arrows + arrow_width * n_arrows;

              // Push NSG Blocks
              var padding_y = 100;
              var padding_x = 70;

              var flat_arrow_padding = 100;
              var normal_arrow_padding = 150;
              var padding_between_nsgs = 120;

              var nsg_blocks = [];
              var nsg_map = _.groupBy(arrows, "nsg_id");

              // Start with offset
              let x = offset;
              // Calculate positions and push them to NSG blocks
              _.each(nsg_map, function (group, nsg_id) {
                // Calculate Arrow positions
                group.forEach((arrow, i) => {
                  const position = {
                    x,
                    y: arrow["lower_pos"] * row_height + view_height,
                    w: arrow["size"] === 0 ? flat_arrow_width : arrow_width,
                    h: row_height * (arrow["size"] + 1),
                  };

                  // Assign to existing arrow object
                  Object.assign(arrow, position);

                  // Adjust X
                  if (arrow["size"] === 0) {
                    x += flat_arrow_width;
                  } else {
                    x += arrow_width;
                  }
                });

                // Add some space after NSG
                x += padding_between_nsgs;
                row_width += padding_between_nsgs;

                var sorted = _.sortBy(group, (ar) => ar.x);
                var left_arrow = sorted[0];
                var right_arrow = sorted[sorted.length - 1];

                var padding_right = flat_arrow_padding + 2 * padding_x;
                if (right_arrow.size === 0) {
                  padding_right = normal_arrow_padding + 2 * padding_x;
                }

                // If AWS, nsg_map will have a key "undefined"
                // Hacky but it works and does not requires lot of changes
                if (nsg_id !== "undefined") {
                  nsg_blocks.push({
                    id: nsg_id,
                    x: left_arrow.x - padding_x,
                    y: -padding_y + view_height,
                    w: right_arrow.x - left_arrow.x + padding_right,
                    h: view.rows.length * row_height + 2 * padding_y,
                  });
                }
              });

              // Add co-ordinates
              rows.forEach((row, index) => {
                const position = {
                  id: row["id"],
                  name: row["id"],
                  x: 0,
                  y: row_height * index + view_height,
                  w: row_width,
                  h: row_height,
                };

                // Assign new properties
                Object.assign(row, position);
              });

              rows = rows.filter((row) => row.type !== "blank")

              // Push to final list
              all_rows = all_rows.concat(rows);
              all_arrows = all_arrows.concat(arrows);
              all_nsg_blocks = all_nsg_blocks.concat(nsg_blocks);

              // Adjust view height
              view_height += row_height * rows.length + view_padding;
            });

            // Group everything by network_id and add name label positions
            let network_group_labels = [];
            _.forEach(_.groupBy(all_rows, "network_id"), function(rows, group_id) {
              let label = { text: rows[0].network_name, x: 60, y: null, w: rows[0].w, h: rows[0].h }
              _.each(rows, function(row) {
                if(label.y === null || row.y < label.y) label.y = row.y;
              });

              // Pad it out
              label.y -= (label.h - 80);

              network_group_labels.push(label);
            });

            // Finally all the layout information to the view
            const positions = {
              rows: all_rows,
              arrows: all_arrows,
              nsg_blocks: all_nsg_blocks,
              labels: network_group_labels
            };
            const { environment } = ctrl;
            const { current_view } = environment;

            scope.$emit("view:positioned", current_view.type, positions);
            return positions;
          };

          $timeout(function () {
            ctrl.position();
          });


          ctrl.count += 1
          // Listen to the view options hide all toggle
          $rootScope.$on("view:hide_all", function (event, hide) {
            // Basically check if we need to trigger change
            if ((hide && !ctrl.hidden) || (!hide && ctrl.hidden)) {
            // Reposition
            const positions = ctrl.position();

            // Reset resources
            const { current_view } = ctrl.environment;
            current_view.model.resourceCells = [];

            // and load again
            current_view.load_with_positions(ctrl.environment, positions);
            $rootScope.$broadcast("view:modified", current_view);
            }
          });
        },
      };
    },
  ]);

angular.module('designer.workspace.exporter', [
  "designer.app-scope",
  "designer.configuration"
])
.directive('exporter', ["$window", "$appScope", "DesignerConfig", function($window, $appScope, DesignerConfig) {
    return {
      templateUrl: '/designer/workspace/controls/exporter.html',
      replace: true,
      link: {
        post: function(scope, element, attrs, ctrl) {
          scope.show_export = false;
          scope.formats = DesignerConfig.get("exportFormats");

          scope.toggleExports = function() {
            scope.show_export = !scope.show_export;

            scope.show_export ?
              angular.element($window).on("click", scope.handleWindowClick) :
              angular.element($window).off("click", scope.handleWindowClick);
          };

          scope.upgradeAccount = function() {
            scope.$emit("trial:upgrade");
          };

          scope.handleWindowClick = function(event) {
            var target = $(event.target);

            if (!target.parents('#export-options').length) {
              $appScope.safeApply(function() {
                scope.toggleExports();
              }, scope);
            }
          }
        }
      }
    }
  }]);

angular.module('designer.workspace.revision.selector', [])
.directive('revisionSelector', ["$rootScope", function($rootScope) {
    return {
      templateUrl: '/designer/workspace/controls/revision.selector.html',
      replace: true,
      link: {
        post: function(scope, element, attrs, ctrl) {
          scope.revisions = [];
          scope.loading = null;
          scope.loading_next = false;
          scope.page_token = null;

          scope.selectRevision = function(revision) {
            if(revision.id === scope.Designer.environment.current_revision.id) return;
            
            scope.Designer.environment.setCurrentRevision(revision.id);
            scope.loading = revision;

            $rootScope.$broadcast("revision:selected", revision.id);
          };

          scope.showNextRevisions = function() {
            scope.loading_next = true;
            $rootScope.$broadcast("revisions:show-all", { token: scope.page_token });
          };

          scope.$on("environment:reloaded",  function() {
            if(scope.loading) {
              scope.loading = null;
            }
            else {
              scope.revisions = [];
              scope.page_token = null;
              scope.showNextRevisions();
            }
          });

          scope.$on("revisions:loaded",  function(event, revisions) {
            scope.loading_next = false;
            scope.page_token = revisions["next_page_token"];
            scope.revisions = scope.revisions.concat(revisions.results);
          });

          // On load grab the revisions
          scope.showNextRevisions();
        }
      }
    }
  }]);

angular.module('designer.workspace.sharer', [
  "designer.app-scope",
  "designer.configuration"
])
.directive('sharer', ["$window", "$appScope", "DesignerConfig", "$timeout", function($window, $appScope, DesignerConfig, $timeout) {
  return {
    templateUrl: '/designer/workspace/controls/sharer.html',
    replace: true,
    link: {
      post: function(scope, element, attrs, ctrl) {
        scope.show_share = false;
        scope.allow_embed = DesignerConfig.get("allowEmbed");
        scope.embeddable_host = DesignerConfig.get("embeddableHost");
        scope.embed_code = null;
        scope.loading_embed = false;
        scope.embed_error = false;
        scope.copy_state = { result: null };

        scope.toggleShareOptions = function() {
          scope.show_share = !scope.show_share;

          scope.show_share ?
            angular.element($window).on("click", scope.handleWindowClick) :
            angular.element($window).off("click", scope.handleWindowClick);
        };

        scope.loadEmbedCode = function() {
          scope.$emit("embed:load");
          scope.loading_embed = true;
          scope.embed_error = false;
        };

        scope.copyEmbedCode = function() {
          var content = angular.element("#embed-code-display").text().trim();
          navigator.clipboard.writeText(content).then(function() {
            scope.setCopyResult(true);
          }, function() {
            scope.setCopyResult(false);
          });
        };

        scope.setCopyResult = function(r) {
          $appScope.safeApply(function() {
            scope.copy_state.result = r;
          }, scope);

          $timeout(function() {
            scope.copy_state.result = null;
          }, 2000);
        }

        scope.upgradeAccount = function() {
          scope.$emit("trial:upgrade");
        };

        scope.$on("embed:loaded", function(e, code) {
          scope.embed_code = code;
          scope.loading_embed = false;
        });

        scope.$on("embed:error", function() {
          scope.loading_embed = false;
          scope.embed_error = true;
        });

        scope.$on("revision:selected", function() {
          scope.embed_code = null;
          scope.loading_embed = false;
          scope.embed_error = false;
        });

        scope.handleWindowClick = function(event) {
          var target = $(event.target);

          if (!target.parents('#share-options').length) {
            $appScope.safeApply(function() {
              scope.toggleShareOptions();
            }, scope);
          }
        }
      }
    }
  }
}]);

angular.module('designer.workspace.sidebar', [
  "designer.attributes",
  'designer.workspace.views.selector',
  'designer.workspace.views.picker',
  'designer.workspace.revision.selector',
  'designer.configuration'
])
.directive('sidebar', ["DesignerConfig", function(DesignerConfig) {
    return {
      templateUrl: '/designer/workspace/controls/sidebar.html',
      replace: true,
      link: {
        post: function(scope, element, attrs, ctrl) {
          scope.selected_tab = "attributes";
          scope.show_revisions = DesignerConfig.get("showRevisions");
        }
      }
    }
  }]);

angular.module('designer.workspace.view.options', [
  "designer.app-scope",
  "designer.model.resource.images",
  "designer.configuration",
  "designer.state"
])
.directive('viewOptions', ["$window", "$appScope", "$rootScope", "ResourceImages", "DesignerConfig", "DesignerState", "$sce",
  function($window, $appScope, $rootScope, ResourceImages, DesignerConfig, DesignerState, $sce) {
    return {
      templateUrl: '/designer/workspace/controls/view.options.html',
      replace: true,
      link: {
        post: function(scope, element, attrs, ctrl) {
          scope.show_options      = false;
          scope.icon_sets         = ResourceImages.getIconList(scope.Designer.environment);
          scope.show_icons        = DesignerConfig.get("showIcons") && _.keys(scope.icon_sets).length > 1;
          scope.selected_icon_set = DesignerState.get("selectedIconSet");
          scope.show_labels       = DesignerState.get("displayLabels");
          scope.show_connections  = DesignerState.get("displayConnections");
          scope.display3DView     = DesignerState.get("display3DView");
          scope.hide_all          = DesignerState.get("hideDefaultArrows");
          scope.hide_namespaces   = DesignerState.get("hideNamespaces");

          scope.selectIconSet = function(icon_set) {
            if (DesignerState.get("selectedIconSet") === icon_set) return;

            scope.selected_icon_set = icon_set;
            DesignerState.set("selectedIconSet", icon_set);

            $rootScope.$broadcast("icon:switch");
          };

          scope.defaultIconPath = function(icon_set, values) {
            return $sce.trustAsResourceUrl("#" + values['provider'] + "-" + icon_set + "-" + values['main_icon']);
          };

          scope.$watch("show_labels", function() {
            DesignerState.set("displayLabels", scope.show_labels);

            $rootScope.$broadcast("toggle:labels");
          });

          scope.$watch("show_connections", function() {
            DesignerState.set("displayConnections", scope.show_connections);

            $rootScope.$broadcast("toggle:connections");
          });

          scope.$watch("hide_namespaces", function() {
            DesignerState.set("hideNamespaces", scope.hide_namespaces);

            $rootScope.$broadcast("view:reposition");
          });

          scope.toggleArrowsAll = function () {
            scope.hide_all = !scope.hide_all;
            // Get the current option and flip it
            var value = DesignerState.get("hideDefaultArrows");
            DesignerState.set("hideDefaultArrows", !value);
            $rootScope.$broadcast("view:hide_all", !value);
          }

          scope.toggleOptions = function() {
            scope.show_options = !scope.show_options;

            scope.show_options ?
              angular.element($window).on("click", scope.handleWindowClick) :
              angular.element($window).off("click", scope.handleWindowClick);
          };

          scope.changeLayout = function(key, val, min, max) {
            var positions = DesignerState.get("layout")[scope.Designer.environment.current_view.type];
            var new_val = positions[key] + val;

            if(new_val >= min && new_val <= max) {
              positions[key] += val;
              $rootScope.$broadcast("view:reposition");
            }
          };

          scope.resetLayout = function() {
            DesignerState.reset("layout");

            $rootScope.$broadcast("view:reposition");
          };

          scope.$on("viewChanged", function () {
            scope.display3DView = DesignerState.get("display3DView");
          });

          scope.$on("reset:layout", function () {
            scope.resetLayout();
          });

          scope.handleWindowClick = function(event) {
            var target = $(event.target);

            if (!target.parents('#view-options').length) {
              $appScope.safeApply(function() {
                scope.toggleOptions();
              }, scope);
            }
          };
        }
      }
    }
  }]);

angular.module('designer.workspace.views.picker', [
    "designer.configuration",
    "designer.state"
  ])
  .directive('viewsPicker', ["$rootScope", "$timeout", "DesignerConfig", "DesignerState", function($rootScope, $timeout, DesignerConfig, DesignerState) {
      return {
        templateUrl: '/designer/workspace/controls/views.picker.html',
        replace: true,
        link: {
          post: function(scope, element, attrs, ctrl) {
            scope.views = scope.Designer.environment.views;
            scope.allowable_views = DesignerConfig.get("allowableViews");
            $rootScope.expandedPicker = JSON.parse(localStorage.getItem('expanded_picker'));
  
            // TODO: temp value - this should be removed in future when it's handled by the API
            if(scope.allowable_views.length > 0) {
              scope.views = _.filter(scope.views, function(v) { return _.includes(scope.allowable_views, v.type) })
            }

            scope.toggle = function () {
              $timeout(function () {
                $rootScope.expandedPicker = !$rootScope.expandedPicker;
                localStorage.setItem('expanded_picker', $rootScope.expandedPicker);
              })
            }
  
            scope.selectView = function(view) {
              if(view.id === scope.Designer.environment.current_view.id) return;
  
              // TODO: check if we want to set current view in the environment or just in the state
              scope.Designer.environment.setCurrentView(view.id);
              DesignerState.set("selectedView", view.type);
              $rootScope.$broadcast("view:selected", view);
            };
  
            scope.$on("environment:reloaded",  function() {
              scope.views = scope.Designer.environment.views;
            });

            scope.viewIcons = {
              'AWS Infrastructure': 'computer',
              'Infrastructure': 'computer',
              'Extended Infrastructure': 'dashboard',
              'List': 'list',
              'Security Group': 'security',
              'Container': 'dashboard'
            }
          }
        }
      }
    }]);
  
angular.module('designer.workspace.views.selector', [
  "designer.configuration",
  "designer.state"
])
.directive('viewsSelector', ["$rootScope", "DesignerConfig", "DesignerState", function($rootScope, DesignerConfig, DesignerState) {
    return {
      templateUrl: '/designer/workspace/controls/views.selector.html',
      replace: true,
      link: {
        post: function(scope, element, attrs, ctrl) {
          scope.views = scope.Designer.environment.views;
          scope.allowable_views = DesignerConfig.get("allowableViews");

          // TODO: temp value - this should be removed in future when it's handled by the API
          if(scope.allowable_views.length > 0) {
            scope.views = _.filter(scope.views, function(v) { return _.includes(scope.allowable_views, v.type) })
          }

          scope.selectView = function(view) {
            if(view.id === scope.Designer.environment.current_view.id) return;

            // TODO: check if we want to set current view in the environment or just in the state
            scope.Designer.environment.setCurrentView(view.id);
            DesignerState.set("selectedView", view.type);

            $rootScope.$broadcast("view:selected", view);
          };

          scope.$on("environment:reloaded",  function() {
            scope.views = scope.Designer.environment.views;

            if(scope.allowable_views.length > 0) {
              scope.views = _.filter(scope.views, function(v) { return _.includes(scope.allowable_views, v.type) })
            }
          });
        }
      }
    }
  }]);

angular.module("designer.workspace.views.factory", [
  "designer.model.view",
  "designer.workspace.views.infrastructure",
  "designer.workspace.views.infrastructure-info",
  "designer.workspace.views.security",
  "designer.workspace.views.container",
  "designer.workspace.views.list"
])
  .service("ViewsFactory", ["View", "InfrastructureView", "InfrastructureInfoView", "SecurityView", "ListView", "ContainerLayoutView",
    function(View, InfrastructureView, InfrastructureInfoView, SecurityView, ListView, ContainerLayoutView)
    {
      return function fromResourceObject(obj, environment) {
        var constructors = {
          "Views::Infrastructure": InfrastructureView,
          "Views::Infrastructure::Extended": InfrastructureInfoView,
          "Views::Security": SecurityView,
          "Views::Container": ContainerLayoutView,
          "Views::List": ListView
        };

        var c = constructors[obj.type];
        var view = c ? c.create(obj) : View.create(obj);

        view.load(environment);

        return view;
      };
    }]);

angular.module('designer.workspace.views.container', [
  "designer.model.view",
  "designer.workspace.canvases.jointjs.graph",
  "designer.workspace.views.container.shapes.cluster",
  "designer.workspace.views.container.shapes.namespace",
  "designer.workspace.views.container.shapes.aws.service",
  "designer.workspace.views.container.shapes.kubernetes.service",
  'designer.workspace.views.container.shapes.hex',
  'designer.workspace.views.container.shapes.hex.empty',
  'designer.workspace.views.container.shapes.workload',
  'designer.workspace.views.container.shapes.load-balancer'
])
.factory('ContainerLayoutView', [
  "View", "Graph", "ClusterElement", "HexElement", "NamespaceElement", "AWSServiceElement", "KubeServiceElement", "EmptyHexElement", "LoadBalancerElement", "WorkloadElement",
  function(View, Graph, ClusterElement, HexElement, NamespaceElement, AWSServiceElement, KubeServiceElement, EmptyHexElement, LoadBalancerElement, WorkloadElement) {
    return {
      create: function(obj) {
        var view = View.create(obj);

        view.name = "Container";
        view.canvas = "jointjs";
        view.positioned = false;
        view.height = 0;
        view.width  = 0;
        view.model = new Graph();

        // Set some of our own shapes
        view.model.shapes.custom = {
          "Resources::AWS::ECS::Cluster": ClusterElement,
          "Resources::AWS::ECS::Task": HexElement,
          "Resources::AWS::ECS::Service": AWSServiceElement,
          "Resources::AWS::ElasticLoadBalancingV2::TargetGroup": LoadBalancerElement,
          "Resources::AWS::ElasticLoadBalancing::LoadBalancer": LoadBalancerElement,

          "Resources::Kubernetes::Cluster::Cluster": ClusterElement,
          "Resources::Kubernetes::Cluster::Namespace": NamespaceElement,
          "Resources::Kubernetes::Cluster::Pod": HexElement,
          "Resources::Kubernetes::Cluster::DaemonSet": WorkloadElement,
          "Resources::Kubernetes::Cluster::Deployment": WorkloadElement,
          "Resources::Kubernetes::Cluster::ReplicaSet": WorkloadElement,
          "Resources::Kubernetes::Cluster::StatefulSet": WorkloadElement,
          "Resources::Kubernetes::Cluster::Service": KubeServiceElement,
        };

        // Disable visio export
        view.supported_exports.vsdx = false;

        view.isEmpty = function() {
          return this.model.resourceCells.length === 0;
        };

        view.load = function(model) {
          this.loadResources(model);
          this.loadEmptyCells();
          this.loadResourceConnections(model);
          this.loadDimensions();
        };

        view.load_with_positions = function(model, coords) {
          this.coordinates = coords;

          this.loadResources(model);
          this.loadEmptyCells();
          this.loadResourceConnections(model);
          this.loadDimensions();

          this.positioned = true;
        };

        view.reposition = function(model, coords) {
          // Just clear and redraw
          this.model.clear();

          this.load_with_positions(model, coords);
        };

        view.geometry = function(resource_id) {
          return _.filter(this.coordinates, function(geometry) { return geometry["id"] === resource_id });
        };

        view.loadResources = function(model) {
          _.each(model.facet.resources, function(resource) {
            var geom = this.geometry(resource.id);

            if(resource.drawable(true) && geom.length > 0) {
              _.each(geom, function(g) { this.model.createResourceCell(resource, g) }.bind(this));
            }
          }.bind(this));
        };

        view.loadResourceConnections = function(environment) {
          var connection_map = [];
          _.each(environment.facet.resources, function (resource) {
            if(resource.drawable() && this.geometry(resource.id).length > 0) {
              var connectables = resource.getDisplayableConnections();

              _.each(connectables, function(c) {
                // Check if we've already done this connection
                if(connection_map[resource.id] && _.includes(connection_map[resource.id], c.id)) {
                  return;
                }
                else {
                  if(!connection_map[resource.id]) connection_map[resource.id] = [];
                  connection_map[resource.id].push(c.id)
                }

                var provideCells = this.model.getResourceCellsForResource(resource.id);
                var dependCells  = this.model.getResourceCellsForResource(c.id);

                _.each(provideCells, function(provideCell) {
                  _.each(dependCells, function(dependCell) {
                    this.model.createResourceLink(provideCell, dependCell, {});
                  }.bind(this));
                }.bind(this));
              }.bind(this));
            }
          }.bind(this));
        };

        view.loadEmptyCells = function() {
          var empty = this.geometry("empty");

          _.each(empty, function(g) { this.model.createShape(g, EmptyHexElement) }.bind(this));
        };

        view.loadDimensions = function() {
          _.each(this.coordinates, function(g) {
            if(g && g.x && g.y) {
              var max_x = g.x + g.w;
              var max_y = g.y + g.h;

              if(max_x > this.width)  this.width  = max_x;
              if(max_y > this.height) this.height = max_y;
            }
          }.bind(this));
        };

        return view;
      }
    }
  }]);

angular.module('designer.workspace.views.infrastructure-info', [
  'designer.workspace.views.infrastructure',
  'designer.workspace.views.infrastructure-info.shapes.resource',
  'designer.workspace.views.infrastructure-info.shapes.elb'
])
.factory('InfrastructureInfoView', ["InfrastructureView", "InfrastructureInfoResourceElement", "InfrastructureInfoELBElement",
  function(InfrastructureView, InfrastructureInfoResourceElement, InfrastructureInfoELBElement) {
  return {
    create: function(obj) {
      var view = InfrastructureView.create(obj);
      view.name = "Extended Infrastructure";

      // Deny visio export
      view.supported_exports.vsdx = false;

      // AWS shapes
      view.model.shapes.custom["Resources::AWS::EC2::Instance"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::EC2::NATGateway"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::EFS::FileSystem"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::RDS::DBInstance"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::RDS::DBCluster"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::AutoScaling::AutoScalingGroup"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::ElasticLoadBalancing::LoadBalancer"] = InfrastructureInfoELBElement;
      view.model.shapes.custom["Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer"] = InfrastructureInfoELBElement;
      view.model.shapes.custom["Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer"] = InfrastructureInfoELBElement;
      view.model.shapes.custom["Resources::AWS::ElastiCache::CacheNode"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::Redshift::ClusterNode"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::WorkSpaces::WorkSpace"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::DirectoryService::Directory"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::AWS::Lambda::Function"] = InfrastructureInfoResourceElement;

      // Azure shapes
      view.model.shapes.custom["Resources::Azure::Compute::VirtualMachine"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::Azure::Batch::Pool"] = InfrastructureInfoResourceElement;

      // GCP shapes
      // TODO: I think we need a custom GCP shape for the load balancer so we can figure out which info to show
      view.model.shapes.custom["Resources::GCP::Compute::Instance"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::GCP::SQL::Instance"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::GCP::MemoryStore::Instance"] = InfrastructureInfoResourceElement;
      view.model.shapes.custom["Resources::GCP::Compute::URLMap"] = InfrastructureInfoELBElement;
      view.model.shapes.custom["Resources::GCP::Compute::RegionURLMap"] = InfrastructureInfoELBElement;
      view.model.shapes.custom["Resources::GCP::Compute::TargetPool"] = InfrastructureInfoELBElement;
      view.model.shapes.custom["Resources::GCP::Compute::BackendService"] = InfrastructureInfoELBElement;

      return view;
    }
  }
}]);

angular.module('designer.workspace.views.infrastructure', [
  "designer.configuration",
  "designer.model.view",
  "designer.workspace.canvases.jointjs.graph",
  "designer.workspace.views.infrastructure.aws.shapes.subnet",
  "designer.workspace.views.infrastructure.aws.shapes.vpc",
  'designer.workspace.views.infrastructure.aws.shapes.availability-zone',

  "designer.workspace.views.infrastructure.ibm.shapes.subnet",
  "designer.workspace.views.infrastructure.ibm.shapes.vpc",
  'designer.workspace.views.infrastructure.ibm.shapes.availability-zone',

  "designer.workspace.views.infrastructure.azure.shapes.subnet",
  "designer.workspace.views.infrastructure.azure.shapes.virtual-network",
  "designer.workspace.views.infrastructure.azure.shapes.resource-group",

  "designer.workspace.views.infrastructure.gcp.shapes.subnetwork",
  "designer.workspace.views.infrastructure.gcp.shapes.network",
  "designer.workspace.views.infrastructure.gcp.shapes.zone",

  "designer.model.resources.aws.availabilityzone",
  "designer.model.resources.ibm.availabilityzone",
  "designer.model.resources.gcp.zone",
])
.factory('InfrastructureView', [
  "View", "Graph", "SubnetElement", "VpcElement", "AZElement", "AzureSubnetElement", "AzureVirtualNetworkElement", "AzureResourceGroupElement",
  "GCPNetworkElement", "GCPSubnetworkElement", "GCPZoneElement", "DesignerConfig", "AWS_AvailabilityZone", "GCP_Zone",
  "IBMVpcElement", "IBMSubnetElement", "IBMAZElement", "IBM_AvailabilityZone",
  function(View, Graph, SubnetElement, VpcElement, AZElement, AzureSubnetElement, AzureVirtualNetworkElement, AzureResourceGroupElement,
           GCPNetworkElement, GCPSubnetworkElement, GCPZoneElement, DesignerConfig, AWS_AvailabilityZone, GCP_Zone,
           IBMVpcElement, IBMSubnetElement, IBMAZElement, IBM_AvailabilityZone) {
    return {
      create: function(obj) {
        var view = View.create(obj);

        view.name = "Infrastructure";
        view.canvas = "jointjs";
        view.positioned = false;
        view.height = 0;
        view.width  = 0;
        view.az_padding = 16;
        view.model = new Graph();

        // Set some of our own shapes
        view.model.shapes.custom = {
          "Resources::AWS::EC2::VPC": VpcElement,
          "Resources::AWS::EC2::Subnet": SubnetElement,
          "Resources::AWS::AvailabilityZone": AZElement,

          "Resources::Azure::Network::VirtualNetwork": AzureVirtualNetworkElement,
          "Resources::Azure::Network::Subnet": AzureSubnetElement,
          "Resources::Azure::Resources::ResourceGroup": AzureResourceGroupElement,

          "Resources::GCP::Compute::Network": GCPNetworkElement,
          "Resources::GCP::Compute::Subnetwork": GCPSubnetworkElement,
          "Resources::GCP::Zone": GCPZoneElement,

          "Resources::IBM::EC2::VPC": IBMVpcElement,
          "Resources::IBM::EC2::Subnet": IBMSubnetElement,
          "Resources::IBM::AvailabilityZone": IBMAZElement,
        };

        // Allow visio export
        view.supported_exports.vsdx = true;

        view.isEmpty = function() {
          return this.model.resourceCells.length === 0 && this.model.resourceLinks.length === 0;
        };

        view.load_with_positions = function(model, coords) {
          this.coordinates = coords;

          this.loadResources(model);
          this.loadAzs(model);

          if(DesignerConfig.get("loadConnections"))
            this.loadResourceConnections(model);

          this.loadDimensions();

          this.positioned = true;
        };

        view.reposition = function(model, coords) {
          this.coordinates = coords;
          var resource_ids = _.uniq(_.map(coords, function(c) { return c.id }));
          _.each(resource_ids, function(id) {
            var geom = this.geometry(id);
            var cells = this.model.findByResourceId(id);
            _.each(geom, function(g) {
              var cell = cells.shift();
              if (cell) {
                cell.position(g.x, g.y);
                cell.resize(g.w, g.h);
              }
            })
          }.bind(this));

          // Reload AZ's and dimensions
          this.loadAzs(model);
          this.loadDimensions();
        };

        view.geometry = function(resource_id) {
          return _.filter(this.coordinates, function(geometry) { return geometry["id"] === resource_id });
        };

        view.loadResources = function(model) {
          _.each(model.facet.resources, function(resource) {
            var geom = this.geometry(resource.id);

            if(resource.drawable(true) && geom.length > 0) {
              _.each(geom, function(g) { this.model.createResourceCell(resource, g) }.bind(this));
            }
          }.bind(this));
        };

        view.loadAzs = function(model) {
          // Draw each VPC separately
          var vpcs = model.getResourcesByType("Resources::AWS::EC2::VPC");

          if(vpcs.length === 0) {
            this.calculateAzs(model.getResourcesByType("Resources::AWS::EC2::Subnet"));
          }
          else {
            _.each(vpcs, function(vpc) {
              this.calculateAzs(model.getResourcesByType("Resources::AWS::EC2::Subnet", vpc), vpc.id);
            }.bind(this));
          }

          // Just copy the above for IBM for now
          var vpcs = model.getResourcesByType("Resources::IBM::EC2::VPC");

          if(vpcs.length === 0) {
            this.calculateAzs(model.getResourcesByType("Resources::IBM::EC2::Subnet"));
          }
          else {
            _.each(vpcs, function(vpc) {
              this.calculateAzs(model.getResourcesByType("Resources::IBM::EC2::Subnet", vpc), vpc.id);
            }.bind(this));
          }

          // Draw zones for GCP... assume we always have a network
          var networks = model.getResourcesByType("Resources::GCP::Compute::Network");
          _.each(networks, function(network) {
            this.calculateZones(model, network);
          }.bind(this));
        };

        view.calculateAzs = function(subnets_to_wrap, parent_id) {
          // Group subnets by AZ
          var subnets = {};
          var is_ibm = (subnets_to_wrap[0] && subnets_to_wrap[0].type === "Resources::IBM::EC2::Subnet");

          _.each(subnets_to_wrap, function(r) {
            var az = r.availability_zone || "";

            if(!subnets[az])
              subnets[az] = [];

            subnets[az].push(r);
          });

          // Make sure the az wraps the subnets
          var azs = [];
          var globalMaxY = 0;
          _.each(subnets, function(sns, az_name) {
            var az    = { name: az_name, x: 0, y: 0, width: 0, height: 0 },
              max_x = 0,
              max_y = 0;

            _.each(sns, function(sn) {
              var g = this.geometry(sn.id)[0];

              // Set the origin if needed
              if(az.x === 0 || g.x < az.x) az.x = g.x;
              if(az.y === 0 || g.y < az.y) az.y = g.y;

              // Set max values so we can set height and width later
              var sn_max_x = g.x + g.w;
              var sn_max_y = g.y + g.h;
              if(max_x === 0 || max_x < sn_max_x) max_x = sn_max_x;
              if(max_y === 0 || max_y < sn_max_y) max_y = sn_max_y;
            }.bind(this));

            // Set width and height
            az.width  = max_x - az.x;
            az.height = max_y - az.y;

            // Pad it
            az.x -= this.az_padding;
            az.y -= this.az_padding;

            az.width += this.az_padding*2;
            az.height += this.az_padding*3;

            // AZ's can start at different points but they all need to end at the same point
            if(max_y > globalMaxY) globalMaxY = max_y;

            azs.push(az);
          }.bind(this));

          _.each(azs, function(az) {
            az.id = az.name + "_" + parent_id;
            az.type = is_ibm ? "Resources::IBM::AvailabilityZone" : "Resources::AWS::AvailabilityZone";

            // Make sure it reaches the bottom
            if(az.y + az.height < globalMaxY) {
              az.height = globalMaxY - az.y + this.az_padding*2;
            }

            // If we're repositioning then just update it
            var azs = this.model.findByResourceId(az.id);
            var geom = { x: az.x, y: az.y, w: az.width, h: az.height };

            if(azs.length) {
              azs[0].position(az.x, az.y);
              azs[0].resize(az.width, az.height);
            }
            else {
              var az_class = is_ibm ? IBM_AvailabilityZone : AWS_AvailabilityZone;
              az = az_class.load(az, {subnets: subnets[az.name] });
              this.model.createResourceCell(az, geom);
            }

          }.bind(this));
        };

        view.calculateZones = function(model, network) {
          var all_zones = {};
          var visible_zones = [];

          _.each(model.getResourcesByType("Resources::GCP::Compute::Subnetwork", network), function(subnet) {
            var resources = model.connectedTo(subnet, null, true);

            // Keep track of the subnet cells on the diagram
            subnet.cells = [];

            // Let's grab any zones that aren't undefined
            subnet.zones = _.reject(_.uniq(_.map(resources, function(r) { return r.zone })).sort(), function(zone) {
              return zone === undefined;
            });

            // No zones, we don't draw it in one
            if(subnet.zones.length === 0)
              return;

            // Figure out how many cells we have per subnet and which are in which zones
            _.each(this.geometry(subnet.id), function(g) {
              var subnet_cell = {
                id: subnet.id,
                x: g.x,
                y: g.y,
                w: g.w,
                h: g.h,
                max_x: g.x + g.w,
                max_y: g.y + g.h,
                zone_top_left: {},
                zones: []
              };

              // If any resources are within this subnet cell then it's part of that zone
              _.each(resources, function(r) {
                _.each(this.geometry(r.id), function(r_g) {
                  if((r_g.x >= subnet_cell.x && r_g.x <= subnet_cell.max_x) && (r_g.y >= subnet_cell.y && r_g.y <= subnet_cell.max_y)) {
                    subnet_cell.zones.push(r.zone);

                    // Keep track of zones that have visible resources in them, otherwise there's no point showing it
                    visible_zones.push(r.zone);

                    // Keep track of the top left coords so we can draw the zone there if required
                    if(!subnet_cell.zone_top_left[r.zone] || r_g.x < subnet_cell.zone_top_left[r.zone])
                      subnet_cell.zone_top_left[r.zone] = r_g.x;
                  }
                }.bind(this));
              }.bind(this));

              subnet_cell.zones = _.uniq(subnet_cell.zones).sort();

              subnet.cells.push(subnet_cell);
            }.bind(this));

            _.each(subnet.zones, function(zone) {
              if(!all_zones[zone])
                all_zones[zone] = [];

              all_zones[zone].push(subnet);
            }.bind(this));
          }.bind(this));

          // Make sure the az wraps the subnets
          var zones = [];
          
          var globalMaxY = 0;
          _.each(all_zones, function(subnets, zone_name) {
            if(zone_name === "") return;

            var zone = { name: zone_name, x: 0, y: 0, width: 0, height: 0 },
              max_x  = 0,
              max_y  = 0;

            _.each(subnets, function(subnet) {
              _.each(subnet.cells, function(cell) {
                // Only for this zone bro
                if(cell.zones.indexOf(zone_name) === -1) return;

                // Set top and bottom, these are the same regardless of span
                if(zone.y === 0 || cell.y < zone.y) zone.y = cell.y;
                if(max_y === 0 || max_y < cell.max_y) max_y = cell.max_y;

                if (cell.zones.length === 1) {
                  // If we only have one cell we can set side and width too
                  if(zone.x === 0 || cell.x < zone.x) zone.x = cell.x;
                  if(max_x === 0 || max_x < cell.max_x) max_x = cell.max_x;
                }
                else {
                  // We span multiple zones, so we need to do our best to figure out where this cell starts -_-
                  var top_left = cell.zone_top_left[zone_name];
                  if (top_left && (zone.x === 0 || top_left < zone.x)) zone.x = (top_left-16);

                  // If this is the last cell then use the right hand side as our width
                  if (cell.zones.indexOf(zone_name) === (cell.zones.length-1)) {
                    if(max_x === 0 || max_x < cell.max_x) max_x = cell.max_x;
                  }
                }
              }.bind(this));
            }.bind(this));

            // Okaaay so grab resources in this zone and check if any are further down the page
            var resources_in_zone = _.filter(model.facet.resources, function(r) { return r["zone"] === zone_name });
            _.each(resources_in_zone, function(r) {
              _.each(this.geometry(r.id), function(g) {
                if (g.y + g.h > max_y)
                  max_y = g.y + g.h + (this.az_padding*2);
              }.bind(this));
            }.bind(this));

            // Set width and height
            if(max_x)
              zone.width  = max_x - zone.x;
            if (max_y)
              zone.height = max_y - zone.y;

            // AZ's can start at different points but they all need to end at the same point
            if(max_y > globalMaxY) globalMaxY = max_y;

            zones.push(zone);
          }.bind(this));

          // Remove invisible zones, filter, sort
          visible_zones = _.uniq(visible_zones);
          zones = _.filter(zones, (z) => _.includes(visible_zones, z.name));
          zones = _.sortBy(zones, (z) => z.name);

          // If we have no width then base it on the next zone along
          for (var i = 0; i < zones.length; i++) {
            var zone = zones[i];
            var next_zone = zones[i+1];

            if (zone.width === 0 && next_zone) {
              zone.width = (next_zone.x - zone.x - 48);
            }
          }

          _.each(zones, function(zone) {
            if(!zone.name || !_.includes(visible_zones, zone.name)) return;

            // Make sure the name is unique
            zone.id = zone.name + "_" + network.id;
            zone.type = "Resources::GCP::Zone";

            // Pad it
            zone.x -= this.az_padding;
            zone.y -= this.az_padding;
            zone.width += this.az_padding*2;
            zone.height += this.az_padding*3;
            
            // Make sure it reaches the bottom
            if(zone.y + zone.height < globalMaxY) {
              zone.height = globalMaxY - zone.y + this.az_padding*2;
            }

            var geom = { x: zone.x, y: zone.y, w: zone.width, h: zone.height };
            // If we're repositioning then just update it
            var zones = this.model.findByResourceId(zone.id);
            if(zones.length) {
              zones[0].position(zone.x, zone.y);
              zones[0].resize(zone.width, zone.height);
            }
            else {
              var az = GCP_Zone.load(zone, {subnets: all_zones[zone.name] });
              this.model.createResourceCell(az, geom);
            }
          }.bind(this));
        };

        view.loadResourceConnections = function(environment) {
          var connection_map = [];
          _.each(environment.facet.resources, function (resource) {
            if(resource.drawable() && this.geometry(resource.id).length > 0) {
              var connectables = resource.getDisplayableConnections();

              _.each(connectables, function(c) {
                // Check if we've already done this connection
                if(connection_map[resource.id] && _.includes(connection_map[resource.id], c.id)) {
                  return;
                }
                else {
                  if(!connection_map[resource.id]) connection_map[resource.id] = [];
                  connection_map[resource.id].push(c.id)
                }

                var provideCells = this.model.getResourceCellsForResource(resource.id);
                var dependCells  = this.model.getResourceCellsForResource(c.id);

                _.each(provideCells, function(provideCell) {
                  _.each(dependCells, function(dependCell) {
                    this.model.createResourceLink(provideCell, dependCell, {});
                  }.bind(this));
                }.bind(this));
              }.bind(this));
            }
          }.bind(this));
        };

        view.loadDimensions = function() {
          this.width = this.height = 0;

          _.each(this.coordinates, function(g) {
            if(g && g.x && g.y) {
              var max_x = g.x + g.w;
              var max_y = g.y + g.h;

              if(max_x > this.width)  this.width  = max_x;
              if(max_y > this.height) this.height = max_y;
            }
          }.bind(this));
        };

        return view;
      }
    }
  }]);

angular.module('designer.workspace.views.list', [
  "designer.model.view",
  "designer.workspace.views.list.control"
])
  .factory('ListView', ["$rootScope", "$compile", "$http", "$templateCache", "View",
    function($rootScope, $compile, $http, $templateCache, View) {
      return {
        create: function(obj) {
          var view = View.create(obj);

          view.name = "List";
          view.canvas = "html";
          view.zoomable = false;
          view.scrollable = false;
          view.elements = [];
          view.model = null;
          view.height = 0;
          view.width  = 0;
          view.controller = null;

          view.supported_exports = {
            pdf: false,
            png: false,
            vsdx: false,
            csv: true,
            json: true
          };

          view.load = function(model) {
            this.model = model;
          };

          view.compileController = function() {
            var $scope = $rootScope.$new(true);
            $scope.resources = _.map(this.resources, function(list_items) {
              return this.model.getResource(list_items["id"])
            }.bind(this));
            var controller = $('<div list-control></div>');

            $compile(controller)($scope);

            return controller;
          };

          view.render = function(diagram) {
            diagram.clear();

            this.controller = this.compileController();

            diagram.el.append(this.controller);
          };

          view.loadDimensions = function() {
            if(this.controller) {
              this.height = this.controller.height();
              this.width = 1100; // Need to set a minimum or it goes all squishy
            }
          };

          return view;
        }
      }
    }]);

angular.module('designer.workspace.views.security', [
  "designer.model.view",
  "designer.workspace.canvases.jointjs.graph",
  "designer.workspace.views.security.shapes.arrow",
  "designer.workspace.views.security.shapes.arrow.azure",
  "designer.workspace.views.security.shapes.arrow.horizontal",
  "designer.workspace.views.security.shapes.security-group",
  "designer.workspace.views.security.shapes.security-group.azure",
  'designer.model.resources.security.arrow',
  'designer.model.resources.security.arrow.azure',
  'designer.model.resources.security.arrow.horizontal',
  'designer.workspace.views.security.shapes.nsg',
  'designer.model.resource'
])
  .factory('SecurityView', ["View", "Graph", "ArrowElement", "AzureArrowElement", "HorizontalArrowElement", "SecurityGroupElement", "AzureSecurityGroupElement", "SecurityArrow", "AureSecurityArrow", "HorizontalSecurityArrow", "NSGElement", "Resource",
    function(View, Graph, ArrowElement, AzureArrowElement, HorizontalArrowElement, SecurityGroupElement, AzureSecurityGroupElement, SecurityArrow, AureSecurityArrow, HorizontalSecurityArrow, NSGElement, Resource) {
      return {
        create: function(obj) {
          var view = View.create(obj);

          // TODO: i reckon a lot of this can be sent to View.create as an 'options' array, eh
          view.name = "Security Group";
          view.canvas = "jointjs";
          view.positioned = false;
          view.height = 0;
          view.width  = 0;
          view.model = new Graph();

          view.model.shapes.custom = {
            "Resources::AWS::EC2::SecurityGroup": SecurityGroupElement,
            "Resources::Azure::Network::Subnet": AzureSecurityGroupElement,
            "Resources::Azure::Network::NetworkInterface": AzureSecurityGroupElement,
            "Resources::Azure::Network::NetworkSecurityGroup": ArrowElement,
            "Resources::Azure::Network::ApplicationSecurityGroup": AzureSecurityGroupElement,
            "Resources::Security::Arrow": ArrowElement,
            "Resources::Security::Arrow::Azure": AzureArrowElement,
            "Resources::Security::Arrow::Horizontal": HorizontalArrowElement,
            "Resources::Azure::Generic::GlobalResource": AzureSecurityGroupElement
          };
          view.isEmpty = function() {
            return this.model.resourceCells.length === 0 && this.model.resourceLinks.length === 0;
          };

          view.load_with_positions = function(model, coords) {
            this.coordinates = coords;

            _.each(this.coordinates["arrows"], function(a) {
              a.y = a.y + 20;
              a.h = a.h - 40;
            });

            this.loadGroups(model);
            this.loadArrows(model);
            this.loadNSGs(model);
            this.loadInternalTraffic(model);
            this.loadLabels(model);

            this.loadDimensions();

            this.positioned = true;
          };

          view.reposition = function(model, coords) {
            // Implement when we can reposition
          };

          view.geometry = function(resource_id) {
            return _.filter(this.coordinates.rows, function(geometry) { return geometry["id"] === resource_id });
          };

          view.loadGroups = function(model) {
            _.each(this.coordinates["rows"], function(group) {
              var resource = model.getResource(group["id"]);

              if(resource) {
                this.model.createResourceCell(resource, group);
              }
              else {
                resource = this.loadEmptyResource(group);
                this.model.createResourceCell(resource, group);
              }
            }.bind(this));
          };

          view.loadLabels = function(model) {
            _.each(this.coordinates["labels"], function(label) {
              this.model.createTextBox(label);
            }.bind(this));
          };

          view.loadNSGs = function(model) {
            _.each(this.coordinates["nsg_blocks"], function(group) {
              var resource = model.getResource(group["id"])
              this.model.createShape(
                { id: group.id, x: group.x, y: group.y, width: group.w, height: group.h },
                NSGElement,
                {},
                resource
              );
            }.bind(this));
          }

          view.loadArrows = function(model) {
            _.each(this.coordinates["arrows"], function(arrow) {
              var geom = { x: arrow.x, y: arrow.y, w: arrow.width, h: arrow.height };
              var security_arrow;

              if (arrow.provider === "azure") {
                if (arrow.size === 0) {
                  security_arrow = HorizontalSecurityArrow.load(arrow)
                  this.loadSourceDestinations(model, security_arrow, 'id')
                } else {
                  security_arrow = AureSecurityArrow.load(arrow)
                  this.loadSourceDestinations(model, security_arrow, 'id')
                }
              } else {
                security_arrow = SecurityArrow.load(arrow);
                this.loadSourceDestinations(model, security_arrow, 'provider_id')
              }

              this.model.createResourceCell(security_arrow, geom, arrow);
              
            }.bind(this));
          };

          view.loadInternalTraffic = function(model) {
            _.each(this.coordinates["internal_blocks"], function(group) {
              var resource = model.getResource(group["id"])
              this.model.createShape(
                { name: "Internal", id: group.id, x: group.x, y: group.y, width: group.w, height: group.h },
                InternalElement,
                {},
                resource
              )
            })
          }

          view.loadDimensions = function() {
            var max_x, max_y = 0;

            _.each(this.coordinates.rows.concat(this.coordinates.labels), function(group) {
              max_x = group.x + group.w;
              max_y  = group.y + group.h;

              if(max_y > this.height) this.height = max_y;
              if(max_x > this.width)  this.width  = max_x;
            }.bind(this));

            // Add some padding
            this.height += 50;
            this.width += 50;
          };

          view.loadEmptyResource = function(group) {
            var resource = Resource.load(
              {
                name: group.name,
                type: 'Resources::Azure::Generic::GlobalResource',
                id: _.uniqueId(1000)
              }
            );

            resource.only_properties = {};
            resource.type_name = group.name;
            resource.info = function() {return {}}

            return resource;
          }

          view.loadSourceDestinations = function (model, security_arrow, id) {
            // Find source/destination information
            const source_row = this.coordinates["rows"].find((r) => r[id] === security_arrow.src);
            const destination_row = this.coordinates["rows"].find((r) => r[id] === security_arrow.dst);

            // Add source/destination information on arrows
            let source = model.getResource(source_row.id);
            let destination = model.getResource(destination_row.id);

            if (!source)  {
              source = source_row;
              source.resource = false;
            } else {
              source.resource = true;
            }
            if (!destination) {
              destination = destination_row;
              destination.resource = false;
            } else {
              destination.resource = true;
            }

            security_arrow.source = source;
            security_arrow.destination = destination;
          }

          return view;
        }
      }
    }]);

angular.module('designer.model.resources.aws.availabilityzone', ['designer.model.resource'])
  .factory('AWS_AvailabilityZone', ["Resource", function(Resource) {
    return {
      load: function(resource, data) {
        resource = Resource.load(resource);
        resource.type_name = 'AVAILABILITY ZONE';

        resource.info = function() {
          var info = {};

          info.subnets = data.subnets;

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module("designer.data.resources.aws.factory", [
  'designer.model.resource',

  "designer.model.resources.aws.apigateway.api_key",
  "designer.model.resources.aws.apigateway.authorizer",
  "designer.model.resources.aws.apigateway.deployment",
  "designer.model.resources.aws.apigateway.domain",
  "designer.model.resources.aws.apigateway.method",
  "designer.model.resources.aws.apigateway.model",
  "designer.model.resources.aws.apigateway.resource",
  "designer.model.resources.aws.apigateway.rest_api",
  "designer.model.resources.aws.apigateway.stage",
  "designer.model.resources.aws.apigateway.usage_plan",
  "designer.model.resources.aws.apigateway.vpc_link",
  "designer.model.resources.aws.autoscaling.auto_scaling_group",
  "designer.model.resources.aws.autoscaling.launch_configuration",
  "designer.model.resources.aws.autoscaling.scaling_policy",
  "designer.model.resources.aws.cloudfront.distribution",
  "designer.model.resources.aws.cloudfront.streamingdistribution",
  "designer.model.resources.aws.direct_connect.connection",
  "designer.model.resources.aws.direct_connect.direct_connect_gateway",
  "designer.model.resources.aws.direct_connect.direct_connect_gateway_association",
  "designer.model.resources.aws.direct_connect.virtual_interface",
  "designer.model.resources.aws.direct_connect.lag",
  "designer.model.resources.aws.directory_service.directory",
  "designer.model.resources.aws.directory_service.domain_controller",
  "designer.model.resources.aws.directory_service.trust",
  "designer.model.resources.aws.dynamodb.table",
  "designer.model.resources.aws.ec2.address",
  "designer.model.resources.aws.ec2.customer_gateway",
  "designer.model.resources.aws.ec2.dhcp_options",
  "designer.model.resources.aws.ec2.egress_only_internet_gateway",
  "designer.model.resources.aws.ec2.instance",
  "designer.model.resources.aws.ec2.internet_gateway",
  "designer.model.resources.aws.ec2.nat_gateway",
  "designer.model.resources.aws.ec2.network_acl",
  "designer.model.resources.aws.ec2.network_interface",
  "designer.model.resources.aws.ec2.placement_group",
  "designer.model.resources.aws.ec2.route_table",
  "designer.model.resources.aws.ec2.security_group",
  "designer.model.resources.aws.ec2.security_group_permission",
  "designer.model.resources.aws.ec2.subnet",
  "designer.model.resources.aws.ec2.transitgateway",
  "designer.model.resources.aws.ec2.transitgatewayattachment",
  "designer.model.resources.aws.ec2.transitgatewayroutetable",
  "designer.model.resources.aws.ec2.transitgatewayvpcattachment",
  "designer.model.resources.aws.ec2.volume",
  "designer.model.resources.aws.ec2.vpc",
  "designer.model.resources.aws.ec2.vpc_endpoint",
  "designer.model.resources.aws.ec2.vpc_peering_connection",
  "designer.model.resources.aws.ec2.vpn_connection",
  "designer.model.resources.aws.ec2.vpn_gateway",
  "designer.model.resources.aws.ecs.cluster",
  "designer.model.resources.aws.ecs.container",
  "designer.model.resources.aws.ecs.container_instance",
  "designer.model.resources.aws.ecs.deployment",
  "designer.model.resources.aws.ecs.service",
  "designer.model.resources.aws.ecs.task",
  "designer.model.resources.aws.ecs.task_definition",
  "designer.model.resources.aws.efs.file_system",
  "designer.model.resources.aws.efs.mount_target",
  "designer.model.resources.aws.elasticbeanstalk.application",
  "designer.model.resources.aws.elasticbeanstalk.applicationversion",
  "designer.model.resources.aws.elasticbeanstalk.environment",
  "designer.model.resources.aws.elastic_load_balancing.load_balancer",
  "designer.model.resources.aws.elastic_load_balancing_v2.application_load_balancer",
  "designer.model.resources.aws.elastic_load_balancing_v2.network_load_balancer",
  "designer.model.resources.aws.elastic_load_balancing_v2.listener",
  "designer.model.resources.aws.elastic_load_balancing_v2.rule",
  "designer.model.resources.aws.elastic_load_balancing_v2.target_group",
  "designer.model.resources.aws.elasticache.cache_cluster",
  "designer.model.resources.aws.elasticache.cache_node",
  "designer.model.resources.aws.elasticache.parameter_group",
  "designer.model.resources.aws.elasticache.subnet_group",
  "designer.model.resources.aws.redshift.cluster",
  "designer.model.resources.aws.redshift.cluster_node",
  "designer.model.resources.aws.redshift.parameter_group",
  "designer.model.resources.aws.redshift.cluster_subnet_group",
  "designer.model.resources.aws.rds.db_cluster",
  "designer.model.resources.aws.rds.db_instance",
  "designer.model.resources.aws.rds.db_security_group",
  "designer.model.resources.aws.rds.db_subnet_group",
  "designer.model.resources.aws.route53.hosted_zone",
  "designer.model.resources.aws.route53.resource_record_set",
  "designer.model.resources.aws.s3.bucket",
  "designer.model.resources.aws.sqs.queue",
  "designer.model.resources.aws.waf.rate_based_rule",
  "designer.model.resources.aws.waf.rule",
  "designer.model.resources.aws.waf.rule_group",
  "designer.model.resources.aws.waf.web_acl",
  "designer.model.resources.aws.wafv2.web_acl",
  "designer.model.resources.aws.workspaces.directory",
  "designer.model.resources.aws.workspaces.ip_group",
  "designer.model.resources.aws.workspaces.workspace",

  "designer.model.resources.aws.lambda.function_version",
  "designer.model.resources.aws.lambda.layer_version",
  "designer.model.resources.aws.lambda.event_source_mapping",
  "designer.model.resources.aws.lambda.function",
  "designer.model.resources.aws.lambda.layer",
  "designer.model.resources.aws.lambda.lambda_alias"
])
  .service("AWSResourcesFactory",
    [
      "Resource",

      "AWS_APIKey",
      "AWS_Authorizer",
      "AWS_Deployment",
      "AWS_Domain",
      "AWS_Method",
      "AWS_Model",
      "AWS_APIGatewayResource",
      "AWS_RestAPI",
      "AWS_Stage",
      "AWS_UsagePlan",
      "AWS_VPCLink",

      "AWS_AutoScalingGroup",
      "AWS_AutoScalingLaunchConfiguration",
      "AWS_AutoScalingScalingPolicy",

      "AWS_CloudFront_Distribution",
      "AWS_CloudFront_StreamingDistribution",

      "AWS_Connection",
      "AWS_DirectConnectGateway",
      "AWS_DirectConnectGatewayAssociation",
      "AWS_LAG",
      "AWS_VirtualInterface",

      "AWS_Directory",
      "AWS_DomainController",
      "AWS_Trust",

      "AWS_Address",
      "AWS_CustomerGateway",
      "AWS_DHCPOptions",
      "AWS_EgressOnlyInternetGateway",
      "AWS_Instance",
      "AWS_InternetGateway",
      "AWS_NATGateway",
      "AWS_NetworkACL",
      "AWS_NetworkInterface",
      "AWS_PlacementGroup",
      "AWS_RouteTable",
      "AWS_SecurityGroup",
      "AWS_SecurityGroupPermission",
      "AWS_Subnet",
      "AWS_TransitGateway",
      "AWS_TransitGatewayAttachment",
      "AWS_TransitGatewayRouteTable",
      "AWS_TransitGatewayVPCAttachment",
      "AWS_Volume",
      "AWS_VPC",
      "AWS_VPCEndpoint",
      "AWS_VpcPeeringConnection",
      "AWS_VpnConnection",
      "AWS_VpnGateway",

      "AWS_LoadBalancer",

      "AWS_ApplicationLoadBalancer",
      "AWS_NetworkLoadBalancer",
      "AWS_ALBListener",
      "AWS_ALBRule",
      "AWS_ALBTargetGroup",

      "AWS_ElastiCacheCacheCluster",
      "AWS_ElastiCacheCacheNode",
      "AWS_ElastiCacheParameterGroup",
      "AWS_ElastiCacheSubnetGroup",

      "AWS_ElasticBeanstalk_Application",
      "AWS_ElasticBeanstalk_ApplicationVersion",
      "AWS_ElasticBeanstalk_Environment",

      "AWS_DynamoDBTable",

      "AWS_ECSCluster",
      "AWS_ECSContainer",
      "AWS_ECSContainerInstance",
      "AWS_ECSDeployment",
      "AWS_ECSService",
      "AWS_ECSTask",
      "AWS_ECSTaskDefinition",

      "AWS_EFSFileSystem",
      "AWS_EFSMountTarget",

      "AWS_RedshiftCluster",
      "AWS_RedshiftClusterNode",
      "AWS_RedshiftParameterGroup",
      "AWS_RedshiftClusterSubnetGroup",
      
      "AWS_DBCluster",
      "AWS_DBInstance",
      "AWS_DBSecurityGroup",
      "AWS_DBSubnetGroup",

      "AWS_Route53HostedZone",
      "AWS_Route53ResourceRecordSet",

      "AWS_S3Bucket",

      "AWS_SQSQueue",

      "AWS_WAFRateBasedRule",
      "AWS_WAFRule",
      "AWS_WAFRuleGroup",
      "AWS_WAFWebACL",

      "AWS_WAFV2WebACL",

      "AWS_WorkSpacesDirectory",
      "AWS_WorkSpacesIPGroup",
      "AWS_WorkSpacesWorkSpace",

      "AWS_FunctionVersion",
      "AWS_LayerVersion",
      "AWS_EventSourceMapping",
      "AWS_LambdaFunction",
      "AWS_Layer",
      "AWS_LambdaAlias",

      function(
        Resource,

        AWS_APIKey,
        AWS_Authorizer,
        AWS_Deployment,
        AWS_Domain,
        AWS_Method,
        AWS_Model,
        AWS_APIGatewayResource,
        AWS_RestAPI,
        AWS_Stage,
        AWS_UsagePlan,
        AWS_VPCLink,

        AWS_AutoScalingGroup,
        AWS_AutoScalingLaunchConfiguration,
        AWS_AutoScalingScalingPolicy,

        AWS_CloudFront_Distribution,
        AWS_CloudFront_StreamingDistribution,

        AWS_Connection,
        AWS_DirectConnectGateway,
        AWS_DirectConnectGatewayAssociation,
        AWS_LAG,
        AWS_VirtualInterface,

        AWS_Directory,
        AWS_DomainController,
        AWS_Trust,

        AWS_Address,
        AWS_CustomerGateway,
        AWS_DHCPOptions,
        AWS_EgressOnlyInternetGateway,
        AWS_Instance,
        AWS_InternetGateway,
        AWS_NATGateway,
        AWS_NetworkACL,
        AWS_NetworkInterface,
        AWS_PlacementGroup,
        AWS_RouteTable,
        AWS_SecurityGroup,
        AWS_SecurityGroupPermission,
        AWS_Subnet,
        AWS_TransitGateway,
        AWS_TransitGatewayAttachment,
        AWS_TransitGatewayRouteTable,
        AWS_TransitGatewayVPCAttachment,
        AWS_Volume,
        AWS_VPC,
        AWS_VPCEndpoint,
        AWS_VpcPeeringConnection,
        AWS_VpnConnection,
        AWS_VpnGateway,

        AWS_LoadBalancer,

        AWS_ApplicationLoadBalancer,
        AWS_NetworkLoadBalancer,
        AWS_ALBListener,
        AWS_ALBRule,
        AWS_ALBTargetGroup,

        AWS_ElastiCacheCacheCluster,
        AWS_ElastiCacheCacheNode,
        AWS_ElastiCacheParameterGroup,
        AWS_ElastiCacheSubnetGroup,

        AWS_ElasticBeanstalk_Application,
        AWS_ElasticBeanstalk_ApplicationVersion,
        AWS_ElasticBeanstalk_Environment,

        AWS_DynamoDBTable,

        AWS_ECSCluster,
        AWS_ECSContainer,
        AWS_ECSContainerInstance,
        AWS_ECSDeployment,
        AWS_ECSService,
        AWS_ECSTask,
        AWS_ECSTaskDefinition,

        AWS_EFSFileSystem,
        AWS_EFSMountTarget,

        AWS_RedshiftCluster,
        AWS_RedshiftClusterNode,
        AWS_RedshiftParameterGroup,
        AWS_RedshiftClusterSubnetGroup,

        AWS_DBCluster,
        AWS_DBInstance,
        AWS_DBSecurityGroup,
        AWS_DBSubnetGroup,

        AWS_Route53HostedZone,
        AWS_Route53ResourceRecordSet,

        AWS_S3Bucket,

        AWS_SQSQueue,

        AWS_WAFRateBasedRule,
        AWS_WAFRule,
        AWS_WAFRuleGroup,
        AWS_WAFWebACL,

        AWS_WAFV2WebACL,

        AWS_WorkSpacesDirectory,
        AWS_WorkSpacesIPGroup,
        AWS_WorkSpacesWorkSpace,

        AWS_FunctionVersion,
        AWS_LayerVersion,
        AWS_EventSourceMapping,
        AWS_LambdaFunction,
        AWS_Layer,
        AWS_LambdaAlias
  )
      {
        return function fromResourceObject(resource, environment) {
          var constructors = {
            "Resources::AWS::APIGateway::APIKey": AWS_APIKey,
            "Resources::AWS::APIGateway::Authorizer": AWS_Authorizer,
            "Resources::AWS::APIGateway::Deployment": AWS_Deployment, 
            "Resources::AWS::APIGateway::Domain": AWS_Domain,
            "Resources::AWS::APIGateway::Method": AWS_Method,
            "Resources::AWS::APIGateway::Model": AWS_Model,
            "Resources::AWS::APIGateway::Resource": AWS_APIGatewayResource,
            "Resources::AWS::APIGateway::RestAPI": AWS_RestAPI,
            "Resources::AWS::APIGateway::Stage": AWS_Stage,
            "Resources::AWS::APIGateway::UsagePlan": AWS_UsagePlan,
            "Resources::AWS::APIGateway::VpcLink": AWS_VPCLink,

            "Resources::AWS::AutoScaling::AutoScalingGroup": AWS_AutoScalingGroup,
            "Resources::AWS::AutoScaling::LaunchConfiguration": AWS_AutoScalingLaunchConfiguration,
            "Resources::AWS::AutoScaling::ScalingPolicy": AWS_AutoScalingScalingPolicy,

            "Resources::AWS::CloudFront::Distribution": AWS_CloudFront_Distribution,
            "Resources::AWS::CloudFront::StreamingDistribution": AWS_CloudFront_StreamingDistribution,

            "Resources::AWS::DirectConnect::Connection": AWS_Connection,
            "Resources::AWS::DirectConnect::DirectConnectGateway": AWS_DirectConnectGateway,
            "Resources::AWS::DirectConnect::DirectConnectGatewayAssociation": AWS_DirectConnectGatewayAssociation,
            "Resources::AWS::DirectConnect::LAG": AWS_LAG,
            "Resources::AWS::DirectConnect::VirtualInterface": AWS_VirtualInterface,

            "Resources::AWS::DirectoryService::Directory": AWS_Directory,
            "Resources::AWS::DirectoryService::DomainController": AWS_DomainController,
            "Resources::AWS::DirectoryService::Trust": AWS_Trust,
            
            "Resources::AWS::EC2::Address": AWS_Address,
            "Resources::AWS::EC2::CustomerGateway": AWS_CustomerGateway,
            "Resources::AWS::EC2::DHCPOptions": AWS_DHCPOptions,
            "Resources::AWS::EC2::EgressOnlyInternetGateway": AWS_EgressOnlyInternetGateway,
            "Resources::AWS::EC2::Instance": AWS_Instance,
            "Resources::AWS::EC2::InternetGateway": AWS_InternetGateway,
            "Resources::AWS::EC2::NATGateway": AWS_NATGateway,
            "Resources::AWS::EC2::NetworkACL": AWS_NetworkACL,
            "Resources::AWS::EC2::NetworkInterface": AWS_NetworkInterface,
            "Resources::AWS::EC2::PlacementGroup": AWS_PlacementGroup,
            "Resources::AWS::EC2::RouteTable": AWS_RouteTable,
            "Resources::AWS::EC2::SecurityGroup": AWS_SecurityGroup,
            "Resources::AWS::EC2::SecurityGroupPermission": AWS_SecurityGroupPermission,
            "Resources::AWS::EC2::Subnet": AWS_Subnet,
            "Resources::AWS::EC2::TransitGateway": AWS_TransitGateway,
            "Resources::AWS::EC2::TransitGatewayAttachment": AWS_TransitGatewayAttachment,
            "Resources::AWS::EC2::TransitGatewayRouteTable": AWS_TransitGatewayRouteTable,
            "Resources::AWS::EC2::TransitGatewayVPCAttachment": AWS_TransitGatewayVPCAttachment,
            "Resources::AWS::EC2::Volume": AWS_Volume,
            "Resources::AWS::EC2::VPC": AWS_VPC,
            "Resources::AWS::EC2::VPCEndpoint": AWS_VPCEndpoint,
            "Resources::AWS::EC2::VPCPeeringConnection": AWS_VpcPeeringConnection,
            "Resources::AWS::EC2::VPNConnection": AWS_VpnConnection,
            "Resources::AWS::EC2::VPNGateway": AWS_VpnGateway,

            "Resources::AWS::ECS::Cluster": AWS_ECSCluster,
            "Resources::AWS::ECS::Container": AWS_ECSContainer,
            "Resources::AWS::ECS::ContainerInstance": AWS_ECSContainerInstance,
            "Resources::AWS::ECS::Deployment": AWS_ECSDeployment,
            "Resources::AWS::ECS::Service": AWS_ECSService,
            "Resources::AWS::ECS::Task": AWS_ECSTask,
            "Resources::AWS::ECS::TaskDefinition": AWS_ECSTaskDefinition,

            "Resources::AWS::EFS::FileSystem": AWS_EFSFileSystem,
            "Resources::AWS::EFS::MountTarget": AWS_EFSMountTarget,

            "Resources::AWS::ElasticLoadBalancing::LoadBalancer": AWS_LoadBalancer,

            "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer": AWS_ApplicationLoadBalancer,
            "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer": AWS_NetworkLoadBalancer,
            "Resources::AWS::ElasticLoadBalancingV2::Listener": AWS_ALBListener,
            "Resources::AWS::ElasticLoadBalancingV2::Rule": AWS_ALBRule,
            "Resources::AWS::ElasticLoadBalancingV2::TargetGroup": AWS_ALBTargetGroup,

            "Resources::AWS::ElastiCache::CacheCluster": AWS_ElastiCacheCacheCluster,
            "Resources::AWS::ElastiCache::CacheNode": AWS_ElastiCacheCacheNode,
            "Resources::AWS::ElastiCache::ParameterGroup": AWS_ElastiCacheParameterGroup,
            "Resources::AWS::ElastiCache::CacheSubnetGroup": AWS_ElastiCacheSubnetGroup,

            "Resources::AWS::ElasticBeanstalk::Application": AWS_ElasticBeanstalk_Application,
            "Resources::AWS::ElasticBeanstalk::ApplicationVersion": AWS_ElasticBeanstalk_ApplicationVersion,
            "Resources::AWS::ElasticBeanstalk::Environment": AWS_ElasticBeanstalk_Environment,

            "Resources::AWS::DynamoDB::Table": AWS_DynamoDBTable,

            "Resources::AWS::Redshift::Cluster": AWS_RedshiftCluster,
            "Resources::AWS::Redshift::ClusterNode": AWS_RedshiftClusterNode,
            "Resources::AWS::Redshift::ClusterParameterGroup": AWS_RedshiftParameterGroup,
            "Resources::AWS::Redshift::ClusterSubnetGroup": AWS_RedshiftClusterSubnetGroup,
            
            "Resources::AWS::RDS::DBCluster": AWS_DBCluster,
            "Resources::AWS::RDS::DBInstance": AWS_DBInstance,
            "Resources::AWS::RDS::DBSecurityGroup": AWS_DBSecurityGroup,
            "Resources::AWS::RDS::DBSubnetGroup": AWS_DBSubnetGroup,

            "Resources::AWS::Route53::HostedZone": AWS_Route53HostedZone,
            "Resources::AWS::Route53::ResourceRecordSet": AWS_Route53ResourceRecordSet,

            "Resources::AWS::S3::Bucket": AWS_S3Bucket,

            "Resources::AWS::SQS::Queue": AWS_SQSQueue,

            "Resources::AWS::WAF::RateBasedRule": AWS_WAFRateBasedRule,
            "Resources::AWS::WAF::Rule": AWS_WAFRule,
            "Resources::AWS::WAF::RuleGroup": AWS_WAFRuleGroup,
            "Resources::AWS::WAF::WebACL": AWS_WAFWebACL,

            "Resources::AWS::WAFV2::WebACL": AWS_WAFV2WebACL,

            "Resources::AWS::WorkSpaces::Directory": AWS_WorkSpacesDirectory,
            "Resources::AWS::WorkSpaces::IPGroup": AWS_WorkSpacesIPGroup,
            "Resources::AWS::WorkSpaces::WorkSpace": AWS_WorkSpacesWorkSpace,

            "Resources::AWS::Lambda::FunctionVersion": AWS_FunctionVersion,
            "Resources::AWS::Lambda::LayerVersion": AWS_LayerVersion,
            "Resources::AWS::Lambda::EventSourceMapping": AWS_EventSourceMapping,
            "Resources::AWS::Lambda::Function": AWS_LambdaFunction,
            "Resources::AWS::Lambda::Layer": AWS_Layer,
            "Resources::AWS::Lambda::LambdaAlias": AWS_LambdaAlias

          };

          var c = constructors[resource.type];

          // TODO: if we don't find the resource we probably want to return a generic resource
          return c ? c.load(resource, environment) : Resource.load(resource, environment);
        };
      }]);

angular.module("designer.data.resources.kubernetes.factory", [
  'designer.model.resource',

  "designer.model.resources.kubernetes.cluster.cluster",
  "designer.model.resources.kubernetes.cluster.daemon_set",
  "designer.model.resources.kubernetes.cluster.deployment",
  "designer.model.resources.kubernetes.cluster.namespace",
  "designer.model.resources.kubernetes.cluster.node",
  "designer.model.resources.kubernetes.cluster.persistent_volume",
  "designer.model.resources.kubernetes.cluster.persistent_volume_claim",
  "designer.model.resources.kubernetes.cluster.pod",
  "designer.model.resources.kubernetes.cluster.replica_set",
  "designer.model.resources.kubernetes.cluster.service",
  "designer.model.resources.kubernetes.cluster.service_account",
  "designer.model.resources.kubernetes.cluster.stateful_set",

])
  .service("KubernetesResourcesFactory",
    [
      "Resource",

      "Kubernetes_Cluster",
      "Kubernetes_DaemonSet",
      "Kubernetes_Deployment",
      "Kubernetes_Namespace",
      "Kubernetes_Node",
      "Kubernetes_PersistentVolume",
      "Kubernetes_PersistentVolumeClaim",
      "Kubernetes_Pod",
      "Kubernetes_ReplicaSet",
      "Kubernetes_Service",
      "Kubernetes_ServiceAccount",
      "Kubernetes_StatefulSet",

      function(
        Resource,

        Kubernetes_Cluster,
        Kubernetes_DaemonSet,
        Kubernetes_Deployment,
        Kubernetes_Namespace,
        Kubernetes_Node,
        Kubernetes_PersistentVolume,
        Kubernetes_PersistentVolumeClaim,
        Kubernetes_Pod,
        Kubernetes_ReplicaSet,
        Kubernetes_Service,
        Kubernetes_ServiceAccount,
        Kubernetes_StatefulSet
  )
      {
        return function fromResourceObject(resource, environment) {
          var constructors = {
            "Resources::Kubernetes::Cluster::Cluster": Kubernetes_Cluster,
            "Resources::Kubernetes::Cluster::DaemonSet": Kubernetes_DaemonSet,
            "Resources::Kubernetes::Cluster::Deployment": Kubernetes_Deployment,
            "Resources::Kubernetes::Cluster::Namespace": Kubernetes_Namespace,
            "Resources::Kubernetes::Cluster::Node": Kubernetes_Node,
            "Resources::Kubernetes::Cluster::PersistentVolume": Kubernetes_PersistentVolume,
            "Resources::Kubernetes::Cluster::PersistentVolumeClaim": Kubernetes_PersistentVolumeClaim,
            "Resources::Kubernetes::Cluster::Pod": Kubernetes_Pod,
            "Resources::Kubernetes::Cluster::ReplicaSet": Kubernetes_ReplicaSet,
            "Resources::Kubernetes::Cluster::Service": Kubernetes_Service,
            "Resources::Kubernetes::Cluster::ServiceAccount": Kubernetes_ServiceAccount,
            "Resources::Kubernetes::Cluster::StatefulSet": Kubernetes_StatefulSet
          };

          var c = constructors[resource.type];

          return c ? c.load(resource, environment) : Resource.load(resource, environment);
        };
      }]);

angular.module("designer.data.resources.azure.factory", [
    'designer.model.resource',

    "designer.model.resources.azure.batch.batch_account",
    "designer.model.resources.azure.batch.application",
    "designer.model.resources.azure.batch.pool",

    "designer.model.resources.azure.compute.availability_set",
    "designer.model.resources.azure.compute.virtual_machine",
    "designer.model.resources.azure.compute.virtual_machine_extension",
    "designer.model.resources.azure.compute.virtual_machine_scale_set",

    "designer.model.resources.azure.dns.record_set",
    "designer.model.resources.azure.dns.zone",

    "designer.model.resources.azure.eventhub.eventhub",
    "designer.model.resources.azure.eventhub.namespace",

    "designer.model.resources.azure.mariadb.server",

    "designer.model.resources.azure.mysql.server",

    "designer.model.resources.azure.network.application_gateway",
    "designer.model.resources.azure.network.application_gateway.frontend_ip_configuration",
    "designer.model.resources.azure.network.application_gateway.backend_addresspool",
    "designer.model.resources.azure.network.application_gateway.request_routing_rule",
    "designer.model.resources.azure.network.application_gateway.probe",
    "designer.model.resources.azure.network.application_security_group",
    "designer.model.resources.azure.network.express_route_circuit",
    "designer.model.resources.azure.network.express_route_circuit.peering",
    "designer.model.resources.azure.network.firewall",
    "designer.model.resources.azure.network.ip_configuration",
    "designer.model.resources.azure.network.load_balancer",
    "designer.model.resources.azure.network.load_balancer.backend_addresspool",
    "designer.model.resources.azure.network.load_balancer.frontend_ip_configuration",
    "designer.model.resources.azure.network.load_balancer.probe",
    "designer.model.resources.azure.network.load_balancer.rule",
    "designer.model.resources.azure.network.local_network_gateway",
    "designer.model.resources.azure.network.network_interface",
    "designer.model.resources.azure.network.network_interface.ip_configuration",
    "designer.model.resources.azure.network.network_security_group",
    "designer.model.resources.azure.network.network_security_group.security_rule",
    "designer.model.resources.azure.network.private_endpoint",
    "designer.model.resources.azure.network.public_ip_address",
    "designer.model.resources.azure.network.route",
    "designer.model.resources.azure.network.route_table",
    "designer.model.resources.azure.network.security_rule",
    "designer.model.resources.azure.network.subnet",
    "designer.model.resources.azure.network.virtual_network",
    "designer.model.resources.azure.network.virtual_network_gateway",
    "designer.model.resources.azure.network.virtual_network_gateway.ip_configuration",
    "designer.model.resources.azure.network.virtual_network_gateway_connection",
    "designer.model.resources.azure.network.virtual_network_peering",

    "designer.model.resources.azure.postgresql.server",

    "designer.model.resources.azure.redis.redis_cache",

    "designer.model.resources.azure.resources.resource",
    "designer.model.resources.azure.resources.resource_group",

    "designer.model.resources.azure.servicebus.namespace",
    "designer.model.resources.azure.servicebus.queue",
    "designer.model.resources.azure.servicebus.subscription",
    "designer.model.resources.azure.servicebus.topic",

    "designer.model.resources.azure.storage.storage_account",
  
    "designer.model.resources.azure.sql.data_base",
    "designer.model.resources.azure.sql.server",

  ])
  .service("AzureResourcesFactory",
    [
      "Resource",
      "Azure_BatchAccount",
      "Azure_BatchApplication",
      "Azure_BatchPool",

      "Azure_AvailabilitySet",
      "Azure_VirtualMachine",
      "Azure_VirtualMachineExtension",
      "Azure_VirtualMachine_Scaleset",

      "Azure_DNSRecordSet",
      "Azure_DNSZone",

      "Azure_EHEventHub",
      "Azure_EHNamespace",

      "Azure_MariaDBServer",

      "Azure_MySQLServer",

      "Azure_ApplicationGateway",
      "Azure_ApplicationGateway_FrontendIpConfiguration",
      "Azure_ApplicationGateway_BackendAddressPool",
      "Azure_ApplicationGateway_RequestRoutingRule",
      "Azure_ApplicationGateway_Probe",
      "Azure_ApplicationSecurityGroup",
      "Azure_ExpressRouteCircuit",
      "Azure_ExpressRouteCircuit_Peering",
      "Azure_Firewall",
      "Azure_IpConfiguration",
      "Azure_LoadBalancer",
      "Azure_LoadBalancer_BackendAddressPool",
      "Azure_LoadBalancer_FrontendIpConfiguration",
      "Azure_LoadBalancer_Probe",
      "Azure_LoadBalancer_Rule",
      "Azure_LocalNetworkGateway",
      "Azure_NetworkInterface",
      "Azure_NetworkInterface_IpConfiguration",
      "Azure_NetworkSecurityGroup",
      "Azure_NetworkSecurityGroup_SecurityRule",
      "Azure_PrivateEndpoint",
      "Azure_PublicIpAddress",
      "Azure_Route",
      "Azure_RouteTable",
      "Azure_SecurityRule",
      "Azure_Subnet",
      "Azure_VirtualNetwork",
      "Azure_VirtualNetworkGateway",
      "Azure_VirtualNetworkGateway_IpConfiguration",
      "Azure_VirtualNetworkGatewayConnection",
      "Azure_VirtualNetworkPeering",

      "Azure_PostgreSQLServer",

      "Azure_RedisCache",

      "Azure_Resource",
      "Azure_ResourceGroup",

      "Azure_SBNamespace",
      "Azure_SBQueue",
      "Azure_SBSubscription",
      "Azure_SBTopic",

      "Azure_StorageAccount",
      "Azure_SQL_DataBase",
      "Azure_SQL_Server",
      
      function (Resource,
                Azure_BatchAccount,
                Azure_BatchApplication,
                Azure_BatchPool,
                Azure_AvailabilitySet,
                Azure_VirtualMachine,
                Azure_VirtualMachineExtension,
                Azure_VirtualMachine_Scaleset,
                Azure_DNSRecordSet,
                Azure_DNSZone,
                Azure_EHEventHub,
                Azure_EHNamespace,
                Azure_MariaDBServer,
                Azure_MySQLServer,
                Azure_ApplicationGateway,
                Azure_ApplicationGateway_FrontendIpConfiguration,
                Azure_ApplicationGateway_BackendAddressPool,
                Azure_ApplicationGateway_RequestRoutingRule,
                Azure_ApplicationGateway_Probe,
                Azure_ApplicationSecurityGroup,
                Azure_ExpressRouteCircuit,
                Azure_ExpressRouteCircuit_Peering,
                Azure_Firewall,
                Azure_IpConfiguration,
                Azure_LoadBalancer,
                Azure_LoadBalancer_BackendAddressPool,
                Azure_LoadBalancer_FrontendIpConfiguration,
                Azure_LoadBalancer_Probe,
                Azure_LoadBalancer_Rule,
                Azure_LocalNetworkGateway,
                Azure_NetworkInterface,
                Azure_NetworkInterface_IpConfiguration,
                Azure_NetworkSecurityGroup,
                Azure_NetworkSecurityGroup_SecurityRule,
                Azure_PrivateEndpoint,
                Azure_PublicIpAddress,
                Azure_Route,
                Azure_RouteTable,
                Azure_SecurityRule,
                Azure_Subnet,
                Azure_VirtualNetwork,
                Azure_VirtualNetworkGateway,
                Azure_VirtualNetworkGateway_IpConfiguration,
                Azure_VirtualNetworkGatewayConnection,
                Azure_VirtualNetworkPeering,
                Azure_PostgreSQLServer,
                Azure_RedisCache,
                Azure_Resource,
                Azure_ResourceGroup,
                Azure_SBNamespace,
                Azure_SBQueue,
                Azure_SBSubscription,
                Azure_SBTopic,
                Azure_StorageAccount,
                Azure_SQL_DataBase,
                Azure_SQL_Server) {
        return function fromResourceObject(resource, environment) {
          var constructors = {
            "Resources::Azure::Batch::BatchAccount": Azure_BatchAccount,
            "Resources::Azure::Batch::Application": Azure_BatchApplication,
            "Resources::Azure::Batch::Pool": Azure_BatchPool,

            "Resources::Azure::Compute::AvailabilitySet": Azure_AvailabilitySet,
            "Resources::Azure::Compute::VirtualMachine": Azure_VirtualMachine,
            "Resources::Azure::Compute::VirtualMachineExtension": Azure_VirtualMachineExtension,
            "Resources::Azure::Compute::VirtualMachineScaleSet": Azure_VirtualMachine_Scaleset,

            "Resources::Azure::DNS::RecordSet": Azure_DNSRecordSet,
            "Resources::Azure::DNS::Zone": Azure_DNSZone,

            "Resources::Azure::EventHub::EventHub": Azure_EHEventHub,
            "Resources::Azure::EventHub::Namespace": Azure_EHNamespace,

            "Resources::Azure::MariaDB::Server": Azure_MariaDBServer,

            "Resources::Azure::Mysql::Server": Azure_MySQLServer,

            "Resources::Azure::Network::ApplicationGateway": Azure_ApplicationGateway,
            "Resources::Azure::Network::ApplicationGateway::FrontendIpConfiguration": Azure_ApplicationGateway_FrontendIpConfiguration,
            "Resources::Azure::Network::ApplicationGateway::BackendAddressPool": Azure_ApplicationGateway_BackendAddressPool,
            "Resources::Azure::Network::ApplicationGateway::RequestRoutingRule": Azure_ApplicationGateway_RequestRoutingRule,
            "Resources::Azure::Network::ApplicationGateway::Probe": Azure_ApplicationGateway_Probe,
            "Resources::Azure::Network::ApplicationSecurityGroup": Azure_ApplicationSecurityGroup,
            "Resources::Azure::Network::ExpressRouteCircuit": Azure_ExpressRouteCircuit,
            "Resources::Azure::Network::ExpressRouteCircuit::Peering": Azure_ExpressRouteCircuit_Peering,
            "Resources::Azure::Network::Firewall": Azure_Firewall,
            "Resources::Azure::Network::IpConfiguration": Azure_IpConfiguration,
            "Resources::Azure::Network::LoadBalancer": Azure_LoadBalancer,
            "Resources::Azure::Network::LoadBalancer::BackendAddressPool": Azure_LoadBalancer_BackendAddressPool,
            "Resources::Azure::Network::LoadBalancer::FrontendIpConfiguration": Azure_LoadBalancer_FrontendIpConfiguration,
            "Resources::Azure::Network::LoadBalancer::Probe": Azure_LoadBalancer_Probe,
            "Resources::Azure::Network::LoadBalancer::Rule": Azure_LoadBalancer_Rule,
            "Resources::Azure::Network::LocalNetworkGateway": Azure_LocalNetworkGateway,
            "Resources::Azure::Network::NetworkInterface": Azure_NetworkInterface,
            "Resources::Azure::Network::NetworkInterface::IpConfiguration": Azure_NetworkInterface_IpConfiguration,
            "Resources::Azure::Network::NetworkSecurityGroup": Azure_NetworkSecurityGroup,
            "Resources::Azure::Network::NetworkSecurityGroup::SecurityRule": Azure_NetworkSecurityGroup_SecurityRule,
            "Resources::Azure::Network::PrivateEndpoint": Azure_PrivateEndpoint,
            "Resources::Azure::Network::PublicIpAddress": Azure_PublicIpAddress,
            "Resources::Azure::Network::Route": Azure_Route,
            "Resources::Azure::Network::RouteTable": Azure_RouteTable,
            "Resources::Azure::Network::SecurityRule": Azure_SecurityRule,
            "Resources::Azure::Network::Subnet": Azure_Subnet,
            "Resources::Azure::Network::VirtualNetwork": Azure_VirtualNetwork,
            "Resources::Azure::Network::VirtualNetworkGateway": Azure_VirtualNetworkGateway,
            "Resources::Azure::Network::VirtualNetworkGateway::IpConfiguration": Azure_VirtualNetworkGateway_IpConfiguration,
            "Resources::Azure::Network::VirtualNetworkGatewayConnection": Azure_VirtualNetworkGatewayConnection,
            "Resources::Azure::Network::VirtualNetworkPeering": Azure_VirtualNetworkPeering,

            "Resources::Azure::Postgresql::Server": Azure_PostgreSQLServer,

            "Resources::Azure::Redis::RedisCache": Azure_RedisCache,

            "Resources::Azure::Resources::Resource": Azure_Resource,
            "Resources::Azure::Resources::ResourceGroup": Azure_ResourceGroup,

            "Resources::Azure::ServiceBus::Namespace": Azure_SBNamespace,
            "Resources::Azure::ServiceBus::Queue": Azure_SBQueue,
            "Resources::Azure::ServiceBus::Subscription":  Azure_SBSubscription,
            "Resources::Azure::ServiceBus::Topic": Azure_SBTopic,

            "Resources::Azure::Storage::StorageAccount": Azure_StorageAccount,

            "Resources::Azure::SQL::DataBase": Azure_SQL_DataBase,
            "Resources::Azure::SQL::Server": Azure_SQL_Server
          };

          var c = constructors[resource.type];

          return c ? c.load(resource, environment) : Resource.load(resource, environment);
        };
      }]);

angular.module('designer.model.resources.ibm.availabilityzone', ['designer.model.resource'])
  .factory('IBM_AvailabilityZone', ["Resource", function(Resource) {
    return {
      load: function(resource, data) {
        resource = Resource.load(resource);
        resource.type_name = 'AVAILABILITY ZONE';

        resource.info = function() {
          var info = {};

          info.subnets = data.subnets;

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module("designer.data.resources.ibm.factory", [
  'designer.model.resource',

  "designer.model.resources.ibm.ec2.address",
  "designer.model.resources.ibm.ec2.customer_gateway",
  "designer.model.resources.ibm.ec2.dhcp_options",
  "designer.model.resources.ibm.ec2.egress_only_internet_gateway",
  "designer.model.resources.ibm.ec2.instance",
  "designer.model.resources.ibm.ec2.internet_gateway",
  "designer.model.resources.ibm.ec2.nat_gateway",
  "designer.model.resources.ibm.ec2.network_acl",
  "designer.model.resources.ibm.ec2.network_interface",
  "designer.model.resources.ibm.ec2.placement_group",
  "designer.model.resources.ibm.ec2.route_table",
  "designer.model.resources.ibm.ec2.security_group",
  "designer.model.resources.ibm.ec2.security_group_permission",
  "designer.model.resources.ibm.ec2.subnet",
  "designer.model.resources.ibm.ec2.transitgateway",
  "designer.model.resources.ibm.ec2.transitgatewayattachment",
  "designer.model.resources.ibm.ec2.transitgatewayroutetable",
  "designer.model.resources.ibm.ec2.transitgatewayvpcattachment",
  "designer.model.resources.ibm.ec2.volume",
  "designer.model.resources.ibm.ec2.vpc",
  "designer.model.resources.ibm.ec2.vpc_endpoint",
  "designer.model.resources.ibm.ec2.vpc_peering_connection",
  "designer.model.resources.ibm.ec2.vpn_connection",
  "designer.model.resources.ibm.ec2.vpn_gateway",

  "designer.model.resources.ibm.elastic_load_balancing.load_balancer",
  "designer.model.resources.ibm.elastic_load_balancing_v2.application_load_balancer",
  "designer.model.resources.ibm.elastic_load_balancing_v2.network_load_balancer",
  "designer.model.resources.ibm.elastic_load_balancing_v2.listener",
  "designer.model.resources.ibm.elastic_load_balancing_v2.rule",
  "designer.model.resources.ibm.elastic_load_balancing_v2.target_group",
  "designer.model.resources.ibm.elasticache.cache_cluster",
  "designer.model.resources.ibm.elasticache.cache_node",
  "designer.model.resources.ibm.elasticache.parameter_group",
  "designer.model.resources.ibm.elasticache.subnet_group",
  "designer.model.resources.ibm.rds.db_instance",
  "designer.model.resources.ibm.rds.db_security_group",
  "designer.model.resources.ibm.rds.db_subnet_group",
  "designer.model.resources.ibm.route53.hosted_zone",
  "designer.model.resources.ibm.route53.resource_record_set",
  "designer.model.resources.ibm.s3.bucket",
])
  .service("IBMResourcesFactory",
    [
      "Resource",

      "IBM_Address",
      "IBM_CustomerGateway",
      "IBM_DHCPOptions",
      "IBM_EgressOnlyInternetGateway",
      "IBM_Instance",
      "IBM_InternetGateway",
      "IBM_NATGateway",
      "IBM_NetworkACL",
      "IBM_NetworkInterface",
      "IBM_PlacementGroup",
      "IBM_RouteTable",
      "IBM_SecurityGroup",
      "IBM_SecurityGroupPermission",
      "IBM_Subnet",
      "IBM_TransitGateway",
      "IBM_TransitGatewayAttachment",
      "IBM_TransitGatewayRouteTable",
      "IBM_TransitGatewayVPCAttachment",
      "IBM_Volume",
      "IBM_VPC",
      "IBM_VPCEndpoint",
      "IBM_VpcPeeringConnection",
      "IBM_VpnConnection",
      "IBM_VpnGateway",

      "IBM_LoadBalancer",

      "IBM_ApplicationLoadBalancer",
      "IBM_NetworkLoadBalancer",
      "IBM_ALBListener",
      "IBM_ALBRule",
      "IBM_ALBTargetGroup",

      "IBM_ElastiCacheCacheCluster",
      "IBM_ElastiCacheCacheNode",
      "IBM_ElastiCacheParameterGroup",
      "IBM_ElastiCacheSubnetGroup",

      "IBM_DBInstance",
      "IBM_DBSecurityGroup",
      "IBM_DBSubnetGroup",

      "IBM_Route53HostedZone",
      "IBM_Route53ResourceRecordSet",

      "IBM_S3Bucket",

      function(
        Resource,

        IBM_Address,
        IBM_CustomerGateway,
        IBM_DHCPOptions,
        IBM_EgressOnlyInternetGateway,
        IBM_Instance,
        IBM_InternetGateway,
        IBM_NATGateway,
        IBM_NetworkACL,
        IBM_NetworkInterface,
        IBM_PlacementGroup,
        IBM_RouteTable,
        IBM_SecurityGroup,
        IBM_SecurityGroupPermission,
        IBM_Subnet,
        IBM_TransitGateway,
        IBM_TransitGatewayAttachment,
        IBM_TransitGatewayRouteTable,
        IBM_TransitGatewayVPCAttachment,
        IBM_Volume,
        IBM_VPC,
        IBM_VPCEndpoint,
        IBM_VpcPeeringConnection,
        IBM_VpnConnection,
        IBM_VpnGateway,

        IBM_LoadBalancer,

        IBM_ApplicationLoadBalancer,
        IBM_NetworkLoadBalancer,
        IBM_ALBListener,
        IBM_ALBRule,
        IBM_ALBTargetGroup,

        IBM_ElastiCacheCacheCluster,
        IBM_ElastiCacheCacheNode,
        IBM_ElastiCacheParameterGroup,
        IBM_ElastiCacheSubnetGroup,

        IBM_DBInstance,
        IBM_DBSecurityGroup,
        IBM_DBSubnetGroup,

        IBM_Route53HostedZone,
        IBM_Route53ResourceRecordSet,

        IBM_S3Bucket
  )
      {
        return function fromResourceObject(resource, environment) {
          var constructors = {
            "Resources::IBM::EC2::Address": IBM_Address,
            "Resources::IBM::EC2::CustomerGateway": IBM_CustomerGateway,
            "Resources::IBM::EC2::DHCPOptions": IBM_DHCPOptions,
            "Resources::IBM::EC2::EgressOnlyInternetGateway": IBM_EgressOnlyInternetGateway,
            "Resources::IBM::EC2::Instance": IBM_Instance,
            "Resources::IBM::EC2::InternetGateway": IBM_InternetGateway,
            "Resources::IBM::EC2::NATGateway": IBM_NATGateway,
            "Resources::IBM::EC2::NetworkACL": IBM_NetworkACL,
            "Resources::IBM::EC2::NetworkInterface": IBM_NetworkInterface,
            "Resources::IBM::EC2::PlacementGroup": IBM_PlacementGroup,
            "Resources::IBM::EC2::RouteTable": IBM_RouteTable,
            "Resources::IBM::EC2::SecurityGroup": IBM_SecurityGroup,
            "Resources::IBM::EC2::SecurityGroupPermission": IBM_SecurityGroupPermission,
            "Resources::IBM::EC2::Subnet": IBM_Subnet,
            "Resources::IBM::EC2::TransitGateway": IBM_TransitGateway,
            "Resources::IBM::EC2::TransitGatewayAttachment": IBM_TransitGatewayAttachment,
            "Resources::IBM::EC2::TransitGatewayRouteTable": IBM_TransitGatewayRouteTable,
            "Resources::IBM::EC2::TransitGatewayVPCAttachment": IBM_TransitGatewayVPCAttachment,
            "Resources::IBM::EC2::Volume": IBM_Volume,
            "Resources::IBM::EC2::VPC": IBM_VPC,
            "Resources::IBM::EC2::VPCEndpoint": IBM_VPCEndpoint,
            "Resources::IBM::EC2::VPCPeeringConnection": IBM_VpcPeeringConnection,
            "Resources::IBM::EC2::VPNConnection": IBM_VpnConnection,
            "Resources::IBM::EC2::VPNGateway": IBM_VpnGateway,

            "Resources::IBM::ElasticLoadBalancing::LoadBalancer": IBM_LoadBalancer,

            "Resources::IBM::ElasticLoadBalancingV2::ApplicationLoadBalancer": IBM_ApplicationLoadBalancer,
            "Resources::IBM::ElasticLoadBalancingV2::NetworkLoadBalancer": IBM_NetworkLoadBalancer,
            "Resources::IBM::ElasticLoadBalancingV2::Listener": IBM_ALBListener,
            "Resources::IBM::ElasticLoadBalancingV2::Rule": IBM_ALBRule,
            "Resources::IBM::ElasticLoadBalancingV2::TargetGroup": IBM_ALBTargetGroup,

            "Resources::IBM::ElastiCache::CacheCluster": IBM_ElastiCacheCacheCluster,
            "Resources::IBM::ElastiCache::CacheNode": IBM_ElastiCacheCacheNode,
            "Resources::IBM::ElastiCache::ParameterGroup": IBM_ElastiCacheParameterGroup,
            "Resources::IBM::ElastiCache::CacheSubnetGroup": IBM_ElastiCacheSubnetGroup,
            
            "Resources::IBM::RDS::DBInstance": IBM_DBInstance,
            "Resources::IBM::RDS::DBSecurityGroup": IBM_DBSecurityGroup,
            "Resources::IBM::RDS::DBSubnetGroup": IBM_DBSubnetGroup,

            "Resources::IBM::Route53::HostedZone": IBM_Route53HostedZone,
            "Resources::IBM::Route53::ResourceRecordSet": IBM_Route53ResourceRecordSet,

            "Resources::IBM::S3::Bucket": IBM_S3Bucket

          };

          var c = constructors[resource.type];

          return c ? c.load(resource, environment) : Resource.load(resource, environment);
        };
      }]);

angular
  .module("designer.workspace.canvases.3dview", [
    "designer.workspace.canvases.jointjs.3dview.paper",
    "designer.workspace.canvases.jointjs.3dview.views.linkview3d",
    "designer.workspace.canvases.jointjs.3dview.views.elementview3d",
    "designer.configuration",
    "designer.workspace.canvases.jointjs.3dview.shapes.modelFactory",
  ])
  .directive("threeJsCanvas", ["$rootScope", "Graph", "Paper3D", "LinkView3D", "ElementView3D", "DesignerState", "DesignerConfig", "ModelFactory",
    function ($rootScope, Graph, Paper3D, LinkView3D, ElementView3D, DesignerState, DesignerConfig, modelFactory) {
      return {
        templateUrl: "/designer/workspace/canvases/3dview/canvas.html",
        replace: true,
        controllerAs: "ThreeCanvas",
        controller: ["$scope", "$element", "$attrs",
          function ($scope, $element, $attrs) {
            this.environment = $scope.Designer.environment;
            this.view = this.environment.current_view;
            this.initialized = false;

            // WEBGL and feature flags
            $scope.WEBGL = THREE.WEBGL.isWebGLAvailable();
            $scope.WEBGL2 = THREE.WEBGL.isWebGL2Available();
            $scope.enable3DView = DesignerConfig.get("enable3DView");

            // Check for WEBGL/WEBGL2 support before instantiating Paper3D.
            if (!$scope.WEBGL || !$scope.enable3DView) {
              return;
            }

            if (!this.view.model) return;

            this.paper3d = new Paper3D({
              elementView: ElementView3D,
              linkView: LinkView3D,
              viewName: this.view.name,
              model: new Graph(),
            });

            this.paper3d.setEventHandlers();
          },
        ],
        link: function (scope, element, attrs, ctrl) {
          /**
           * Switch to JointJs Canvas
           */
          scope.switchToJointJsCanvas = function () {
            var value = DesignerState.get("display3DView");
            DesignerState.set("display3DView", !value);
            $rootScope.$broadcast("viewChanged");
            ctrl.view.canvas = "jointjs";
          };

          // Only initialize the scene when user chooses to do so
          // Don't do it otherwise as we will be unnecessarily consuming resources
          scope.initialize = function () {
            if (!ctrl.initialized) {
              ctrl.paper3d = new Paper3D({
                elementView: ElementView3D,
                linkView: LinkView3D,
                viewName: ctrl.view.name,
                model: new Graph(),
                paper2d: ctrl.environment.paper,
              });
  
              ctrl.paper3d.setEventHandlers();
              ctrl.paper3d.paper2d = ctrl.environment.paper;

              scope._render();
              ctrl.initialized = true;
            }
          }

          /**
           * Snap to center
           */
          scope.snapToCenter = function () {
            ctrl.paper3d.snapToCenter();
          };

          scope.toggleShadows = function () {
            ctrl.paper3d.toggleShadows();
          };

          // Check WEBGL/WEBGL2 support before listening to events
          if (!scope.WEBGL || !scope.enable3DView) {
            return;
          }

          if (!ctrl.view.model) return;

          /**
           * When a different view is selected set the new model on paper
           */
          scope._viewSelected3D = function (event, view) {
            if (view.canvas !== "jointjs" && view.canvas !== "3d") return;

            // Don't switch the canvas type
            view.canvas = ctrl.view.canvas;
            ctrl.view = view;

            ctrl.paper3d.options.viewName = ctrl.view.name;
            ctrl.paper3d.setEventHandlers();
            ctrl.paper3d.model.resetCells([]);

            scope._render()
          };

          /**
           * When the render is done, resize the canvas and enable the 3D view oction controls
           */
          scope._render = async function () {
            if (!ctrl.paper3d) return;

            // First load all the models
            if (!modelFactory.loaded) {
              await modelFactory.preLoadModels();
            }

            const { paper3d } = ctrl;
            const { model, sceneManager } = paper3d;
            model.resetCells([]);
            model.addCells(ctrl.view.model.allCells());

            sceneManager.elementCount = model.getElements().length;
            sceneManager.linkCount = model.getLinks().length;
            sceneManager.meshCount = 0;
            sceneManager.link3dCount = 0;

            sceneManager.resizeHandler();
            sceneManager.enable3DControls();
          };

          /**
           * Event handlers
           */
          scope._toggleLinks = function () {
            if (!ctrl.paper3d) return;
            ctrl.paper3d.toggleLinks();
          };

          scope._highlightConnected = function (event, resource) {
            ctrl.paper3d.highlightConnected(resource);
          };

          scope._unhighlightAll = function () {
            ctrl.paper3d.unhighlightAll();
          };

          scope._toggleNames = function () {
            if (!ctrl.paper3d) return;
            ctrl.paper3d.toggleNames();
          };

          scope.resourceSelected = function (event, resource) {
            ctrl.paper3d.showCSSBox(resource);
          }

          scope.resizeHandler = function (event) {
            const { sceneManager } = ctrl.paper3d;
            sceneManager.resizeHandler();
          }

          scope.$on('$destroy', function() {
            ctrl.paper3d.destroyScene();
          });

          /**
           * Listent to events
           */
          scope.$on("toggle:connections", scope._toggleLinks);
          scope.$on("connected:highlight", scope._highlightConnected);
          scope.$on("connected:unhighlight", scope._unhighlightAll);
          scope.$on("resource:unhighlight", scope._unhighlightAll);
          scope.$on("toggle:labels", scope._toggleNames);
          scope.$on("canvas:resize", scope.resizeHandler);

          scope.$on("view:selected", scope._viewSelected3D);
          scope.$on("viewChanged", scope.initialize);
          scope.$on("view:ready", scope._render);
        },
      };
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.paper", [
    "designer.workspace.canvases.jointjs.3dview.scene",
  ])
  .service("Paper3D", [
    "$rootScope",
    "Scene",
    "DesignerState",
    function ($rootScope, sceneManager, DesignerState) {
      const onCellAdded = function (cell) {
        switch (cell.attributes.type) {
          case "resource":
          case "container":
            this.sceneManager.createShape(cell);
            break;
          case "link":
            this.sceneManager.createLink(cell);
            break;
        }
        joint.dia.Paper.prototype.onCellAdded.apply(this, arguments);
      };

      /*
      Get the group, find the to be removed meshes and texts by cid and then remove them
      */
      const removeView = function (cell) {
        const { group } = this.sceneManager;
        const meshes = group.children.filter((c) => c.name === cell.cid);
        meshes.forEach((mesh) => {
          group.remove(mesh);
        });
        this.sceneManager.meshCount = 0;
        joint.dia.Paper.prototype.removeView.apply(this, arguments);
      };

      const resetViews = function (paper, previousData) {
        joint.dia.Paper.prototype.resetViews.apply(this, arguments);
        if (!this.sceneManager) return;
        const { group } = this.sceneManager;
        for (var i = group.children.length - 1; i >= 0; i--) {
          group.remove(group.children[i]);
        }
      };

      /*
      Set the model to be used on the paper
      */
      const setEventHandlers = function () {
        // Reset listeners
        this.model.off();
        if (!this.is3DViewSupported()) return;
        this.model.on("add", this.onCellAdded, this);
        this.model.on("updated", this.updateView, this);
        this.model.on("remove", this.removeView, this);
        this.model.on("reset", this.resetViews, this);
        this.model.on("sort", this._onSort, this);
        this.model.on("batch:stop", this._onBatchStop, this);
      };

      /*
      Update mesh position, link routing when model changes
      */
      const updateView = function (view, flag, opt) {
        switch (view.model.attributes.type) {
          case "resource":
          case "container":
            this.sceneManager.updateShape(view);
            break;
          case "link":
            this.sceneManager.updateLink(view);
            break;
        }
      };

      /*
      Create an empty scene with a plane, grid and lighting
      */
      const initialize = function () {
        joint.dia.Paper.prototype.initialize.apply(this, arguments);
        this.highlighted = [];
        this.display_connections = false;
        if (!this.sceneCreated) {
          this.sceneManager = sceneManager;
          this.sceneManager.createScene(this);
        }
      };

      /*
      Paper3D Events
      */
      const toggleLinks = function () {
        this.model.getLinks().forEach((link) => {
          var view = this.findViewByModel(link);
          var visibility = DesignerState.get("displayConnections");
          this.display_connections = visibility;
          if (view) {
            view.toggleVisibility(visibility);
          }
        });
      };

      const toggleNames = function () {
        const value = DesignerState.get("displayLabels");
        this.model.getElements().forEach((model) => {
          const { type } = model.attributes;
          switch (type) {
            case "resource":
              if (model.mesh && model.mesh.labels) {
                model.mesh.labels.forEach((label) => {
                  label.visible = value;
                });
              }
          }
        });
      };

      const destroyScene = function () {
        this.sceneManager.destroyScene();
      }

      const highlightConnected = function (resource) {
        var resources = resource.highlightableConnections();

        resources.forEach((r) => {
          if (!r.hidden) {
            var cells = this.model.getCellsByResourceId(r.id);

            cells.forEach((cell) => {
              var view = this.findViewByModel(cell);
              view.highlight(this.sceneManager.outlinePass);
              this.highlighted.push(view);
            });
          }
        });
      };

      const showLinks = function (resource) {
        const { outlinePass } = this.sceneManager;

        var view = this.findViewByModel(resource);
        if (view) {
          outlinePass.selectedObjects = [];
          outlinePass.clicked = undefined;
          view.highlight(outlinePass, true);
        }

        if (this.display_connections) return;
        this.hideAllLinks();

        this.model.getLinks().forEach((link) => {
          const { source, target } = link.attributes;
          if (resource.id === source.id || resource.id === target.id) {
            this.findViewByModel(link).show();
          }
        });
      };

      // Hide links
      const hideLinks = function (resource) {
        if (this.display_connections) return;
        this.hideAllLinks();
      };

      const unhighlightAll = function () {
        const { outlinePass } = this.sceneManager;
        this.highlighted.forEach((view) => {
          view.unhighlight(outlinePass);
          // Do this to prevent the bug that hides the meshes when outline passs is applied
          view.mesh.visible = true;
        });
        this.highlighted = [];
      };

      const unhighlightClicks = function () {
        // Unhighlight all meshes
        const { outlinePass } = this.sceneManager;
        outlinePass.clicked = undefined;
        this.model.getElements().forEach((model) => {
          const meshView = this.findViewByModel(model);
          if (meshView) {
            meshView.unhighlight(outlinePass);
            // Do this to prevent the bug that hides the meshes when outline passs is applied
            meshView.mesh.visible = true;
          }
        });
      }

      const hideAllLinks = function () {
        if (this.display_connections) return;
        this.model.getLinks().forEach((link) => {
          const linkView = this.findViewByModel(link);
          if (linkView) {
            linkView.hide();
          }
        });
      };

      const isExtView = function () {
        const viewName = "Extended Infrastructure";
        return this.options.viewName === viewName;
      };

      const is3DViewSupported = function () {
        const notSupportedViews = ["Security Group", "List", "Container"];
        return !notSupportedViews.includes(this.options.viewName);
      };

      const snapToCenter = function() {
        this.sceneManager.resetCameraPosition();
      }

      const toggleShadows = function () {
        this.sceneManager.toggleDirectionalLightShadows();
      }

      const showCSSBox = function (resource) {
        this.sceneManager.showCSSBox(resource);
      }

      const Paper3D = joint.dia.Paper.extend({
        initialize,
        onCellAdded,
        updateView,
        toggleLinks,
        highlightConnected,
        unhighlightAll,
        showLinks,
        hideLinks,
        hideAllLinks,
        removeView,
        destroyScene,
        resetViews,
        setEventHandlers,
        toggleNames,
        isExtView,
        is3DViewSupported,
        snapToCenter,
        toggleShadows,
        showCSSBox,
        unhighlightClicks
      });

      return Paper3D;
    },
  ]);

angular.module("designer.data.resources.gcp.factory", [
  'designer.model.resource',
  'designer.model.resources.gcp.compute.address',
  'designer.model.resources.gcp.compute.autoscaler',
  'designer.model.resources.gcp.compute.backendbucket',
  'designer.model.resources.gcp.compute.backendservice',
  'designer.model.resources.gcp.compute.disk',
  'designer.model.resources.gcp.compute.disktype',
  'designer.model.resources.gcp.compute.externalvpngateway',
  'designer.model.resources.gcp.compute.firewall',
  'designer.model.resources.gcp.compute.forwardingrule',
  'designer.model.resources.gcp.compute.globaladdress',
  'designer.model.resources.gcp.compute.globalforwardingrule',
  'designer.model.resources.gcp.compute.globalnetworkendpointgroup',
  'designer.model.resources.gcp.compute.healthcheck',
  'designer.model.resources.gcp.compute.healthcheckservice',
  'designer.model.resources.gcp.compute.httphealthcheck',
  'designer.model.resources.gcp.compute.httpshealthcheck',
  'designer.model.resources.gcp.compute.instance',
  'designer.model.resources.gcp.compute.instancegroup',
  'designer.model.resources.gcp.compute.instancegroupmanager',
  'designer.model.resources.gcp.compute.interconnect',
  'designer.model.resources.gcp.compute.interconnectattachment',
  'designer.model.resources.gcp.compute.natgateway',
  'designer.model.resources.gcp.compute.network',
  'designer.model.resources.gcp.compute.networkendpointgroup',
  'designer.model.resources.gcp.compute.nodegroup',
  'designer.model.resources.gcp.compute.notificationendpoint',
  'designer.model.resources.gcp.compute.packetmirroring',
  'designer.model.resources.gcp.compute.regionautoscaler',
  'designer.model.resources.gcp.compute.regionbackendservice',
  'designer.model.resources.gcp.compute.regiondisk',
  'designer.model.resources.gcp.compute.regiondisktype',
  'designer.model.resources.gcp.compute.regionhealthcheck',
  'designer.model.resources.gcp.compute.regioninstancegroup',
  'designer.model.resources.gcp.compute.regioninstancegroupmanager',
  'designer.model.resources.gcp.compute.regionnetworkendpointgroup',
  'designer.model.resources.gcp.compute.regionsslcertificate',
  'designer.model.resources.gcp.compute.regiontargethttpproxy',
  'designer.model.resources.gcp.compute.regiontargethttpsproxy',
  'designer.model.resources.gcp.compute.regionurlmap',
  'designer.model.resources.gcp.compute.route',
  'designer.model.resources.gcp.compute.router',
  'designer.model.resources.gcp.compute.securitypolicy',
  'designer.model.resources.gcp.compute.serviceattachment',
  'designer.model.resources.gcp.compute.sslcertificate',
  'designer.model.resources.gcp.compute.sslpolicy',
  'designer.model.resources.gcp.compute.subnetwork',
  'designer.model.resources.gcp.compute.targetgrpcproxy',
  'designer.model.resources.gcp.compute.targethttpproxy',
  'designer.model.resources.gcp.compute.targethttpsproxy',
  'designer.model.resources.gcp.compute.targetinstance',
  'designer.model.resources.gcp.compute.targetpool',
  'designer.model.resources.gcp.compute.targetsslproxy',
  'designer.model.resources.gcp.compute.targettcpproxy',
  'designer.model.resources.gcp.compute.targetvpngateway',
  'designer.model.resources.gcp.compute.urlmap',
  'designer.model.resources.gcp.compute.vpngateway',
  'designer.model.resources.gcp.compute.vpntunnel',
  'designer.model.resources.gcp.dns.managedzone',
  'designer.model.resources.gcp.memorystore.instance',
  'designer.model.resources.gcp.sql.instance',
  'designer.model.resources.gcp.storage.bucket'
])
  .service("GCPResourcesFactory",
    [
      'Resource',
      'GCP_ComputeAddress',
      'GCP_ComputeAutoscaler',
      'GCP_ComputeBackendBucket',
      'GCP_ComputeBackendService',
      'GCP_ComputeDisk',
      'GCP_ComputeDiskType',
      'GCP_ComputeExternalVpnGateway',
      'GCP_ComputeFirewall',
      'GCP_ComputeForwardingRule',
      'GCP_ComputeGlobalAddress',
      'GCP_ComputeGlobalForwardingRule',
      'GCP_ComputeGlobalNetworkEndpointGroup',
      'GCP_ComputeHealthCheck',
      'GCP_ComputeHealthCheckService',
      'GCP_ComputeHttpHealthCheck',
      'GCP_ComputeHttpsHealthCheck',
      'GCP_ComputeInstance',
      'GCP_ComputeInstanceGroup',
      'GCP_ComputeInstanceGroupManager',
      'GCP_ComputeInterconnect',
      'GCP_ComputeInterconnectAttachment',
      'GCP_ComputeNATGateway',
      'GCP_ComputeNetwork',
      'GCP_ComputeNetworkEndpointGroup',
      'GCP_ComputeNodeGroup',
      'GCP_ComputeNotificationEndpoint',
      'GCP_ComputePacketMirroring',
      'GCP_ComputeRegionAutoscaler',
      'GCP_ComputeRegionBackendService',
      'GCP_ComputeRegionDisk',
      'GCP_ComputeRegionDiskType',
      'GCP_ComputeRegionHealthCheck',
      'GCP_ComputeRegionInstanceGroup',
      'GCP_ComputeRegionInstanceGroupManager',
      'GCP_ComputeRegionNetworkEndpointGroup',
      'GCP_ComputeRegionSslCertificate',
      'GCP_ComputeRegionTargetHttpProxy',
      'GCP_ComputeRegionTargetHttpsProxy',
      'GCP_ComputeRegionUrlMap',
      'GCP_ComputeRoute',
      'GCP_ComputeRouter',
      'GCP_ComputeSecurityPolicy',
      'GCP_ComputeServiceAttachment',
      'GCP_ComputeSslCertificate',
      'GCP_ComputeSslPolicy',
      'GCP_ComputeSubnetwork',
      'GCP_ComputeTargetGrpcProxy',
      'GCP_ComputeTargetHttpProxy',
      'GCP_ComputeTargetHttpsProxy',
      'GCP_ComputeTargetInstance',
      'GCP_ComputeTargetPool',
      'GCP_ComputeTargetSslProxy',
      'GCP_ComputeTargetTcpProxy',
      'GCP_ComputeTargetVpnGateway',
      'GCP_ComputeUrlMap',
      'GCP_ComputeVpnGateway',
      'GCP_ComputeVpnTunnel',
      'GCP_DNSManagedZone',
      'GCP_MemoryStoreInstance',
      'GCP_SQLInstance',
      'GCP_StorageBucket',

      function(
        Resource,
        GCP_ComputeAddress,
        GCP_ComputeAutoscaler,
        GCP_ComputeBackendBucket,
        GCP_ComputeBackendService,
        GCP_ComputeDisk,
        GCP_ComputeDiskType,
        GCP_ComputeExternalVpnGateway,
        GCP_ComputeFirewall,
        GCP_ComputeForwardingRule,
        GCP_ComputeGlobalNetworkEndpointGroup,
        GCP_ComputeGlobalAddress,
        GCP_ComputeGlobalForwardingRule,
        GCP_ComputeHealthCheck,
        GCP_ComputeHealthCheckService,
        GCP_ComputeHttpHealthCheck,
        GCP_ComputeHttpsHealthCheck,
        GCP_ComputeInstance,
        GCP_ComputeInstanceGroup,
        GCP_ComputeInstanceGroupManager,
        GCP_ComputeInterconnect,
        GCP_ComputeInterconnectAttachment,
        GCP_ComputeNATGateway,
        GCP_ComputeNetwork,
        GCP_ComputeNetworkEndpointGroup,
        GCP_ComputeNodeGroup,
        GCP_ComputeNotificationEndpoint,
        GCP_ComputePacketMirroring,
        GCP_ComputeRegionAutoscaler,
        GCP_ComputeRegionBackendService,
        GCP_ComputeRegionDisk,
        GCP_ComputeRegionDiskType,
        GCP_ComputeRegionHealthCheck,
        GCP_ComputeRegionInstanceGroup,
        GCP_ComputeRegionInstanceGroupManager,
        GCP_ComputeRegionNetworkEndpointGroup,
        GCP_ComputeRegionSslCertificate,
        GCP_ComputeRegionTargetHttpProxy,
        GCP_ComputeRegionTargetHttpsProxy,
        GCP_ComputeRegionUrlMap,
        GCP_ComputeRoute,
        GCP_ComputeRouter,
        GCP_ComputeSecurityPolicy,
        GCP_ComputeServiceAttachment,
        GCP_ComputeSslCertificate,
        GCP_ComputeSslPolicy,
        GCP_ComputeSubnetwork,
        GCP_ComputeTargetGrpcProxy,
        GCP_ComputeTargetHttpProxy,
        GCP_ComputeTargetHttpsProxy,
        GCP_ComputeTargetInstance,
        GCP_ComputeTargetPool,
        GCP_ComputeTargetSslProxy,
        GCP_ComputeTargetTcpProxy,
        GCP_ComputeTargetVpnGateway,
        GCP_ComputeUrlMap,
        GCP_ComputeVpnGateway,
        GCP_ComputeVpnTunnel,
        GCP_DNSManagedZone,
        GCP_MemoryStoreInstance,
        GCP_SQLInstance,
        GCP_StorageBucket
      )
      {
        return function fromResourceObject(resource, environment) {
          var constructors = {
            'Resources::GCP::Compute::Address': GCP_ComputeAddress,
            'Resources::GCP::Compute::Autoscaler': GCP_ComputeAutoscaler,
            'Resources::GCP::Compute::BackendBucket': GCP_ComputeBackendBucket,
            'Resources::GCP::Compute::BackendService': GCP_ComputeBackendService,
            'Resources::GCP::Compute::Disk': GCP_ComputeDisk,
            'Resources::GCP::Compute::DiskType': GCP_ComputeDiskType,
            'Resources::GCP::Compute::ExternalVPNGateway': GCP_ComputeExternalVpnGateway,
            'Resources::GCP::Compute::Firewall': GCP_ComputeFirewall,
            'Resources::GCP::Compute::ForwardingRule': GCP_ComputeForwardingRule,
            'Resources::GCP::Compute::GlobalAddress': GCP_ComputeGlobalAddress,
            'Resources::GCP::Compute::GlobalForwardingRule': GCP_ComputeGlobalForwardingRule,
            'Resources::GCP::Compute::GlobalNetworkEndpointGroup': GCP_ComputeGlobalNetworkEndpointGroup,
            'Resources::GCP::Compute::HealthCheck': GCP_ComputeHealthCheck,
            'Resources::GCP::Compute::HealthCheckService': GCP_ComputeHealthCheckService,
            'Resources::GCP::Compute::HTTPHealthCheck': GCP_ComputeHttpHealthCheck,
            'Resources::GCP::Compute::HTTPSHealthCheck': GCP_ComputeHttpsHealthCheck,
            'Resources::GCP::Compute::Instance': GCP_ComputeInstance,
            'Resources::GCP::Compute::InstanceGroup': GCP_ComputeInstanceGroup,
            'Resources::GCP::Compute::InstanceGroupManager': GCP_ComputeInstanceGroupManager,
            'Resources::GCP::Compute::Interconnect': GCP_ComputeInterconnect,
            'Resources::GCP::Compute::InterconnectAttachment': GCP_ComputeInterconnectAttachment,
            'Resources::GCP::Compute::NATGateway': GCP_ComputeNATGateway,
            'Resources::GCP::Compute::Network': GCP_ComputeNetwork,
            'Resources::GCP::Compute::NetworkEndpointGroup': GCP_ComputeNetworkEndpointGroup,
            'Resources::GCP::Compute::NodeGroup': GCP_ComputeNodeGroup,
            'Resources::GCP::Compute::NotificationEndpoint': GCP_ComputeNotificationEndpoint,
            'Resources::GCP::Compute::PacketMirroring': GCP_ComputePacketMirroring,
            'Resources::GCP::Compute::RegionAutoscaler': GCP_ComputeRegionAutoscaler,
            'Resources::GCP::Compute::RegionBackendService': GCP_ComputeRegionBackendService,
            'Resources::GCP::Compute::RegionDisk': GCP_ComputeRegionDisk,
            'Resources::GCP::Compute::RegionDiskType': GCP_ComputeRegionDiskType,
            'Resources::GCP::Compute::RegionHealthCheck': GCP_ComputeRegionHealthCheck,
            'Resources::GCP::Compute::RegionInstanceGroup': GCP_ComputeRegionInstanceGroup,
            'Resources::GCP::Compute::RegionInstanceGroupManager': GCP_ComputeRegionInstanceGroupManager,
            'Resources::GCP::Compute::RegionNetworkEndpointGroup': GCP_ComputeRegionNetworkEndpointGroup,
            'Resources::GCP::Compute::RegionSSLCertificate': GCP_ComputeRegionSslCertificate,
            'Resources::GCP::Compute::RegionTargetHTTPProxy': GCP_ComputeRegionTargetHttpProxy,
            'Resources::GCP::Compute::RegionTargetHTTPSProxy': GCP_ComputeRegionTargetHttpsProxy,
            'Resources::GCP::Compute::RegionURLMap': GCP_ComputeRegionUrlMap,
            'Resources::GCP::Compute::Route': GCP_ComputeRoute,
            'Resources::GCP::Compute::Router': GCP_ComputeRouter,
            'Resources::GCP::Compute::SecurityPolicy': GCP_ComputeSecurityPolicy,
            'Resources::GCP::Compute::ServiceAttachment': GCP_ComputeServiceAttachment,
            'Resources::GCP::Compute::SSLCertificate': GCP_ComputeSslCertificate,
            'Resources::GCP::Compute::SSLPolicy': GCP_ComputeSslPolicy,
            'Resources::GCP::Compute::Subnetwork': GCP_ComputeSubnetwork,
            'Resources::GCP::Compute::TargetGrpcProxy': GCP_ComputeTargetGrpcProxy,
            'Resources::GCP::Compute::TargetHTTPProxy': GCP_ComputeTargetHttpProxy,
            'Resources::GCP::Compute::TargetHTTPSProxy': GCP_ComputeTargetHttpsProxy,
            'Resources::GCP::Compute::TargetInstance': GCP_ComputeTargetInstance,
            'Resources::GCP::Compute::TargetPool': GCP_ComputeTargetPool,
            'Resources::GCP::Compute::TargetSSLProxy': GCP_ComputeTargetSslProxy,
            'Resources::GCP::Compute::TargetTCPProxy': GCP_ComputeTargetTcpProxy,
            'Resources::GCP::Compute::TargetVPNGateway': GCP_ComputeTargetVpnGateway,
            'Resources::GCP::Compute::URLMap': GCP_ComputeUrlMap,
            'Resources::GCP::Compute::VPNGateway': GCP_ComputeVpnGateway,
            'Resources::GCP::Compute::VPNTunnel': GCP_ComputeVpnTunnel,
            'Resources::GCP::DNS::ManagedZone': GCP_DNSManagedZone,
            'Resources::GCP::MemoryStore::Instance': GCP_MemoryStoreInstance,
            'Resources::GCP::SQL::Instance': GCP_SQLInstance,
            'Resources::GCP::Storage::Bucket': GCP_StorageBucket
          };

          var c = constructors[resource.type];

          // TODO: if we don't find the resource we probably want to return a generic resource
          return c ? c.load(resource, environment) : Resource.load(resource, environment);
        };
      }
    ]
  );

angular.module('designer.model.resources.gcp.zone', ['designer.model.resource'])
  .factory('GCP_Zone', ["Resource", function(Resource) {
    return {
      load: function(resource, data) {
        resource = Resource.load(resource);
        resource.type_name = 'ZONE';
        
        resource.info = function() {
          var info = {};

          info.subnets = _.uniq(data.subnets);

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.security.arrow', ['designer.model.resource'])
  .factory('SecurityArrow', ["Resource", function(Resource) {
    return {
      load: function(resource) {
        resource.type_name = 'SECURITY';
        resource.name = "Arrow";
        resource.type = "Resources::Security::Arrow";

        resource = Resource.load(resource);

        return resource;
      }
    }
  }]);

angular.module('designer.workspace.canvases.jointjs.graph', [
  "designer.workspace.canvases.jointjs.shapes.container",
  "designer.workspace.canvases.jointjs.shapes.resource",
  "designer.workspace.canvases.jointjs.shapes.text",
  "designer.workspace.canvases.jointjs.link.resource",
  "designer.data.resources.factory"
])
  .service('Graph',
    ["ResourceElement", "ContainerElement", "TextElement", "ResourceLink",
      function(ResourceElement, ContainerElement, TextElement, ResourceLink) {
      return joint.dia.Graph.extend({
        resourceLinks: [],
        resourceCells: [],
        shapes: {},

        initialize: function() {
          joint.dia.Graph.prototype.initialize.apply(this, arguments);

          this.resourceLinks = [];
          this.resourceCells = [];
          this.textCells = [];
          this.shapes = {
            default_container: ContainerElement,
            default_resource: ResourceElement,
            custom: {}
          };
        },

        createResourceCell: function(r, geometry, additional) {
          var cell = null;
          var details = { resource: angular.copy(r), position: { x: geometry.x, y: geometry.y } };
          if(additional) details.info = additional;

          if(this.shapes.custom[r.type]) {
            cell = new this.shapes.custom[r.type](details);
          }
          else {
            cell = r.container ? new this.shapes.default_container(details) : new this.shapes.default_resource(details);
          }

          // Make sure the IDs match
          cell.resource_id = r.id;
          cell.id = cell.cid;

          this.resourceCells.push(cell);

          // Containers have a default size - set the proper size now
          if(cell.container) {
            cell.resize(geometry.w, geometry.h);
          }
        },

        createResourceLink: function(source, target, connection) {
          var link = new ResourceLink({});
          link.set('source', { id: source.id, selector: "g:nth-child(1) .connectionPoint" });
          link.set('target', { id: target.id, selector: "g:nth-child(1) .connectionPoint" });
          link.set('connection', connection);

          var startDirections = [];
          var endDirections = [];

          var start = source.position();
          var end = target.position();

          // Don't start links starting or ending in the wrong direction
          if (end.x > start.x) {
            startDirections.push("right");
            endDirections.push("left");
          } else {
            startDirections.push("left");
            endDirections.push("right");
          }

          // Don't start links starting or ending in the wrong direction
          if (end.y > start.y) {
            startDirections.push("bottom");
            endDirections.push("top");
          } else {
            startDirections.push("top");
            endDirections.push("bottom");
          }

          link.router('metro', {
            excludeEnds: ["source", "target"],
            excludeTypes: ["container"],
            step: 16,
            endDirections,
            startDirections,
          });
          link.connector('rounded', { radius: 20 });

          // Make sure the IDs match
          //link.id = connection.id;

          this.resourceLinks.push(link);

          return link;
        },

        createShape: function(info, shape_object, additional, resource = undefined) {
          var details = {
            position: { x: info.x, y: info.y },
            size: { width: info.width, height: info.height },
          };

          if (resource) {
            details.resource = resource;
          }

          if(additional) details.info = additional;

          var s  = new shape_object(details);
          s.name = info.name;
          s.resource_id = info.id || info.name;

          this.resourceCells.push(s);

          return s;
        },

        createTextBox: function(info) {
          var details = {
            position: { x: info.x, y: info.y },
            size: { width: info.w, height: info.h },
            attrs: {
              label: {
                text: info.text
              }
            }
          };

          var s = new TextElement(details);

          this.textCells.push(s);

          return s;
        },

        findByResourceId: function(id) {
          return _.filter(this.resourceCells, function(c) { return c.resource_id === id });
        },

        allCells: function() {
          return this.resourceCells.concat(this.resourceLinks).concat(this.textCells);
        },

        // TODO: both these functions are basically the same. This is pre-render, the next is post-render. Hrm.
        getResourceCellsForResource: function(resource_id) {
          return _.filter(this.resourceCells, function(cell) { return cell.resource_id === resource_id });
        },

        getCellsByResourceId: function(resource_id) {
          return this.get('cells').filter(function(cell) {
            return cell.resource_id === resource_id;
          });
        },

        clear: function() {
          this.resourceLinks = [];
          this.resourceCells = [];
          this.textCells = [];
        }
      });
    }]);

angular.module('designer.workspace.canvases.jointjs.canvas', [
  'designer.workspace.canvases.jointjs.graph',
  'designer.workspace.canvases.jointjs.paper',
  'designer.workspace.canvases.jointjs.views.resource',
  'designer.workspace.canvases.jointjs.views.link',
  'designer.workspace.canvases.jointjs.link.resource',
  'designer.workspace.canvases.jointjs.scroller',
  'designer.workspace.canvases.jointjs.handler.selection',
  'designer.workspace.canvases.jointjs.handler.zoom',
  "designer.app-scope",
  "designer.configuration",
  "designer.state"
])

.directive('jointJsCanvas',
  ["$rootScope", "Graph", "Paper", "LinkView", "ResourceLink", "CanvasScroller", "SelectionHandler", "ZoomHandler", "$appScope", "$timeout", "DesignerConfig", "DesignerState",
  function($rootScope, Graph, Paper, LinkView, ResourceLink, CanvasScroller, SelectionHandler, ZoomHandler, $appScope, $timeout, DesignerConfig, DesignerState) {
  return {
    templateUrl: '/designer/workspace/canvases/jointjs/canvas.html',
    replace: true,
    controllerAs: "JointCanvas",
    controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
      this.environment = $scope.Designer.environment;
      this.view = this.environment.current_view;

      $scope.WEBGL = THREE.WEBGL.isWebGLAvailable();
      $scope.WEBGL2 = THREE.WEBGL.isWebGL2Available();
      $scope.enable3DView =  DesignerConfig.get('enable3DView');

      // Create the paper inside the scroller
      this.paper = new Paper({
        width: this.view.width || 1000,
        height: this.view.height || 1000,
        gridSize: 16,
        model: new Graph(),
        elementView: function(element) {
          return element.view;
        },
        linkView: LinkView,
        defaultLink: new ResourceLink({}),
        snapLinks: { radius: 20 },
        async: true,
        sorting: joint.dia.Paper.sorting.APPROX,
        origin: { x: 0, y: 0 },
        interactive: false
      });

      // Doing this to get a hold of reference to paper in 3d canvas
      this.environment.paper = this.paper;

      // Add filters for shapes
      this.paper.addFilter("selectedResourceFilter", { name: 'dropShadow', args: { dx: 0, dy: 0, blur: 5, color: "#9B9B9B" } });
      this.paper.addFilter("highlightedResourceFilter", { name: 'outline', args: { color: "#077a07", width: 5, opacity: 1, margin: 5 } });

      // Add scroller
      this.scroller = new CanvasScroller({ paper: this.paper });

      // Render
      angular.element('#paper').append(this.scroller.render().el);

      this.selection_handler = new SelectionHandler(this.paper);
      this.zoom_handler = new ZoomHandler(this.paper);
    }],
    link: function(scope, element, attrs, ctrl) {
      // Handlers and defaults
      scope.highlighted = [];
      scope.background_load = false;
      scope.rendering = true;

      scope._cellPointerUp = function(cellView, evt, x, y) {
        if(!ctrl.scroller.hasPanned()) {
          if (evt.target && evt.target.getAttribute('control')) {
            $rootScope.$broadcast("toggle_control", evt.target.getAttribute('control'), true);

            // If they haven't already selected the vpc, select it
            if(!_.includes(ctrl.selection_handler.selected_cells, cellView))
              ctrl.selection_handler.selectCell(cellView);
          }
          else {
            ctrl.selection_handler.selectCell(cellView);
          }

          // Select dat!
          var stored_resource = DesignerState.get("selectedResource");
          var selected_resource;
          
          if (ctrl.selection_handler.selected_cells.length) {
            selected_resource = cellView.model.get("resource") 
          } 
          else { 
            selected_resource = (ctrl.view.type === DesignerState.overrides.selectedView) ?
              null : 
              (stored_resource ? stored_resource : null)
          }

          $rootScope.$broadcast("resource:selected", selected_resource);
          scope._unhighlightAll();
        }

        scope._stopPanning();
      };

      scope._stopPanning = function() {
        if(ctrl.scroller.isPanning()) {
          ctrl.scroller.stopPanning();
        }
      };

      scope._cellPointerDown = function cellPointerDown(cellView, evt, x, y) {
        ctrl.scroller.startPanning(evt, x, y);
      };

      scope._blankPointerDown = function blankPointerDown(evt, x, y) {
        ctrl.scroller.startPanning(evt, x, y);
      };

      scope._blankPointerUp = function blankPointerUp(evt, x, y) {
        if(evt.target.localName !== "svg") return;

        if(ctrl.scroller.isPanning()) {
          ctrl.scroller.stopPanning();
        }

        ctrl.selection_handler.cancelSelection(evt, x, y);

        $rootScope.$broadcast("resource:selected", null);
      };

      // TODO: need to merge this with the actual click method. Mucho duplicato!
      scope._resourceSelect = function resourceSelect(evt, resource) {
        // If it's hidden just display it's details, otherwise simulate a click
        var models = []
        if(ctrl.view.canvas === "jointjs") {
          models = ctrl.paper.model.getCellsByResourceId(resource.id);
        }

        if(!models.length) {
          ctrl.selection_handler.deselectCells();
          $rootScope.$broadcast("resource:selected", resource);
        }
        else {
          scope._cellPointerUp(ctrl.paper.findViewByModel(models[0]), evt);
        }

        scope._unhighlightAll();
      };

      scope._renderDone = function() {
        if(!scope.rendering) {
          return;
        }

        if(!scope.background_load) {
          if(DesignerConfig.get("fitToContent")) {
            ctrl.paper.fitToContent({ padding: 50 });
          }
          else {
            ctrl.paper.fitToEnvironment(ctrl.environment);
            ctrl.scroller.center();
            ctrl.zoom_handler.auto_zoom(ctrl);
          }
        }
        else {
          scope.background_load = false;

          ctrl.selection_handler.refreshSelected();
          ctrl.zoom_handler.zoom();
        }
        ctrl.paper.updateContainerText();
        ctrl.paper.fadeResources();
        $rootScope.$broadcast("render:done", {});
        scope.refreshToggles();

        $appScope.safeApply(function() { scope.rendering = false; }, scope);
      };

      scope._autoCenterAndZoom = function() {
        // TODO: there are too many canvas type checks for events - ideally we only render one canvas at a time and send events to it
        if(ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;

        ctrl.paper.fitToEnvironment(ctrl.environment);
        ctrl.scroller.center();
        ctrl.zoom_handler.auto_zoom(ctrl);
      };

      scope._environmentLoaded = function() {
        if(ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;

        scope.rendering = true;
        // We might not have anything, we don't want the loading screen up the whole time
        // TODO: this is duplicated below. Simpliffyyyyyy.
        if(ctrl.view.isEmpty()) {
          scope.rendering = false;
        }
        else {
          ctrl.paper.model.resetCells(ctrl.view.model.allCells());
        }
        if (!ctrl.environment.facet.resources.length) { 
          scope.rendering = false;
        }
      };

      scope._environmentReloaded = function(event, environment, params) {
        params = params || {};

        ctrl.environment = environment;

        if(params.background) scope.background_load = true;

        scope._viewSelected(null, environment.current_view);
      };

      scope._viewSelected = function(event, view, force = false) {
        if (view.canvas !== "jointjs" && view.canvas !== "3d") return;
        // Don't do anything if the view didn't change
        // This will happen when switching from html canvas to jointjs canvas which was previsouly already rendered.
        if (!force && view.revision_id === ctrl.view.revision_id) return;

        scope.rendering = true;

        if(ctrl.view.canvas)
          view.canvas = ctrl.view.canvas;

        ctrl.view = view;
        // We might not have anything, we don't want the loading screen up the whole time
        if(ctrl.view.isEmpty()) {
          ctrl.paper.model.resetCells([]);
          scope.rendering = false;
        }
        else {
          ctrl.paper.model.resetCells(ctrl.view.model.allCells());
        }
        if (!ctrl.environment.facet.resources.length) {
          scope.rendering = false;
        }
      };

      scope._viewModified = function(event, view) {
        scope._viewSelected(event, view, true);
      }

      scope._viewRepositioned = function() {
        if (ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;

        ctrl.paper.updateLinks();

        if (ctrl.view.type === 'Views::Container')
          scope._viewSelected(event, ctrl.view, true);
      };

      scope._highlightConnected = function(evt, resource) {
        var resources = resource.highlightableConnections();

        _.each(resources, function(r) {
          if(!r.hidden) {
            var cells = ctrl.paper.model.getCellsByResourceId(r.id);

            _.each(cells, function(cell) {
              var view = ctrl.paper.findViewByModel(cell);

              view.highlight();
              scope.highlighted.push(view);
            });
          }
        });
      };

      scope._highlightResource = function(evt, resource) {
        if(!resource.hidden) {
          var cells = ctrl.paper.model.getCellsByResourceId(resource.id);

          _.each(cells, function(cell) {
            var view = ctrl.paper.findViewByModel(cell);

            view.highlight();
            scope.highlighted.push(view);
          });
        }
      };

      scope._unhighlightAll = function() {
        _.each(scope.highlighted, function(cellView) {
          cellView.unhighlight();
        });

        scope.highlighted = [];
      };

      scope.refreshToggles = function() {
        scope._toggleConnections();
        scope._toggleNames();
        scope._skewIsometric();
        scope._highlightChanges();
        scope._iconSwitch();
      };
      
      // TODO: we want to remember the STATE of connections ... hrmm .... otherwise we hide any that might be showing because a resource is selected
      scope._toggleConnections = function() {
        if(ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;
        ctrl.paper.toggleAllConnections(DesignerState.get("displayConnections"));
      };

      scope._toggleNames = function() {
        if(ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;

        _.each(ctrl.paper.model.getElements(), function(e) {
          var view = ctrl.paper.findViewByModel(e);

          if(view && view.model.showName) {
            DesignerState.get("displayLabels") ? view.model.showName(view) : view.model.hideName(view);
          }
        });
      };

      // TODO: this shouldn't be called directly from canvas.html - underscore functions are technically 'private'
      scope._switchSkewIsometric = function() {
        var value = DesignerState.get("displayIsometric");
        DesignerState.set("displayIsometric", !value);

        scope._skewIsometric();
      };

      scope._skewIsometric = function() {
        ctrl.paper.skewIsometric(DesignerState.get("displayIsometric"));
      };

      scope.switchToThreeJSCanvas = function () {
        var value = DesignerState.get("display3DView");
        DesignerState.set("display3DView", !value);
        $rootScope.$broadcast("viewChanged");
        ctrl.view.canvas = '3d';
      }

      scope._iconSwitch = function() {
        ctrl.paper.iconSwitch();
      };

      scope._highlightChanges = function() {
        if(ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;

        ctrl.paper.highlightEnvResources(ctrl.environment, DesignerConfig.get("highlightAdded") || [], DesignerConfig.get("highlightDeleted") || []);
      };

      scope._highlightPreselectedResource = function() {
        if(ctrl.view.canvas !== "jointjs" && ctrl.view.canvas !== "3d") return;
        var resource = DesignerState.get("selectedResource")
        if(resource) {
          $rootScope.$broadcast("resource:select", resource)
        }
      };

      // Handle paper events
      ctrl.paper.on("cell:pointerup",    scope._cellPointerUp);
      ctrl.paper.on("cell:pointerdown",  scope._cellPointerDown);
      ctrl.paper.on("blank:pointerdown", scope._blankPointerDown);
      ctrl.paper.on("blank:pointerup",   scope._blankPointerUp);
      ctrl.paper.on("render:done",       scope._renderDone);

      // Handle our events
      scope.$on("resource:select",          scope._resourceSelect);
      scope.$on("environment:reloaded",     scope._environmentReloaded);
      scope.$on("view:selected",            scope._viewSelected);
      scope.$on("view:modified",            scope._viewModified);
      scope.$on("view:repositioned",        scope._viewRepositioned);
      scope.$on("resource:highlight",       scope._highlightResource);
      scope.$on("resource:unhighlight",     scope._unhighlightAll);
      scope.$on("connected:highlight",      scope._highlightConnected);
      scope.$on("connected:unhighlight",    scope._unhighlightAll);
      scope.$on("diagram:zoomtofit",        scope._autoCenterAndZoom);
      scope.$on("icon:switch",              scope._iconSwitch);
      scope.$on("toggle:connections",       scope._toggleConnections);
      scope.$on("toggle:labels",            scope._toggleNames);

      scope.$on("view:ready", function() {
        scope._environmentLoaded();
        scope._highlightPreselectedResource();
      });

      // When the page has loaded trigger env load in a timeout to take it outside the angular digest
      if(ctrl.view.positioned) {
        element.ready(function() {
          $timeout(function() {
            scope._environmentLoaded();
          }, 1);
        });
      }

      // Make sure if we move our mouse outside the div we stop panning
      element.on('mouseleave', scope._stopPanning);
      scope.$on('$destroy', function() {
        element.off('mouseleave', scope._stopPanning);
      });
    }
  }
}]);

angular.module('designer.workspace.canvases.jointjs.paper', [])
.service('Paper', [function() {
  return joint.dia.Paper.extend({
    locked: true,
    display_connections: false,
    isometric: false,

    addFilter: function(filterID, filter) {
      var filterSVGString = joint.util.filter[filter.name] && joint.util.filter[filter.name](filter.args || {});
      var filterElement = V(filterSVGString);
      // Set the filter area to be 3x the bounding box of the cell
      // and center the filter around the cell.
      filterElement.attr({
        filterUnits: 'objectBoundingBox',
        x: -1, y: -1, width: 3, height: 3
      });
      if (filter.attrs) filterElement.attr(filter.attrs);
      filterElement.node.id = filterID;
      V(this.defs).append(filterElement);
    },

    lock: function(locked) {
      this.locked = locked;
    },

    requestConnectedLinksUpdate: function(view, opt) {
      // Ignore connected link updates - they only ever move if we change the layout, so we trigger that manually below
    },

    updateLinks: function() {
      _.each(this.model.getLinks(), function(link) {
        var linkView = this.findViewByModel(link);
        if (!linkView) return;
        var flagLabels = ['UPDATE', 'TARGET', 'SOURCE'];
        this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), linkView.UPDATE_PRIORITY, {});
      }.bind(this));
    },

    toggleAllConnections: function(toggle) {
      this.display_connections = toggle;

      _.each(this.model.getLinks(), function(link) {
        var model = this.findViewByModel(link);

        if(model) {
          this.display_connections ? model.$el.show() : model.$el.hide();
        }
      }.bind(this));
    },

    showLinks: function(resource) {
      if(this.display_connections) return;

      _.each(this.model.getLinks(), function(link) {
        if(resource.id === link.attributes.source.id || resource.id === link.attributes.target.id) {
          this.findViewByModel(link).$el.show();
        }
      }.bind(this));
    },

    hideLinks: function(resource) {
      if(this.display_connections) return;

      _.each(this.model.getLinks(), function(link) {
        if(resource.id === link.attributes.source.id || resource.id === link.attributes.target.id) {
          this.findViewByModel(link).$el.hide();
        }
      }.bind(this));
    },

    updateContainerText: function() {
      _.each(this.model.getElements(), function(r) {
        r.updateContainerText(this);
      }.bind(this));
    },

    skewIsometric: function(showIsometric) {
      this.isometric = showIsometric;

      if (showIsometric) {
        V(this.svg).addClass("skew");
        V(this.svg).addClass("rotate");
      }
      else {
        V(this.svg).removeClass("skew");
      }
    },

    highlightEnvResources: function(environment, highlightAdded, highlightDeleted) {
      if(environment.facet.resources.length) {
        if(highlightDeleted.length) {
          this.highlightResources(highlightDeleted, true);
        }
        if(highlightAdded.length){
          this.highlightResources(highlightAdded, false);
        }
      }
    },

    highlightResources: function(resources, state) {
      _.each(this.model.getElements(), function(r) {
        var view = this.findViewByModel(r);
        var s = r.get('resource');
        if(s && _.includes(resources, s.id)){
          view.highlight(state)
        }
      }.bind(this));
    },

    fadeResources: function() {
      _.each(this.model.getElements(), function(r) {
        var view = this.findViewByModel(r);
        var resource = r.get('resource');

        if(!view || !resource) return;

        resource.display_faded ? view.fade() : view.unfade();
      }.bind(this));
    },

    iconSwitch: function() {
      _.each(this.model.getElements(), function(r) {
        var view = this.findViewByModel(r);
        var resource = r.get('resource');
        view.updateTheme(resource);
      }.bind(this));
    },

    // If the content is too small, add a lot of padding. Otherwise extend the canvas to fit it all with a little padding
    fitToEnvironment: function(environment) {
      var min         = 4000;
      var padding     = 1500; // Give it some room to zoom, boom
      // TODO: we only need to check views that are on the jointjs canvas
      var maxWidth    = _.maxBy(environment.views, function(view) { return view.width }).width * 2;
      var maxHeight   = _.maxBy(environment.views, function(view) { return view.height }).height * 2;
      var widthDiff   = min - maxWidth;
      var heightDiff  = min - maxHeight;
      var biggestDiff = widthDiff > heightDiff ? widthDiff : heightDiff;

      // If we are smaller than the minimum then add it to padding
      if(biggestDiff > 0) {
        padding = biggestDiff / 2;
      }

      this.fitToContent({ minWidth: maxWidth, minHeight: maxHeight, padding: padding })
    }
  });
}]);

angular.module('designer.workspace.canvases.jointjs.resource.connections.highlighter', [])
.directive('highlightConnectedResources', ["$rootScope", function($rootScope) {
  return {
    scope: {
      resource: "=highlightConnectedResources"
    },
    link: function (scope, element, attrs) {
      scope.highlighted = [];

      scope.highlight = function() {
        $rootScope.$broadcast("connected:highlight", scope.resource);
      };

      scope.unhighlight = function() {
        $rootScope.$broadcast("connected:unhighlight");
      };

      element.on('mouseover',  scope.highlight);
      element.on('mouseleave', scope.unhighlight);
      element.on('mousedown', scope.unhighlight);
      scope.$on('$destroy', function() {
        element.off('mouseover',  scope.highlight);
        element.off('mouseleave', scope.unhighlight);
        element.off('mousedown', scope.unhighlight);
      });
    }
  }
}]);

angular.module('designer.workspace.canvases.jointjs.resource.highlighter', [])
.directive('highlightResources', ["$rootScope", function($rootScope) {
  return {
    scope: {
      resource: "=highlightResources"
    },
    link: function (scope, element, attrs) {
      scope.highlighted = [];

      scope.highlight = function() {
        $rootScope.$broadcast("resource:highlight", scope.resource);
      };

      scope.unhighlight = function() {
        $rootScope.$broadcast("resource:unhighlight");
      };

      element.on('mouseover',  scope.highlight);
      element.on('mouseleave', scope.unhighlight);
      scope.$on('$destroy', function() {
        element.off('mouseover',  scope.highlight);
        element.off('mouseleave', scope.unhighlight);
      });
    }
  }
}]);

angular.module('designer.workspace.canvases.jointjs.scroller', [])
.service('CanvasScroller', [function() {
  return Backbone.View.extend({
    className:"designer-scroller",
    events: {
      mousemove: "pan",
      touchmove: "pan"
    },
    panThreshold: 10, // How many pixels we have to pan before it considers it 'panned'

    initialize: function(options) {
      this.options = options;

      $(this.el).append(this.options.paper.el);

      _.bindAll(this,"startPanning","stopPanning");
    },

    render: function() {
      this.listenTo(this.options.paper,"scale resize",this.onScale);

      return this;
    },

    onScale: function(a, b, ox, oy) {
      var cx = this.options.paper.options.width / 2,
          cy = this.options.paper.options.height / 2;

      V(this.options.paper.viewport).translateCenterToPoint({ x: cx, y: cy });
    },

    center: function(ox,oy) {
      if (_.isUndefined(ox) || _.isUndefined(oy)) {
        ox = this.options.paper.options.width / 2;
        oy = this.options.paper.options.height / 2
      }

      var diagram = angular.element(".designer-workspace");

      var sx = 1,
          sy = 1,
          cx = diagram.width() / sx / 2,
          cy = diagram.height() / sy / 2;

      this.el.scrollLeft = (ox - cx) * sx;
      this.el.scrollTop = (oy - cy) * sy;
    },

    startPanning: function(evt) {
      evt=joint.util.normalizeEvent(evt);
      this._panning=true;
      this._clientX=evt.clientX;
      this._clientY=evt.clientY;

      this._movedX = 0;
      this._movedY = 0;
    },

    pan: function(evt) {
      if(!this._panning)
        return;

      evt=joint.util.normalizeEvent(evt);

      var dx=evt.clientX-this._clientX;
      var dy=evt.clientY-this._clientY;
      this._movedX += dx;
      this._movedY += dy;
      this.el.scrollTop-=dy;
      this.el.scrollLeft-=dx;
      this._clientX=evt.clientX;
      this._clientY=evt.clientY;

      this.options.paper.model.trigger("pan");
    },

    stopPanning: function() {
      delete this._panning;
      this._movedX = 0;
      this._movedY = 0;
    },

    hasPanned: function() {
      return Math.abs(this._movedX) > this.panThreshold || Math.abs(this._movedY) > this.panThreshold;
    },

    isPanning: function() {
      return this._panning;
    }
  });
}]);

angular.module('designer.workspace.canvases.html.diagram', ['designer.workspace.canvases.html.handler.event'])
  .factory('HtmlDiagram', ['HtmlEventHandler', function(HtmlEventHandler) {
    var Diagram = function Diagram(opts) {
      this.el       = $('<div class="html-diagram"></div>');
      this.parent   = opts.parent;
      this.scroller = opts.scroller;
      this.max_size = opts.max_size;
      this.handler  = new HtmlEventHandler();

      // Draw me eh
      this.parent.append(this.el);

      // TODO: look at using _.bindAll
      // TODO: check mousemove on click handler
      var that = this;
      this.parent.on("mousedown", function(evt, x, y) { that.mouseDown(evt) });
      this.parent.on("mouseup",   function(evt, x, y) { that.mouseUp(evt) });
    };

    Diagram.prototype.mouseDown = function(evt) {
      var clicked = this.findElement(evt.target);

      if(clicked) {
        this.handler.trigger("element:pointerdown", evt, clicked);
      }
      else {
        this.handler.trigger("blank:pointerdown", evt);
      }
    };

    Diagram.prototype.mouseUp = function(evt) {
      var clicked = this.findElement(evt.target);

      if(clicked) {
        this.handler.trigger("element:pointerup", evt, clicked);
      }
      else {
        this.handler.trigger("blank:pointerup", evt);
      }
    };

    Diagram.prototype.findElement = function(el) {
      var $el = $(el);

      if ($el.length === 0 || $el[0] === this.el) {
        return undefined;
      }

      if ($el.data('view')) {
        return $el.data('view');
      }

      return this.findElement($el.parent());
    };

    Diagram.prototype.clear = function() {
      this.el.empty();
    };

    Diagram.prototype.fitToView = function(view) {
      var maxWidth  = view.width;
      var maxHeight = view.height;

      this.el.css("position", "absolute");
      this.el.css("width", maxWidth);
      this.el.css("height", maxHeight);
      this.el.css("top", (this.max_size-maxHeight)/2);
      this.el.css("left", (this.max_size-maxWidth)/2);

      this.parent.css("min-width", this.max_size);
      this.parent.css("min-height", this.max_size);
    };

    Diagram.prototype.resetSize = function() {
      this.el.attr("style", "");
      this.parent.attr("style", "");
    };

    Diagram.prototype.render = function(elements) {
      _.each(elements, function(element) {
        element.render();
        this.el.append(element.el);
      }.bind(this));
    };

    Diagram.prototype.on = function(event_name, callme) {
      this.handler.on(event_name, callme);
    };

    return Diagram;
  }]);

angular.module('designer.workspace.canvases.html.canvas', [
  'designer.workspace.canvases.html.scroller',
  'designer.workspace.canvases.html.diagram',
  'designer.workspace.canvases.html.handler.selection',
  'designer.workspace.canvases.html.handler.zoom'
])
  .directive('htmlCanvas',
    ["$rootScope", "HtmlScroller", "HtmlDiagram", "HtmlSelectionHandler", "HtmlZoomHandler", "$timeout", function($rootScope, HtmlScroller, HtmlDiagram, HtmlSelectionHandler, HtmlZoomHandler, $timeout) {
        return {
          templateUrl: '/designer/workspace/canvases/html/canvas.html',
          replace: true,
          controllerAs: "HtmlCanvas",
          controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            this.environment = $scope.Designer.environment;
            this.el = angular.element("#html-canvas");
            this.view =  this.environment.current_view;
            this.scroller = new HtmlScroller();
            this.diagram = new HtmlDiagram({
              parent: this.el,
              max_size: 4000,
              scroller: this.scroller
            });
            this.selection_handler = new HtmlSelectionHandler(this.diagram);
            this.zoom_handler = new HtmlZoomHandler(this.diagram);
          }],

          link: function(scope, element, attrs, ctrl) {
            scope.rendering = true;

            scope.viewLoaded = function(event, view) {
              if(view.canvas !== "html") return;

              ctrl.view = view;
              ctrl.view.render(ctrl.diagram);

              // TODO: Ugh, not ideal - we need to position after the dom has rendered or size is 0. There will be a better way, just need to find it
              $timeout(function() {
                ctrl.view.loadDimensions();

                if(ctrl.view.scrollable) {
                  ctrl.scroller.center();
                }
                else {
                  ctrl.diagram.resetSize();
                }

                if(ctrl.view.zoomable) {
                  ctrl.zoom_handler.autoZoom(ctrl.view);
                }
              }, 0, false);
            };

            scope.environmentReloaded = function(event, environment, params) {
              ctrl.environment = environment;

              scope.viewLoaded(null, environment.current_view);
            }

            scope.autoCenterAndZoom = function() {
              if(ctrl.view.canvas !== "html") return;

              if(ctrl.view.scrollable) {
                ctrl.scroller.center();
              }

              if(ctrl.view.zoomable) {
                ctrl.zoom_handler.autoZoom(ctrl.view);
              }
            };

            scope.elementPointerUp = function(event, element) {
              if(!ctrl.scroller.hasPanned()) {
                ctrl.selection_handler.selectElement(element);
              }

              ctrl.scroller.stopPanning();

              $rootScope.$broadcast("resource:selected", ctrl.selection_handler.selected_elements.length ? element.resource : null);
            };

            scope.elementPointerDown = function(event, element) {
              ctrl.scroller.startPanning(event);
            };

            scope.blankPointerUp = function(event) {
              // TODO: comment this out because it breaks list view and it's the only html canvas
              // if(!ctrl.scroller.hasPanned()) {
              //   ctrl.selection_handler.cancelSelection();
              // }
              //
              // ctrl.scroller.stopPanning();
              //
              // $rootScope.$broadcast("resource:selected", null);
            };

            scope.blankPointerDown = function(event) {
              ctrl.scroller.startPanning(event);
            };

            scope.$on("view:selected", scope.viewLoaded);
            scope.$on("environment:reloaded", scope.environmentReloaded);
            scope.$on("diagram:zoomtofit",    scope.autoCenterAndZoom);

            // Listen to diagram events
            ctrl.diagram.on("element:pointerup", scope.elementPointerUp);
            ctrl.diagram.on("element:pointerdown", scope.elementPointerDown);
            ctrl.diagram.on("blank:pointerup", scope.blankPointerUp);
            ctrl.diagram.on("blank:pointerdown", scope.blankPointerDown);
            ctrl.diagram.on("render:done", scope.renderDone);

            // TODO: these should be handled by the scroller
            ctrl.el.on("mousemove", function mouseMove(evt) {
              ctrl.scroller.pan(evt);
            });
            ctrl.el.on("mouseout", function mouseOutOfCanvas() {
              if(ctrl.scroller.isPanning()) {
                ctrl.scroller.stopPanning();
              }
            });

            // If the default is an html view then we need to render it RIGHT NOW
            scope.viewLoaded(null, ctrl.view);
          }
        }
      }]);

angular.module('designer.workspace.canvases.html.scroller', [])
  .factory('HtmlScroller', [function() {
    var Handler = function Handler() {
      this.el = angular.element("#html-scroller");
      this.panThreshold = 10;
      this._panning = false;
    };

    Handler.prototype.center = function() {
      var width = this.el.children().width();
      var height = this.el.children().height();
      var windowWidth = this.el.width();
      var windowHeight = this.el.height();

      // Get the size of the canvas and then .. center it
      this.el.scrollTop((height-windowHeight)/2);
      this.el.scrollLeft((width-windowWidth)/2);
    };

    Handler.prototype.startPanning = function(evt) {
      this._panning=true;
      this._clientX=evt.clientX;
      this._clientY=evt.clientY;

      this._movedX = 0;
      this._movedY = 0;
    };

    Handler.prototype.pan = function(evt) {
      if(!this._panning)
        return;

      var dx = evt.clientX - this._clientX;
      var dy = evt.clientY - this._clientY;
      this._movedX += dx;
      this._movedY += dy;
      this.el.scrollTop(this.el.scrollTop() - dy);
      this.el.scrollLeft(this.el.scrollLeft() - dx);
      this._clientX = evt.clientX;
      this._clientY = evt.clientY;
    };

    Handler.prototype.stopPanning = function() {
      if(!this._panning) return;

      this._panning = false;
      this._movedX = 0;
      this._movedY = 0;
    };

    Handler.prototype.hasPanned = function() {
      return Math.abs(this._movedX) > this.panThreshold || Math.abs(this._movedY) > this.panThreshold;
    };

    Handler.prototype.isPanning = function() {
      return this._panning;
    };

    return Handler;
  }]);

angular
  .module("designer.workspace.layout.security.aws", ['designer.model.helpers.ports'])
  .factory("SecurityLayoutAWS", ["portMapper",
    function (portMapper) {
      return {
        load: function (environment) {
          const layout = {};

          // Define types we will use later to fetch certain types
          const PREFIX = "Resources::AWS";
          const GROUP = `${PREFIX}::EC2::SecurityGroup`;
          const PERMISSION = `${PREFIX}::EC2::SecurityGroupPermission`;

          // Create a list of the id/names of our returned SGs
          layout.findGroups = function (sgs) {
            return _.map(sgs, function (sg) {
              const { provider_id, id, name } = sg;
              const vpc = sg.getVpc();
              const network_id = vpc.provider_id;
              const network_name = vpc.name;
              return { provider_id, id, name, network_id, network_name };
            });
          };

          // Return an Array of the IP ranges contained in a permission
          layout.ipRanges = function (permission) {
            if (!permission.ip_ranges) return [];
            const { ip_ranges } = permission;
            return _.map(ip_ranges, (range) => range.cidr_ip);
          };

          // Rules with -1 are considered ALL
          layout.compress = function (permission) {
            const { ip_protocol, from_port, to_port } = permission;
            if (ip_protocol === "-1") {
              return { protocol: "ALL", from_port: "ALL", to_port: "ALL" };
            } else {
              return { protocol: ip_protocol, from_port, to_port };
            }
          };

          /**
           * Utility method that finds the connections
           * To a given resources and destination resource type
           */
          layout.getConnected = function (resource, type) {
            const connected = [];

            _.each(resource.connections, function (connection) {
              if (connection.remote_resource_id === resource.id) return;

              const connected_to = environment.getResource(
                connection.remote_resource_id
              );

              if (connected_to && connected_to.type === type) {
                connected_to.connection_data = connection.data;
                connected.push(connected_to);
              }
            });
            return connected;
          };

          /**
           * Utility method that takes in all required args
           * Outputs a rule aka arrow
           */
          layout.rule = function (compressed, range_or_id, group, direction) {
            const { protocol, from_port, to_port } = compressed;
            const rule = {};

            let src = range_or_id;
            let dst = group;
            if (direction == "egress") (src = group), (dst = range_or_id);

            const endpoints = { id: _.uniqueId(), src, dst };
            const from_proto = portMapper[from_port];
            const to_proto = portMapper[to_port]
            const port_rules = { protocol, from_port, to_port, direction, from_proto, to_proto };

            Object.assign(rule, endpoints, port_rules);
            return rule; // Aka arrow
          };

          /**
           * This is where we take in in individual permissions
           * Find out all the rules in it and create arrows
           */
          layout.findRules = function (permissions, group) {
            if (!permissions) return [];

            const rules = [];
            permissions.forEach((permission) => {
              const compressed = this.compress(permission);
              const { ip_ranges, permission_type } = permission;
              const direction = permission_type;

              // Push IP based rules
              if (ip_ranges) {
                const ranges = this.ipRanges(permission);
                ranges.forEach((range) => {
                  const rule = this.rule(compressed, range, group, direction);
                  rules.push(rule);
                });
              }

              // Push Security Group based rules
              const connections = this.getConnected(permission, GROUP);
              connections.forEach((connection) => {
                const conn_id = connection.provider_id;
                const rule = this.rule(compressed, conn_id, group, direction);
                rules.push(rule);
              });
            });

            return rules;
          };

          /**
           * This is where we take in in individual permissions
           * Find out all the rules in it and create arrows
           */
          layout.findInternalRules = function (sgs) {
            let rules = [];

            sgs.forEach((sg) => {
              const { provider_id } = sg;
              const permissions = this.getConnected(sg, PERMISSION);
              const reduced = this.findRules(permissions, provider_id);
              reduced.map((r) => (r.network_id = sg.getVpc().provider_id));
              reduced.map((r) => (r.security_group = sg));
              rules = rules.concat(reduced);
            });

            return rules;
          };

          /**
           * Create Arrows from compressed rules
           * From here on rules that are in security groups become arrows
           */
          layout.createArrows = function (group_ids, rules) {
            let arrows = rules.filter((rule) => {
              return group_ids.includes(rule.src);
            });

            // Now let's split them out to bidirectional arrows
            const bi_arrows = [];
            arrows.forEach((arrow) => {
              const { ports, src, dst, security_group, network_id, network_name } = arrow;
              const bi_ports = ports.filter((r) => r.direction === "bi");

              // Make bi_ports displayed on seperate arrows
              if (bi_ports.length > 0) {
                bi_arrows.push({ network_id, network_name, security_group, src, dst, direction: "bi", ports: bi_ports });

                arrow.ports = ports.filter((port) => {
                  return !bi_ports.includes(port);
                });
              }
            });

            // Add our bidirection arrows
            // Clear anything with empty rules
            // Add a unique Id
            arrows = arrows.concat(bi_arrows);
            arrows = arrows.filter((arrow) => arrow.ports.length);
            _.each(arrows, (arrow) => (arrow.id = _.uniqueId()));

            return arrows;
          };

          /**
           * Add positional details on arrows
           * Do not create new arrow group
           */
          layout.positionArrows = function (full, scoped_arrows) {
            const { resources } = environment.facet;

            // Filter out arrows which cannot be drawn
            const drawable = scoped_arrows.filter((arrow) => {
              const src_pos = full.findIndex(
                (f) => f.provider_id === arrow.src
              );
              const dst_pos = full.findIndex(
                (f) => f.provider_id === arrow.dst
              );

              if (src_pos === -1 || dst_pos === -1) return false;
              return true;
            });

            _.each(drawable, function (arrow) {
              // TODO: so either of those can be an IP rather than an sg id! Shit!
              // Calculate source, destination positions
              let src_pos = full.findIndex((r) => {
                return r.id === arrow.src && r.network_id === arrow.network_id;
              });
              let dst_pos = full.findIndex((r) => {
                return r.id === arrow.dst && r.network_id === arrow.network_id;
              });

              // If the source/destination is a resource
              // Must search in the full list, otherwise search in
              // Scoped list, as they could be service tags
              if (resources.find((r) => r.provider_id === arrow.src)) {
                src_pos = full.findIndex((f) => f.provider_id === arrow.src);
              }

              if (resources.find((r) => r.provider_id === arrow.dst)) {
                dst_pos = full.findIndex((f) => f.provider_id === arrow.dst);
              }

              // Required for arrow position
              const lower_pos = Math.min(src_pos, dst_pos);
              const higher_pos = Math.max(src_pos, dst_pos);
              const size = higher_pos - lower_pos;

              // a is down, c is up (for sorting later)
              let direction = src_pos < dst_pos ? "down" : "up";
              if (arrow.direction === "bi") direction = "two-way";

              const position = { direction, src_pos, dst_pos, lower_pos, size };

              position.sort_key = direction === "up" ? dst_pos : src_pos;
              Object.assign(arrow, position);
            });

            return drawable;
          };

          layout.rejectInternalRules = function (rules) {
            return _.reject(rules, function (x) {
              return x.src === x.dst;
            });
          };

          layout.rejectICMPRules = function (rules) {
            return _.reject(rules, function (x) {
              return x.protocol === "icmp";
            });
          };

          layout.fetchSGs = function (facet) {
            const sgs = _.filter(facet, function (x) {
              return x.type === GROUP;
            });

            return _.sortBy(sgs, function (s) {
              return s.name;
            });
          };

          layout.getData = function () {
            const { resources } = environment.facet;
            const sgs = this.fetchSGs(resources);

            // Get an array of hashes containing id/name keys
            const mini_rows = this.findGroups(sgs);
            const groups = _.groupBy(mini_rows, "network_id");

            // Create an array of the SGs that make up our rows
            const length = _.values(groups).length;
            let count = 0;
            _.each(groups, (v, network_id) => {
              const internet = {};
              internet.name = internet.id = internet.provider_id = "internet";
              internet.network_id = network_id;
              internet.network_name = v[0].network_name;
              v.unshift(internet);

              count += 1;

              const blank_row = { id: "blank", name: "blank", type: "blank" };
              const blank_rows = Array(2).fill(blank_row);
              if (count !== length) blank_rows.forEach((r) => v.push(r));
            });

            const rows = _.values(groups).flat();

            // Create an array of the SGs that make up our rows
            const group_ids = _.map(rows, (g) => g.provider_id);

            // Make a flat set of rules
            // Reject rules where the source and destination are the same
            let rules = this.findInternalRules(sgs);
            rules = this.rejectInternalRules(rules);

            // Batch rules which share same source and destination
            const batched = [];
            rules.forEach((rule) => {
              const { src, dst, network_id, network_name } = rule;
              const existing = batched.find((b) => {
                return b.src === src && b.dst === dst;
              });

              // Create a rule on a port level
              const { protocol, security_group, from_port, to_port, direction, from_proto, to_proto } = rule;
              const port_rule = { protocol, from_port, to_port, direction, from_proto, to_proto, security_group };

              if (existing) {
                existing.ports.push(port_rule);
              } else {
                batched.push({ security_group, src, dst, network_id, network_name, ports: [port_rule] });
              }
            });

            // Remove ICMP rules before determining bi-directional arrows
            _.each(batched, function (derp) {
              derp.ports = _.reject(derp.ports, function (x) {
                return x.protocol === "icmp";
              });
            });

            // Loop through each rule and check if we have any rules going the opposite direction
            const checked = [];
            batched.forEach((rule) => {
              const existing = checked.find((x) => {
                return x.src === rule.dst && x.dst === rule.src;
              });

              // We have a rule going in the opposite direction
              // Check if we share any ports which would create a bidirectional rule
              if (existing) {
                existing.ports.forEach((existing_port, i) => {
                  rule.ports.forEach((rule_port) => {
                    // Egress can't have a security group as a dst
                    // So we only check for ingress on group connections
                    // We share a port - mark one side bidirectional and the other as removeable
                    if (_.isEqual(existing_port, rule_port)) {
                      rule_port.direction = "bi";
                      existing.ports.splice(i, 1);
                    } else if (
                      existing_port.protocol === "ALL" &&
                      rule_port.protocol === "ALL" &&
                      existing_port.direction !== rule_port.direction
                    ) {
                      rule_port.direction = "bi";
                      existing.ports.splice(i, 1);
                    }
                  });
                });
              } else {
                checked.push(rule);
              }
            });

            // Now take any bidirectional rules and move them to a new rule
            // In case there are some rules that only go one direction
            const new_batch = [];
            batched.forEach((r) => {
              const both = r.ports.filter((x) => x.direction === "both");

              if (both.length > 0) {
                // TODO: does this work?
                new_batch.push({ src: r.src, network_id: r.network_id, dst: r.dst, ports: both });

                r.ports = r.ports.filter((x) => x.direction !== "both");
                if (r.ports.length > 0) new_batch.push(r);
              } else {
                new_batch.push(r);
              }
            });

            // Change rules to use 'internet' so we can match the security group
            new_batch.forEach((arrow) => {
              if (arrow.dst === "0.0.0.0/0") arrow.dst = "internet";
              if (arrow.src === "0.0.0.0/0") arrow.src = "internet";
            });

            // Create arrows from the rules
            // Position them in the view space
            // Sort by direction
            let arrows = [];
            let unsorted_arrows = this.createArrows(group_ids, new_batch);

            const grouped_arrows = _.groupBy(unsorted_arrows, "network_id");
            _.each(grouped_arrows, (scoped_arrows, network_id) => {
              const positioned = this.positionArrows(rows, scoped_arrows);
              arrows = arrows.concat(positioned);
            });

            arrows = _.sortBy(arrows, (arrow) => {
              return arrow.direction + arrow.sort_key;
            });

            // Return nothing if there's nothing worth displaying
            if (arrows.length === 0) return { rows: [], arrows: [] };
            return { rows, arrows };
          };

          return layout;
        },
      };
    },
  ]);

angular
  .module("designer.workspace.layout.security.azure", ['designer.model.helpers.ports'])
  .factory("SecurityLayoutAzure", ["portMapper",
    function (portMapper) {
      return {
        load: function (environment) {
          const layout = {};

          // Define types we will use later to fetch certain types
          const PREFIX = "Resources::Azure::Network";
          const SUBNET = `${PREFIX}::Subnet`;
          const VNET = `${PREFIX}::VirtualNetwork`;
          const NSG = `${PREFIX}::NetworkSecurityGroup`;
          const ASG = `${PREFIX}::ApplicationSecurityGroup`;
          const INTERFACE = `${PREFIX}::NetworkInterface`;
          const RULE = `${PREFIX}::NetworkSecurityGroup::SecurityRule`;
          const IPCONFIG = `${PREFIX}::NetworkInterface::IpConfiguration`;

          /**
           * Go through the network resources and arrows
           * Find the arrows' position i.e where it begins and where it ends
           */
          layout.position_arrows = function (full, scoped, scoped_arrows) {
            const { resources } = environment.facet;

            scoped_arrows.forEach(function (arrow) {
              // Calculate source, destination positions
              let src_pos = full.findIndex((r) => {
                return r.id == arrow.src && r.network_id === arrow.network_id;
              });
              let dst_pos = full.findIndex((r) => {
                return r.id == arrow.dst && r.network_id === arrow.network_id;
              });

              // If the source/destination is a resource
              // Must search in the full list, otherwise search in
              // Scoped list, as they could be service tags
              if (resources.find((r) => r.id === arrow.src)) {
                src_pos = full.findIndex((f) => f.id == arrow.src);
              }

              if (resources.find((r) => r.id === arrow.dst)) {
                dst_pos = full.findIndex((f) => f.id == arrow.dst);
              }

              if (src_pos === -1 || dst_pos === -1) return;

              // Caclulate lower, higher positions
              const lower_pos = _.min([src_pos, dst_pos]);
              const higher_pos = _.max([src_pos, dst_pos]);
              const size = higher_pos - lower_pos;

              // New properties
              const positions = {
                lower_pos,
                higher_pos,
                size,
                src_pos,
                dst_pos,
              };

              // Assign new properties to the existing arrows
              Object.assign(arrow, positions);
            });

            return scoped_arrows;
          };

          /**
           * Handy function to get the connected resources
           */
          layout.getConnected = function (resource, type) {
            const connected = [];

            _.each(resource.connections, function (connection) {
              if (connection.remote_resource_id === resource.id) return;

              const connected_to = environment.getResource(
                connection.remote_resource_id
              );

              if (connected_to && connected_to.type === type) {
                connected_to.connection_data = connection.data;
                connected.push(connected_to);
              }
            });
            return connected;
          };

          /**
           * Fetch Network Security Groups
           */
          layout.network_security_groups = function (resources) {
            return resources.filter((r) => r.type === NSG && environment.connectedTo(r, "Resources::Azure::Network::VirtualNetwork").length > 0);
          };

          /**
           * Fetch individual rules by NSGs
           * Map them together by NSG id and return
           */
          layout.network_security_group_rules = function (nsgs) {
            let all_rules = [];

            nsgs.forEach((nsg) => {
              const { id } = nsg;
              let rules = this.getConnected(nsg, RULE);
              let vnet = this.getConnected(nsg, VNET)[0];
              rules.forEach((rule) => {
                rule.nsg_id = id;
                rule.nsg = nsg;
                rule.network_id = vnet.id;
                rule.network_name = vnet.name;
              });
              all_rules = all_rules.concat(rules);
            });

            return all_rules;
          };

          /**
           * Go through all the rules
           * Retreive all sources and destinations
           */
          layout.get_source_destination = function (rules) {
            const endpoints = rules.map((rule) => {
              const { src, dst } = rule;
              return [src, dst];
            });

            return _.uniq(endpoints.flat());
          };

          /**
           * Go through all the resources
           * Find the resources that can be drawn the diagram
           * Return their identifiers
           */
          layout.find_groups = function (resources) {
            const identifiers = {};

            // Subnets
            const subnets = resources.filter((r) => r.type === SUBNET);
            subnets.forEach((subnet) => {
              identifiers[subnet.address_prefix] = subnet;
            });

            // Network Interfaces
            const interfaces = resources.filter((r) => r.type === INTERFACE);
            interfaces.forEach((nic) => {
              const ip_config = this.getConnected(nic, IPCONFIG)[0];
              identifiers[ip_config.private_ipaddress] = nic;
            });

            // Application Security Groups
            const asgs = resources.filter((r) => r.type === ASG);
            asgs.forEach((asg) => {
              identifiers[asg.provider_id] = asg;
            });

            return identifiers;
          };

          /**
           * Need to figure this out later
           * Return all the rules from the raw rules
           */
          layout.create_arrows = function (rules) {
            if (_.isEmpty(rules)) return [];
            const mapped_rules = [];

            rules.forEach(function (rule) {
              const values = rule;

              const source_ports = _.compact(
                _.flatten([values.source_port_ranges, values.source_port_range])
              );

              const destination_ports = _.compact(
                _.flatten([
                  values.destination_port_ranges,
                  values.destination_port_range,
                ])
              );

              const source_ranges = _.compact(
                _.flatten([
                  values.source_address_prefixes,
                  values.source_address_prefix,
                  values.source_application_security_group_id &&
                    values.source_application_security_group_id.toLowerCase(),
                ])
              );

              const destination_ranges = _.compact(
                _.flatten([
                  values.destination_address_prefixes,
                  values.destination_address_prefix,
                  values.destination_application_security_group_id &&
                    values.destination_application_security_group_id.toLowerCase(),
                ])
              );

              const direction = values.direction;

              source_ranges.forEach(function (source_range) {
                destination_ranges.forEach(function (destination_range) {
                  source_ports.forEach(function (source_port) {
                    destination_ports.forEach(function (destination_port) {
                      const r = {
                        src: source_range === "*" ? "Any" : source_range,
                        dst:
                          destination_range === "*" ? "Any" : destination_range,
                        protocol: rule.protocol === "*" ? "ALL" : rule.protocol,
                        from_port: source_port === "*" ? "ALL" : source_port,
                        to_port:
                          destination_port === "*" ? "ALL" : destination_port,
                        direction: direction,
                        access: values.access.toLowerCase(),
                        priority: values.priority,
                        nsg_id: values.nsg_id,
                        nsg: values.nsg,
                        network_id: values.network_id,
                        network_name: values.network_name,
                        provider: "azure",
                      };

                      r.from_proto = portMapper[r.from_port];
                      r.to_proto = portMapper[r.to_port];

                      mapped_rules.push(r);
                    });
                  });
                });
              });
            });

            return mapped_rules;
          };

          /**
           * From the resources that CAN be drawn
           * Pick the resources which are part of the rules
           */
          layout.find_groups_in_rules = function (resources, endpoints) {
            return _.pickBy(resources, function (_, key) {
              return endpoints.includes(key);
            });
          };

          // Now find all the rules in the group that refer to other groups within
          // our collection, so we can create the vertical arrows
          // Now we want to create our arrows, we base these on which rules span
          // from a src to a dst. Groups are Subnets, NIC and ASG
          layout.format_groups_in_arrows = function (groups, arrows) {
            arrows.forEach(function (arrow) {
              if (groups[arrow.src]) arrow.src = groups[arrow.src].id;
              if (groups[arrow.dst]) arrow.dst = groups[arrow.dst].id;
            });

            return arrows;
          };

          // Helper function to test wheter something's an ip or not
          layout.isIP = function (endpoint) {
            const isIp = ipaddr.isValid(endpoint);
            let isCidr = false;

            try {
              ipaddr.parseCIDR(endpoint);
              isCidr = true;
            } catch (e) {
              isCidr = false;
            }

            return isIp || isCidr;
          };

          layout.get_groups = function (groups, arrows) {
            const group_rows = [];

            // Populate the groups with an Id and a name
            arrows.forEach((arrow) => {
              const { src, dst } = arrow;
              [src, dst].forEach((endpoint) => {
                if (groups[endpoint]) {
                  const { id, name } = groups[endpoint];
                  const depth = 2;
                  group_rows.push({ id, resource_id: id, value: name, depth });
                } else {
                  const isIP = this.isIP(endpoint);
                  const value = endpoint;
                  const id = value;
                  group_rows.push({ id, value, depth: isIP ? 3 : 1 });
                }
              });
            });

            // Sort the groups without static resources
            // And append them at the beginning later
            const top = ["Internet", "VirtualNetwork", "Any"];

            const uniq = _.uniqBy(group_rows, "id");
            const resources = uniq.filter((r) => top.indexOf(r.id) === -1);
            resources.sort((r1, r2) => r1.depth - r2.depth);

            const static_r = uniq.filter((r) => top.indexOf(r.id) !== -1);
            static_r.sort((r1, r2) => top.indexOf(r1.id) - top.indexOf(r2.id));

            return static_r.concat(resources);
          };

          // Get Vnet for a given resource
          // Use it for the segragation of the security view by vnet
          layout.getVnetAssociated = function (resource) {
            return environment.connectedTo(resource, "Resources::Azure::Network::VirtualNetwork")[0];
          };

          // Create rows and make sure to order them by vnet
          layout.create_rows = function (vnets, r_map, arrows) {
            let rows = [];
            const { resources } = environment.facet;

            // Separate views
            vnets.forEach((vnet, index) => {
              let vnet_rows = this.get_groups(r_map, arrows);
              vnet_rows = vnet_rows.filter((vnet_row) => {
                const { resource_id } = vnet_row;
                if (resource_id) {
                  const resource = resources.find((r) => r.id === resource_id);

                  // Vnet association
                  const net = this.getVnetAssociated(resource);
                  if (net.id === vnet.id) {
                    vnet_row.network_id = vnet.id;
                    vnet_row.network_name = vnet.name;
                  }
                  return net.id === vnet.id;
                } else {
                  vnet_row.network_id = vnet.id;
                  vnet_row.network_name = vnet.name;
                  return true;
                }
              });

              // Concat them
              // This is where the seperation of the network happens
              rows.push(vnet_rows);
              const blank_row = { id: "blank", name: "blank", type: "blank" };
              const blank_rows = Array(2).fill(blank_row);
              if (vnets.length !== index + 1) rows.push(blank_rows);
            });

            return rows;
          };

          layout.getData = function () {
            const { resources } = environment.facet;

            const vnets = resources.filter((r) => r.type === VNET);

            const nsgs = this.network_security_groups(resources);
            const all_rules = this.network_security_group_rules(nsgs);

            // Make a flat set of rules
            // [{ src, dst, proto, from_port, to_port }]
            let arrows = this.create_arrows(all_rules);

            // This has to be done to make the arrow labels work
            // TODO read ports from the rule itself
            arrows.forEach(function (arrow) {
              arrow.ports = [arrow];
              arrow.id = _.uniqueId();
            });

            // Get all the src and dst (ips,asg) in the rules
            const sources_destinations = this.get_source_destination(arrows);

            // Get an array of hashes containing ip/resource (Subnets, NICS, ASG)
            const available_security_resources_map =
              this.find_groups(resources);

            // Find groups that are resources in the rules
            const resources_map = this.find_groups_in_rules(
              available_security_resources_map,
              sources_destinations
            );

            // Get rows from arrows
            // Create an array of the IPs, Subnets, NICs that make up our rows
            let grouped_rows = this.create_rows(vnets, resources_map, arrows);
            let all_rows = grouped_rows.flat();

            arrows = this.format_groups_in_arrows(resources_map, arrows);

            // Return nothing if there's nothing worth displaying
            if (_.isEmpty(arrows)) return { rows: [], arrows: [] };

            // Pass scoped and full rows for positioning arrows
            // Use full rows for resources and scoped for non-resource types
            vnets.forEach((vnet) => {
              const scoped_rows = all_rows.filter((r) => r.network_id === vnet.id);
              const scoped_arrows = arrows.filter((a) => a.network_id === vnet.id);
              this.position_arrows(all_rows, scoped_rows, scoped_arrows);
            });

            // Sort arrows by NSG, Direction and then Priority
            arrows.sort(function (a1, a2) {
              if (a1.nsg_id === a2.nsg_id) {
                if (a1.direction === a2.direction) {
                  return a1.priority - a2.priority;
                }
                return a1.direction > a2.direction ? 1 : -1;
              }
              return a1.nsg_id > a2.nsg_id ? -1 : 1;
            });

            // Finally return the layout
            return { rows: all_rows, arrows };
          };

          return layout;
        },
      };
    },
  ]);

angular.module('designer.workspace.layout.container.cell', [])
.directive('containerCell',
  ["DesignerConfig", function(DesignerConfig) {
    return {
      templateUrl: '/designer/workspace/layout/container/container.cell.html',
      replace: true,
      controllerAs: "ContainerCell",
      scope: {
        container: "=",
        view: "="
      },
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {

      }],
      link: function(scope, element, attrs, ctrl) {

      }
    }
  }]);

angular.module('designer.workspace.layout.container.hexgrid', [])
.directive('containerHexgrid',
  ["DesignerConfig", function(DesignerConfig) {
    return {
      templateUrl: '/designer/workspace/layout/container/container.hexgrid.html',
      replace: true,
      controllerAs: "ContainerHexgrid",
      scope: {
        container: "=",
        view: "="
      },
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {

      }],
      link: function(scope, element, attrs, ctrl) {

      }
    }
  }]);

angular.module('designer.workspace.views.container.shapes.aws.service',
  ['designer.workspace.canvases.jointjs.shapes.container'])
.service('AWSServiceElement', ["ContainerElement", function(ContainerElement) {
  var prebuilt_markup = V('<g>' +
    '<g class="scalable">' +
    '<rect class="mainRect" />' +
    '</g>' +
    '<text class="type"/>' +
    '<text class="status"/>' +
    '<foreignObject class="infoDisplay">' +
    '<div xmlns="http://www.w3.org/1999/xhtml">' +
    '<div class="details" style="height:20px; direction: rtl; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>' +
    '</div>' +
    '</foreignObject>' +
    '<text class="title"/>' +
    '</g>');

  return ContainerElement.extend({
    prebuilt_markup: prebuilt_markup,
    markup: " ",
    defaults: joint.util.defaultsDeep({
      shape: "aws.subnet",
      size: { width: 200, height: 200 },
      z: 20,
      attrs: {
        '.title': { fill: '#979797' },
        '.details': { fill: '#979797' },
        '.status': { 'font-size': 12, x: -20, y: 20, "text-anchor": "end", fill: 'green', text: '', ref: '.mainRect', 'ref-x': 0.9999999, 'ref-y': 0.0001 },
        '.type': { 'font-size': 12, x: 10, y: 20, fill: 'blue', text: '', ref: '.mainRect' },
        '.infoDisplay': { 'font-size': 11, x: -20, y: -39, width: 360, height: 15, "text-anchor": "end", ref: '.mainRect', 'ref-y': 0.9999999, 'ref-width': 1 },
        '.mainRect': { stroke: '#0e7fba', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, fill: "#FFFFFF" }
      }
    }, ContainerElement.prototype.defaults),

    updateTheme: function() {
      var resource = this.get("resource");
    },

    updateContainerText: function(paper) {
      var resource = this.get("resource");

      var name = resource.name || "";
      var desc = "";
      var status = resource.status || "";
      var el = paper.findViewByModel(this).el;

      if(name !== resource.provider_id) {
        desc = resource.provider_id;
      }

      $(el).find('.details').text(desc);
      this.attr(".title/text", name);
      this.attr(".status/text", status);
      this.attr(".type/text", resource.launch_type || "");
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.cluster',
  ['designer.workspace.canvases.jointjs.shapes.container'])
.service('ClusterElement', ["ContainerElement", function(ContainerElement) {
  var prebuilt_markup = V('<g>' +
    '<g class="scalable">' +
    '<rect class="mainRect" />' +
    '</g>' +
    '<text class="status"/>' +
    '<text class="description1"/>' +
    '<text class="title"/>' +
    '</g>');

  return ContainerElement.extend({
    prebuilt_markup: prebuilt_markup,
    markup: " ",
    defaults: joint.util.defaultsDeep({
      shape: "aws.subnet",
      size: { width: 200, height: 200 },
      z: 15,
      attrs: {
        '.title': { fill: '#979797' },
        '.description1': { fill: '#979797' },
        '.description2': { fill: '#979797' },
        '.status': { 'font-size': 12, x: -20, y: 20, "text-anchor": "end", fill: 'green', text: '', ref: '.mainRect', 'ref-x': 0.9999999, 'ref-y': 0.0001 },
        '.mainRect': { stroke: '#077a07', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, fill: "#FFFFFF" },
        '.subnetGroupDisplay': { ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999, x: 1, y: -55, "ref-width": '96%', "y-alignment": "top", height: 100 }
      }
    }, ContainerElement.prototype.defaults),

    updateTheme: function() {
      var resource = this.get("resource");
    },

    updateContainerText: function(paper) {
      var resource = this.get("resource");

      var name = resource.name || "";
      var desc = "";
      var status = resource.status || "";

      if(name !== resource.provider_id && resource.type !== "Resources::Kubernetes::Cluster::Cluster") {
        desc = resource.provider_id;
      }

      this.attr(".title/text", name);
      this.attr(".description1/text", desc);
      this.attr(".status/text", status);
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.hex.empty',
  ['designer.workspace.views.container.shapes.hex'])
.service('EmptyHexElement', ['HexElement', function(HexElement) {
  return HexElement.extend({
    defaults: joint.util.defaultsDeep({
      attrs: {
        'path': { "stroke": "#A5A5A5", "x": 0, "y": 0, "fill": "none", "stroke-width": 1, "stroke-dasharray": 5  }
      }
    }, HexElement.prototype.defaults),

    updateContainerText: function(paper) {
      // Do noooothing
    },

    updateTheme: function() {
      // Do nothing!
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.hex',
  ['designer.workspace.canvases.jointjs.shapes.resource', 'designer.workspace.views.container.views.hex'])
.service('HexElement', ['ResourceElement', "HexView", function(ResourceElement, HexView) {
  var prebuilt_markup = V('<g class="scalable">' +
    '<circle class="connectionPoint" />' +
    '<path d="M0 43.30127018922193L25 0L75 0L100 43.30127018922193L75 86.60254037844386L25 86.60254037844386Z"></path>' +
    '<text class="description1"/>' +
    '<text class="title"/>' +
    '</g>');

  return ResourceElement.extend({
    view: HexView,
    prebuilt_markup: prebuilt_markup,
    markup: " ",
    defaults: joint.util.defaultsDeep({
      size: { width: 100, height: 86.6 },
      attrs: {
        'path': { "stroke": "black", "x": 0, "y": 0, "fill": "none", "stroke-width": 1  }
      }
    }, ResourceElement.prototype.defaults),

    updateContainerText: function(paper) {
      ResourceElement.prototype.updateContainerText.apply(this, arguments);
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.kubernetes.service',
  ['designer.workspace.canvases.jointjs.shapes.container'])
.service('KubeServiceElement', ["ContainerElement", function(ContainerElement) {
  var prebuilt_markup = V('<g>' +
    '<g class="scalable">' +
    '<rect class="mainRect" />' +
    '</g>' +
    '<use/>' +
    '<text class="label1"/>' +
    '<text class="label2"/>' +
    '<text class="label3"/>' +
    '</g>');

  return ContainerElement.extend({
    prebuilt_markup: prebuilt_markup,
    markup: " ",
    defaults: joint.util.defaultsDeep({
      shape: "aws.subnet",
      size: { width: 200, height: 200 },
      z: 20,
      attrs: {
        '.label1': { 'font-size': 12, x: 55, y: 19, fill: 'black', text: '', ref: '.mainRect' },
        '.label2': { 'font-size': 12, x: 55, y: 36, fill: 'black', text: '', ref: '.mainRect' },
        '.label3': { 'font-size': 12, x: 55, y: 53, fill: 'black', text: '', ref: '.mainRect' },
        'use': { 'width': 40, 'height': 40, 'x':5, 'y':10 },
        '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, rx: 5, ry: 5, fill: "#FFFFFF" }
      }
    }, ContainerElement.prototype.defaults),

    updateTheme: function() {
      var resource = this.get("resource");
      resource.setImageUrl();
      this.attr("use/href", resource.image);
    },

    updateContainerText: function(paper) {
      var resource = this.get("resource");
      var label1 = resource.name;
      var label2 = resource.cluster_ip;
      var label3 = resource.service_type;

      if(label1.length > 30) {
        label1 = label1.substring(0, 29) + "...";
      }

      this.attr(".label1/text", label1);
      this.attr(".label2/text", label2);
      this.attr(".label3/text", label3);
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.load-balancer',
  ['designer.workspace.canvases.jointjs.shapes.container'])
.service('LoadBalancerElement', ["ContainerElement", function(ContainerElement) {
  var prebuilt_markup = V('<g>' +
    '<g class="scalable">' +
    '<rect class="mainRect" />' +
    '</g>' +
    '<use/>' +
    '<text class="label1"/>' +
    '<text class="label2"/>' +
    '<text class="info1"/>' +
    '<text class="info2"/>' +
    '</g>');

  return ContainerElement.extend({
    prebuilt_markup: prebuilt_markup,
    markup: " ",
    defaults: joint.util.defaultsDeep({
      shape: "aws.subnet",
      size: { width: 200, height: 200 },
      z: 25,
      attrs: {
        '.label1': { 'font-size': 12, x: 55, y: 21, fill: 'black', text: '', ref: '.mainRect' },
        '.label2': { 'font-size': 12, x: 55, y: 38, fill: 'black', text: '', ref: '.mainRect' },
        '.info1': { 'font-size': 12, x: 120, y: 21, fill: '#979797', text: '', ref: '.mainRect' },
        '.info2': { 'font-size': 12, x: 120, y: 38, fill: '#979797', text: '', ref: '.mainRect' },
        'use': { 'width': 40, 'height': 40, 'x':5, 'y':5 },
        '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, rx: 5, ry: 5, fill: "#FFFFFF" }
      }
    }, ContainerElement.prototype.defaults),

    updateTheme: function() {
      var resource = this.get("resource");
      resource.setImageUrl();
      this.attr("use/href", resource.image);
    },

    updateContainerText: function() {
      var resource = this.get("resource");
      var label1 = "Container";
      var label2 = "Port";
      var info1 = "";
      var info2 = "";

      // Get connection data
      var connection = _.find(resource.connections, function(c) {
        return c.remote_resource_type === "Resources::AWS::ElasticLoadBalancing::LoadBalancer" ||
          c.remote_resource_type === "Resources::AWS::ElasticLoadBalancingV2::TargetGroup"
      });

      // Build up some infooooooo container_name, container_port
      if (connection) {
        var data = connection["data"];
        info1 = data["container_name"];
        info2 = data["container_port"];
      }

      this.attr(".label1/text", label1);
      this.attr(".label2/text", label2);
      this.attr(".info1/text", info1);
      this.attr(".info2/text", info2);
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.namespace',
  ['designer.workspace.views.container.shapes.aws.service'])
.service('NamespaceElement', ["AWSServiceElement", function(AWSServiceElement) {
  return AWSServiceElement.extend({
    defaults: joint.util.defaultsDeep({
      z: 18
    }, AWSServiceElement.prototype.defaults),

    updateContainerText: function(paper) {
      var resource = this.get("resource");

      var name = resource.name || "";
      var status = resource.status || "";

      this.attr(".title/text", name);
      this.attr(".status/text", status);
      this.attr(".type/text", resource.launch_type || "");
    }
  });
}]);

angular.module('designer.workspace.views.container.shapes.workload',
  ['designer.workspace.views.container.shapes.aws.service'])
.service('WorkloadElement', ["AWSServiceElement", function(AWSServiceElement) {
  return AWSServiceElement.extend({
    defaults: joint.util.defaultsDeep({
      z: 18
    }, AWSServiceElement.prototype.defaults),

    updateContainerText: function(paper) {
      var resource = this.get("resource");

      var name = resource.name || "";
      var desc = resource.type_name;
      var status = resource.status || "";
      var el = paper.findViewByModel(this).el;

      $(el).find('.details').text(desc);
      this.attr(".title/text", name);
      this.attr(".status/text", status);
      this.attr(".type/text", resource.launch_type || "");
    }
  });
}]);

angular.module('designer.workspace.views.container.views.hex', [])
.service('HexView', ["$location", function($location) {
  return joint.dia.ElementView.extend({
    highlighted: false,
    faded: false,

    events: {
      'mouseout': 'unhighlight',
      'dragleave': 'unhighlight',
      'dragover':  'dragover'
    },

    initialize: function() {
      joint.dia.ElementView.prototype.initialize.apply(this, arguments);
      var resource = this.model.get('resource');

      if (resource) {
        var status_color = resource.status_list[resource.status];

        if (status_color === "good") {
          this.model.attr("path/fill", "#aadebd");
        }
        else if (status_color === "warn") {
          this.model.attr("path/fill", "#fff494");
        }
        else if (status_color === "bad") {
          this.model.attr("path/fill", "#fabdb3");
        }
        else {
          this.model.attr("path/fill", "#dcdcdc");
        }
      }

      this.listenTo(this.model, 'change:position', this.geometrychange);
      this.listenTo(this.model, 'change:size', this.geometrychange);

      // Update the resource so we have geometry even if they don't move / resize it :P
      this.geometrychange();
    },

    renderStringMarkup: function() {
      var vel = this.vel;
      vel.append(this.model.prebuilt_markup.clone());
      // Cache transformation groups
      this.rotatableNode = vel.findOne('.rotatable');
      this.scalableNode = vel.findOne('.scalable');

      var selectors = this.selectors = {};
      selectors[this.selector] = this.el;
    },

    geometrychange: function() {
      var s = this.model.get('resource');
      if(s) {
        s.geometry = _.extend(this.model.get('position'), this.model.get('size'));
      }
    },

    select: function(instant) {
      var opts = instant ? { delay: 0, duration: 0 }  :
        { delay: 0, duration: 150, timingFunction: joint.util.timing.linear };

      this.model.set("z", 50);
      this.model.attr("path/stroke-width", 3);
      this.model.translate(-5, -5, opts);
      this.model.resize(this.model.attributes.size["width"] + 10, this.model.attributes.size["height"] + 10, opts);
    },

    deselect: function() {
      var opts = {
        delay: 0,
        duration: 150,
        timingFunction: joint.util.timing.linear
      };


      this.model.set("z", 40);
      this.model.attr("path/stroke-width", 1);
      this.model.translate(5, 5, opts);
      this.model.resize(this.model.attributes.size["width"] - 10, this.model.attributes.size["height"] - 10, opts);
    },

    highlight: function(invalid) {
      if(this.highlighted) return;

      var colour = invalid ?  "#F04124" : "#077a07";

      this.model.attr("path/filter", "url(" + $location.absUrl() + "#highlightedResourceFilter)");

      this.highlighted = true;
    },

    unhighlight: function() {
      if(!this.highlighted) return;

      this.model.attr("path/filter", "");

      this.highlighted = false;
    },

    fade: function() {
      var opts = {
        delay: 0,
        duration: 150,
        timingFunction: joint.util.timing.linear
      };

      this.model.transition('attrs/g/opacity', 0.4, opts);

      this.faded = true;
    },

    unfade: function() {
      var opts = {
        delay: 0,
        duration: 150,
        timingFunction: joint.util.timing.linear
      };

      this.model.transition('attrs/g/opacity', 1, opts);

      this.faded = false;
    },

    updateTheme: function() {
      this.model.updateTheme(this);
    },

    pointermove: function(evt, x, y) {
      // If the paper is locked then do nothing
      if(this.paper.locked) return;

      joint.dia.ElementView.prototype.pointermove.apply(this, arguments);
    }
  });
}]);

angular.module('designer.workspace.layout.infrastructure.container', [

])
.directive('infrastructureContainer',
  ["DesignerConfig", function(DesignerConfig) {
    return {
      templateUrl: '/designer/workspace/layout/infrastructure/infrastructure.container.html',
      replace: true,
      controllerAs: "InfrastructureContainer",
      scope: {
        container: "=",
        view: "="
      },
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {

      }],
      link: function(scope, element, attrs, ctrl) {

      }
    }
  }]);

angular.module('designer.workspace.layout.infrastructure.parent', [

])
.directive('infrastructureParent',
  ["DesignerConfig", function(DesignerConfig) {
    return {
      templateUrl: '/designer/workspace/layout/infrastructure/infrastructure.parent.html',
      replace: true,
      controllerAs: "InfrastructureParent",
      scope: {
        container: "=",
        view: "="
      },
      controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        $scope.generic = function (item) { 
          return item.startsWith("generic"); 
        };

        $scope.regular = function (item) { 
          return !item.startsWith("generic"); 
        };
      }],
      link: function(scope, element, attrs, ctrl) {

      }
    }
  }]);

angular.module('designer.workspace.views.infrastructure-info.shapes.elb', ['designer.workspace.views.infrastructure-info.shapes.resource'])
  .service('InfrastructureInfoELBElement', ['InfrastructureInfoResourceElement', 'DesignerState', function(InfrastructureInfoResourceElement, DesignerState) {
    var prebuilt_markup = V('<g>' +
      '<circle class="selected" />' +
      '<circle class="border" />' +
      '<circle class="connectionPoint" />' +
      '<use></use>' +
      '<circle class="badge" />' +
      '<text class="badgeText"/>' +
      '<text class="title"/>' +
      '<rect class="infoContainer"></rect>' +
      '<foreignObject class="infoDisplay">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<p class="info" style="line-height:1; text-align: center; overflow: hidden; font-size: 15px; word-break: break-all"></p>' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return InfrastructureInfoResourceElement.extend({
      markup: " ",
      prebuilt_markup: prebuilt_markup,

      defaults: joint.util.defaultsDeep({
        attrs: {
          '.infoContainer': { x: -94, y: 75, width: 260, height: 50, "fill-opacity": 0 },
          '.infoDisplay': { x: -86, y: 78, width: 244, height: 66, color: '#111111' }
        }
      }, InfrastructureInfoResourceElement.prototype.defaults),

      updateContainerText: function(paper) {
        InfrastructureInfoResourceElement.prototype.updateContainerText.apply(this, arguments);

        var el       = paper.findViewByModel(this).el;
        var resource = this.get("resource");

        $(el).find('.info').text(resource.dns_name || resource.name || "");
      },

      geometrychange: function() {
        var width = DesignerState.get("layout")["Views::Infrastructure::Extended"].resource_width;
        var height = DesignerState.get("layout")["Views::Infrastructure::Extended"].resource_height;
        this.attr(".infoContainer/x", (-78 - width));
        this.attr(".infoContainer/height", (-14 + height));
        this.attr(".infoContainer/width", (244 + (width*2)));

        this.attr(".infoDisplay/x", (-70 - width));
        this.attr(".infoDisplay/height", (2 + height));
        this.attr(".infoDisplay/width", (228 + (width*2)));
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure-info.shapes.resource', ['designer.workspace.canvases.jointjs.shapes.resource'])
  .service('InfrastructureInfoResourceElement', ['ResourceElement', 'DesignerState', function(ResourceElement, DesignerState) {
    var prebuilt_markup = V('<g>' +
      '<circle class="selected" />' +
      '<circle class="border" />' +
      '<circle class="connectionPoint" />' +
      '<use></use>' +
      '<text class="iconInfo"/>' +
      '<circle class="badge" />' +
      '<text class="badgeText"/>' +
      '<text class="title"/>' +
      '<foreignObject class="nameContainer">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<p class="name" style="line-height:1; text-align: center; overflow: hidden; word-wrap: break-word;"></p>' +
      '</div>' +
      '</foreignObject>' +
      '<rect class="infoContainer"></rect>' +
      '<foreignObject class="infoDisplay">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<div class="info1" style="height:20px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>' +
      '<div class="info2" style="height:20px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>' +
      '<div class="info3" style="height:20px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return ResourceElement.extend({
      showExtendedInfo: true,
      markup: " ",
      prebuilt_markup: prebuilt_markup,

      defaults: joint.util.defaultsDeep({
        attrs: {
          '.infoContainer': { x: 75, y: 0, width: 125, height: 70, "fill-opacity": 0 },
          '.infoDisplay': { 'font-size': 14, x: 76, y: 4, width: 129, height: 66, color: '#111111' },
          '.nameContainer': { width: 200 }
        }
      }, ResourceElement.prototype.defaults),

      updateContainerText: function(paper) {
        ResourceElement.prototype.updateContainerText.apply(this, arguments);

        var el       = paper.findViewByModel(this).el;
        var resource = this.get("resource");
        var info     = resource.getExtendedInformation();

        $(el).find('.info1').text(info.info1 || "");
        $(el).find('.info2').text(info.info2 || "");
        $(el).find('.info3').text(info.info3 || "");

        // If the provider ID is super long then make it display right to left so we can see the end
        if (info.info1 && info.info1.length > 30) {
          $(el).find('.info1').css("direction", "rtl");
        }
      },

      geometrychange: function() {
        var width = DesignerState.get("layout")["Views::Infrastructure::Extended"].resource_width;
        var height = DesignerState.get("layout")["Views::Infrastructure::Extended"].resource_height;
        this.attr(".nameContainer/height", (16 + height));
        this.attr(".nameContainer/width", (184 + width));

        this.attr(".infoDisplay/width", (113 + width));
        this.attr(".infoContainer/width", (109 + width));
      }
    });
  }]);

angular.module('designer.workspace.views.security.shapes.arrow.azure', [
    'designer.workspace.canvases.jointjs.shapes.container',
    'designer.workspace.views.security.views.arrow'
  ])
    .service('AzureArrowElement', ["ContainerElement", "ArrowView", function(ContainerElement, ArrowView) {
      var prebuilt_markup = V('<g class="main">' +
        '<g class="triangle">' +
          '<polyline class="mainRect tri" points="15,75 0,75 50,25 100,75 85,75" stroke="#000000" id="polyline1" fill="white" transform="" stroke-width="2"></polyline>' +
        '</g>' +
  
        '<g class="triangle2" opacity="0">' +
          '<polyline class="mainRect tri" points="15,75 0,75 50,25 100,75 85,75" stroke="#000000" id="polyline2" fill="white" transform="" stroke-width="2"></polyline>' +
        '</g>' +
  
        '<g class="rectangle">' +
          '<rect class="rectangle" fill="#ffffff" x="15" y="50" width="70" height="150"></rect>' +
          '<line class="rectangle mainRect" stroke="#000000" y1="50px" id="line1" x1="15px" y2="200px" x2="15px"></line>' +
          '<line class="rectangle mainRect" stroke="#000000" y1="50px" x1="85px" id="line2" y2="200px" x2="85px"></line>' +
          '<text class="direction" font-size="20px" style="writing-mode: vertical-rl;text-orientation: mixed;" x="50" y="15" fill="black">INBOUND</text>' +
        '</g>' +
  
        '<foreignObject class="arrow-info">' +
          '<div xmlns="http://www.w3.org/1999/xhtml">' +
            '<div class="securityRowTitle"></div>' +
          '</div>' +
        '</foreignObject>' +
  
        '</g>');
  
      return ContainerElement.extend({
        view: ArrowView,
        prebuilt_markup: prebuilt_markup,
        markup: " ",
        selectBorderColor: "#FF00FF",
        defaults: joint.util.defaultsDeep({
          size: { width: 500, height: 500 },
          z: 15,
          attrs: {
            '.arrow-info': { x: 90, y: -60, width: 100, rotate: '-45deg', height: 80, ref: '.rectangle', 'ref-y': 0.9999999 }
          }
        }, ContainerElement.prototype.defaults),
  
        updateContainerText: function(paper) {
          var info = this.get("info");
          const { src_pos, dst_pos } = info;
  
          var color = "#000000"
          if (info["access"] === "allow") {
            color = "#008000";
          } else if (info["access"] === "deny"){
            color = "#ff0000";
          }
  
          const { label,label_length } = this.buildArrowLabel(info["ports"]);
          var text_height = label_length*33+33;
  
          var rect_height = info["h"]-125;
          this.attr(".rectangle/height", info["h"]-125);
          this.attr(".rectangle/y2", info["h"]-75);
          this.attr(".triangle2/opacity", 0);
          this.attr(".mainRect/stroke", color);
          this.attr(".mainRect/stroke-width", 3);
          this.attr(".arrow-info/height", text_height);
          this.attr(".arrow-info/y", -rect_height/2-text_height/2);
  
          if(dst_pos < src_pos) {
            this.attr(".rectangle/y", "75px");
            this.attr(".rectangle/y1", "75px");
            this.attr(".rectangle/y2", info["h"]-50);
          }
          else if(dst_pos > src_pos) {
            this.attr(".triangle/transform", "translate(0, "+info["h"]+") scale(1, -1)");
          }
  
          if (info["direction"]) {
            this.attr(".direction/y", info["h"]/2 - 55);
            this.attr(".direction/text", info["direction"].toUpperCase());
          }
  
          var el = paper.findViewByModel(this).el;
          $(el).find('.securityRowTitle').append($(label));
        },
  
        buildArrowLabel: function(info_ports) {
          var ports = {};
          _.each(info_ports, function(p) {
            if (p["ports"] !== "ALL") {
              if (!ports[p["protocol"]]) { ports[p["protocol"]] = [] }
              ports[p["protocol"]].push(p);
            }
          });
  
          var label = '';
          var label_length = 0
          if (Object.keys(ports).length) {
            _.each(ports, function(prts, protocol) {
              label_length += _.uniq(prts).length + 1;
  
              if(protocol.toUpperCase() !== "ALL") {
                label += '<div>'+ protocol.toUpperCase() + '</div>';
  
                _.each(prts, function(port_rule) {
                  var from = port_rule.from_port;
                  var to = port_rule.to_port;
                  label += `<div><strong>F: ${from}</strong><br />`
                  label += `<strong>T: ${to}</strong></div>`
                });
              }
              else {
                label += '<div style="text-align: center">'+ protocol.toUpperCase() + '</div>';
              }
            });
          } else {
            label = '<div style="text-align: center">All</div>'
          }
          return { label: label, label_length: label_length };
        },
      });
    }]);
  
angular.module('designer.workspace.views.security.shapes.arrow.horizontal', [
    'designer.workspace.canvases.jointjs.shapes.container',
    'designer.workspace.views.security.views.arrow'
  ])
    .service('HorizontalArrowElement', ["ContainerElement", "ArrowView", function(ContainerElement, ArrowView) {
      var prebuilt_markup = V('<g class="main" transform="translate(-20, 0)">' +
        '<g class="triangle">' +
        '<polyline class="mainRect tri" points="75,10 75,-5 25,45 75,95 75,80" stroke="#000000" id="polyline1" fill="white" transform="" stroke-width="2"></polyline>' +
        '</g>' +
  
        '<g class="triangle2" opacity="0">' +
        '<polyline class="mainRect tri" points="75,10 75,-5 25,45 75,95 75,80" stroke="#000000" id="polyline2" fill="white" transform="" stroke-width="2"></polyline>' +
        '</g>' +
  
        '<g class="rectangle">' +
        '<rect class="rectangle" fill="#ffffff" x="15" y="10" width="70" height="70"></rect>' +
        '<line class="rectangle mainRect" stroke="#000000" x1="50px" id="line1" y1="10px" x2="200px" y2="10px"></line>' +
        '<line class="rectangle mainRect" stroke="#000000" x1="50px" id="line2" y1="80px" x2="200px" y2="80px"></line>' +
        '<text class="direction" font-size="20px" x="47" y="52" fill="black">INBOUND</text>' +
        '</g>' +
  
        '<foreignObject class="arrow-info">' +
        '<div xmlns="http://www.w3.org/1999/xhtml">' +
        '<div class="securityRowTitle"></div>' +
        '</div>' +
        '</foreignObject>' +
        '</g>');
  
      return ContainerElement.extend({
        view: ArrowView,
        prebuilt_markup: prebuilt_markup,
        markup: " ",
        selectBorderColor: "#FF00FF",
        defaults: joint.util.defaultsDeep({
          size: { width: 500, height: 500 },
          z: 15,
          attrs: {
            '.arrow-info': { x: 17, y: -60, width: 66, rotate: '-45deg', height: 80, ref: '.rectangle', 'ref-y': 0.9999999 }
          }
        }, ContainerElement.prototype.defaults),
  
        updateContainerText: function(paper) {
          var info = this.get("info");
          info["h"] = 200; 
  
          var color = "#000000"
          if (info["access"] === "allow") {
            color = "#008000";
          } else if (info["access"] === "deny"){
            color = "#ff0000";
          }

          if (info["access"] === "allow") {
            this.attr(".rectangle/fill", "#b5ebc7");
            this.attr(".tri/fill", "#b5ebc7");
            this.attr(".arrow-info/y", -info["h"]/2+text_height/2+25);
          } else {
            this.attr(".rectangle/fill", "#ffa2a2");
            this.attr(".tri/fill", "#ffa2a2");
            this.attr(".arrow-info/y", -info["h"]/2+text_height/2+25);
          }
  
          const { label,label_length } = this.buildArrowLabel(info["ports"]);
          var text_height = label_length*33+33;
  
          var rect_height = info["h"]-125;
          this.attr(".rectangle/width", info["h"]-125);
          this.attr(".rectangle/x2", info["h"]-75);
          this.attr(".triangle2/opacity", 0);
          this.attr(".mainRect/stroke", color);
          this.attr(".mainRect/stroke-width", 3);
          this.attr(".arrow-info/height", text_height);
          this.attr(".arrow-info/y", -rect_height/2-text_height/2);
  
          this.attr(".rectangle/x", "75px");
          this.attr(".rectangle/x1", "75px");
          this.attr(".rectangle/width", info["h"]-150);
          this.attr(".triangle2/transform", "translate("+info["h"]+",0) scale(-1, 1)");
          this.attr(".triangle2/opacity", 1);
          this.attr(".arrow-info/x", -info["h"]/2+text_height/2);

          this.attr(".direction/text", info["direction"].toUpperCase());
  
          var el = paper.findViewByModel(this).el;
          $(el).find('.securityRowTitle').append($(label));
        },
  
        buildArrowLabel: function(info_ports) {
          var ports = {};
          _.each(info_ports, function(p) {
            if (p["ports"] !== "ALL") {
              if (!ports[p["protocol"]]) { ports[p["protocol"]] = [] }
              ports[p["protocol"]].push(p);
            }
          });
  
          var label = '';
          var label_length = 0
          if (Object.keys(ports).length) {
            _.each(ports, function(prts, protocol) {
              label_length += _.uniq(prts).length + 1;
  
              if(protocol.toUpperCase() !== "ALL") {
                label += '<div>'+ protocol.toUpperCase() + '</div>';
  
                _.each(prts, function(port_rule) {
                  var from = port_rule.from_port;
                  var to = port_rule.to_port;
                  label += `<div><strong>F: ${from}</strong><br />`
                  label += `<strong>T: ${to}</strong></div>`
                });
              }
              else {
                label += '<div style="text-align: center">'+ protocol.toUpperCase() + '</div>';
              }
            });
          } else {
            label = '<div style="text-align: center">All</div>'
          }
          return { label: label, label_length: label_length };
        },
      });
    }]);
  
angular.module('designer.workspace.views.security.shapes.arrow', [
  'designer.workspace.canvases.jointjs.shapes.container',
  'designer.workspace.views.security.views.arrow'
])
  .service('ArrowElement', ["ContainerElement", "ArrowView", function(ContainerElement, ArrowView) {
    var prebuilt_markup = V('<g>' +
      '<g class="triangle">' +
      '<polyline class="mainRect" points="15,75 0,75 50,25 100,75 85,75" stroke="#000000" id="polyline1" fill="none" transform="" stroke-width="2"></polyline>' +
      '</g>' +

      '<g class="triangle2" opacity="0">' +
      '<polyline class="mainRect" points="15,75 0,75 50,25 100,75 85,75" stroke="#000000" id="polyline2" fill="none" transform="" stroke-width="2"></polyline>' +
      '</g>' +

      '<g class="rectangle">' +
      '<rect class="rectangle" fill="#ffffff" x="15" y="50" width="70" height="150"></rect>' +
      '<line class="rectangle mainRect" stroke="#000000" y1="50px" id="line1" x1="15px" y2="200px" x2="15px"></line>' +
      '<line class="rectangle mainRect" stroke="#000000" y1="50px" x1="85px" id="line2" y2="200px" x2="85px"></line>' +
      '</g>' +

      '<foreignObject class="arrow-info">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<div class="securityRowTitle"></div>' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return ContainerElement.extend({
      view: ArrowView,
      prebuilt_markup: prebuilt_markup,
      markup: " ",
      selectBorderColor: "#FF00FF",
      defaults: joint.util.defaultsDeep({
        size: { width: 500, height: 500 },
        z: 15,
        attrs: {
          '.arrow-info': { x: 17, y: -60, width: 66, height: 80, ref: '.rectangle', 'ref-y': 0.9999999 }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var info = this.get("info");

        var color = "#000000"
        if (info["access"] === "allow") {
          color = "#008000";
        } else if (info["access"] === "deny"){
          color = "#ff0000";
        }

        const { label,label_length } = this.buildArrowLabel(info["ports"]);
        var text_height = label_length*33+33;

        var rect_height = info["h"]-125;
        this.attr(".rectangle/height", info["h"]-125);
        this.attr(".rectangle/y2", info["h"]-75);
        this.attr(".triangle2/opacity", 0);
        this.attr(".mainRect/stroke", color);
        this.attr(".mainRect/stroke-width", 2);
        this.attr(".arrow-info/height", text_height);
        this.attr(".arrow-info/y", -rect_height/2-text_height/2);

        if(info["direction"] === "up") {
          this.attr(".rectangle/y", "75px");
          this.attr(".rectangle/y1", "75px");
          this.attr(".rectangle/y2", info["h"]-50);
        }
        else if(info["direction"] === "down") {
          this.attr(".triangle/transform", "translate(0, "+info["h"]+") scale(1, -1)");
        }
        else {
          this.attr(".rectangle/y", "75px");
          this.attr(".rectangle/y1", "75px");
          this.attr(".rectangle/height", info["h"]-150);
          this.attr(".triangle2/transform", "translate(0, "+info["h"]+") scale(1, -1)");
          this.attr(".triangle2/opacity", 1);
          this.attr(".arrow-info/y", -info["h"]/2+text_height/2+25);
        }

        var el = paper.findViewByModel(this).el;
        $(el).find('.securityRowTitle').append($(label));
      },

      buildArrowLabel: function(info_ports) {
        var ports = {};
        _.each(info_ports, function(p) {
          if (p["ports"] !== "ALL") {
            if (!ports[p["protocol"]]) { ports[p["protocol"]] = [] }
            if (p["from_port"] == p["to_port"]) {
              ports[p["protocol"]].push(parseInt(p["from_port"]));
            } else {
              ports[p["protocol"]].push(`${parseInt(p["from_port"])}-${parseInt(p["to_port"])}`);
            }
          }
        });

        var label = '';
        var label_length = 0
        if (Object.keys(ports).length) {
          _.each(ports, function(prts, protocol) {
            label_length += _.uniq(prts).length + 1;

            if(protocol.toUpperCase() !== "ALL") {
              label += '<div>'+ protocol.toUpperCase() + '</div>';
              label += '<div><strong>' + _.uniq(prts).sort(function (a, b) {  return a - b;  }).join('<br />') + '</strong></div><br />'
            }
            else {
              label += '<div style="text-align: center">'+ protocol.toUpperCase() + '</div>';
            }
          });
        } else {
          label = '<div style="text-align: center">All</div>'
        }
        return { label: label, label_length: label_length };
      },
    });
  }]);
angular.module('designer.workspace.views.security.shapes.nsg', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('NSGElement', ["ContainerElement", function(ContainerElement) {
    var prebuilt_markup = V('<g>' +
      '<g class="scalable">' +
      '<rect class="mainRect" />' +
      '</g>' +
      '<text class="description1"/>' +
      '<foreignObject class="security-view-row">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<div class="securityGroupTitle" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: flex; align-items: center;"></div>' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return ContainerElement.extend({
      prebuilt_markup: prebuilt_markup,
      markup: " ",
      selectBorderColor: "#979797",
      defaults: joint.util.defaultsDeep({
        size: { width: 500, height: 500 },
        z: 5,
        attrs: {
          '.title': { 'font-size': 28, x: 20, y: -10, "text-anchor": "start", fill: '#4F4F4F', text: '', ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999 },
          '.description1': { 'font-size': 18, x: 45, y: -50, "text-anchor": "start", fill: '#4F4F4F', text: '', ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999 },
          '.mainRect': { stroke: '#00a2ed', "stroke-width": 1.5, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 },
          '.rectangle': { width:40, height:126, x:1, y:1.3},
          '.security-view-row': { 'font-size': 28, x: 45, y: -90, width: 700, height: 80, ref: '.mainRect', 'ref-y': 0.9999999}
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource") || {type: ''};
        var short_type = resource.type.split("::")[3];
        var color = resource.name ?  "#80da80" : "#e06262";
        this.attr(".rectangle/fill", color);

        var info = '';
        info += resource.image ? '<svg><use xlink:href="' + resource.image + '" /></svg>' : '<span class="octicon octicon-globe"></span>';
        info += `<span>${short_type} - ${resource.name || this.name}</span>`;
        var el = paper.findViewByModel(this).el;
        $(el).find('.securityGroupTitle').append($(info));

        if (resource.provider_type === 'aws') { this.attr(".description1/text", (resource.provider_id || ""))}; 
      }
    });
  }]);

angular.module('designer.workspace.views.security.shapes.security-group.azure', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('AzureSecurityGroupElement', ["ContainerElement", function(ContainerElement) {
    var prebuilt_markup = V('<g>' +
      '<g><rect class="rectangle"></rect></g>' +
      '<g class="scalable">' +
      '<rect class="mainRect" />' +
      '</g>' +
      '<text class="description1"/>' +
      '<foreignObject class="security-view-row-azure">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<div class="securityGroupTitle" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: flex; align-items: center;"></div>' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return ContainerElement.extend({
      prebuilt_markup: prebuilt_markup,
      markup: " ",
      selectBorderColor: "#e3e3e3",
      defaults: joint.util.defaultsDeep({
        size: { width: 500, height: 500 },
        z: 10,
        attrs: {
          '.title': { 'font-size': 28, x: 20, y: -10, "text-anchor": "start", fill: '#4F4F4F', text: '', ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999 },
          '.description1': { 'font-size': 18, x: 45, y: -50, "text-anchor": "start", fill: '#4F4F4F', text: '', ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999 },
          '.mainRect': { stroke: '#e3e3e3', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 },
          '.rectangle': { width:40, height:126, x:1, y:1.3},
          '.security-view-row-azure': { 'font-size': 28, x: 45, y: -105, width: 600, height: 80, ref: '.mainRect', 'ref-y': 0.9999999}
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");
        var short_type = resource.type.split("::")[3];
        var color;

        if (resource) {
          color = "#80da80";
        }
        
        if (short_type === "GlobalResource") {
          color = this.isIP(resource.name) ? "#80da80" : "#00a2ed";
        }

        if (resource.name.toLowerCase() == "internet") {
          color = "#e06262";
        }

        this.attr(".rectangle/fill", color);

        var info = '';

        if (short_type === "GlobalResource") {
          info += `<span>&nbsp;&nbsp;&nbsp;${resource.name || this.name}</span>`;
        } else {
          info += resource.image ? '<svg><use xlink:href="' + resource.image + '" /></svg>' : '<span class="octicon octicon-globe"></span>';
          info += `<div class='row-description'"><p>${short_type}</p><p>${resource.name || this.name}</p></div>`;
        }


        var el = paper.findViewByModel(this).el;
        $(el).find('.securityGroupTitle').append($(info));
      },

      isIP: function(endpoint) {
        const isIp = ipaddr.isValid(endpoint);
        let isCidr = false;

        try {
          ipaddr.parseCIDR(endpoint);
          isCidr = true;
        } catch (e) {
          isCidr = false;
        }

        return isIp || isCidr;
      }
    });
  }]);

angular.module('designer.workspace.views.security.shapes.security-group', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('SecurityGroupElement', ["ContainerElement", function(ContainerElement) {
    var prebuilt_markup = V('<g>' +
      '<g><rect class="rectangle"></rect></g>' +
      '<g class="scalable">' +
      '<rect class="mainRect" />' +
      '</g>' +
      '<text class="description1"/>' +
      '<foreignObject class="security-view-row">' +
      '<div xmlns="http://www.w3.org/1999/xhtml">' +
      '<div class="securityGroupTitle" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></div>' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return ContainerElement.extend({
      prebuilt_markup: prebuilt_markup,
      markup: " ",
      selectBorderColor: "#979797",
      defaults: joint.util.defaultsDeep({
        size: { width: 500, height: 500 },
        z: 10,
        attrs: {
          '.title': { 'font-size': 28, x: 20, y: -10, "text-anchor": "start", fill: '#4F4F4F', text: '', ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999 },
          '.description1': { 'font-size': 18, x: 45, y: -50, "text-anchor": "start", fill: '#4F4F4F', text: '', ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999 },
          '.mainRect': { stroke: '#979797', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 },
          '.rectangle': { width:40, height:126, x:1, y:1.3},
          '.security-view-row': { 'font-size': 28, x: 45, y: -45, width: 600, height: 80, ref: '.mainRect', 'ref-y': 0.9999999}
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource") || {};
        var color = resource.name ?  "#80da80" : "#e06262";
        this.attr(".rectangle/fill", color);

        var info = '';
        info += resource.image ? '<svg><use xlink:href="' + resource.image + '" /></svg>' : '<span class="octicon octicon-globe"></span>';
        info += '<span>' + (resource.name || this.name) + '</span>';
        var el = paper.findViewByModel(this).el;
        $(el).find('.securityGroupTitle').append($(info));

        if (resource.provider_type === 'aws') { this.attr(".description1/text", (resource.provider_id || ""))}; 
      }
    });
  }]);
angular.module('designer.workspace.views.security.views.arrow', ['designer.workspace.canvases.jointjs.views.container'])
.service('ArrowView', ["ContainerView", function(ContainerView) {
  return ContainerView.extend({
    select: function(instant) {
      var opts = instant ? { delay: 0, duration: 0 }  :
        { delay: 0, duration: 150 };

      opts.valueFunction = joint.util.interpolate.hexColor;
      this.containerBorderColor = this.model.attr(".mainRect/stroke");
      this.model.transition('attrs/.mainRect/stroke-width', 5, { delay: 0, duration: 150 });

      this.selected = true;
    },

    deselect: function() {
      var opts = {
        delay: 0,
        duration: 150,
        timingFunction: joint.util.timing.linear
      };

      opts.valueFunction = joint.util.interpolate.hexColor;
      this.model.transition('attrs/.mainRect/stroke-width', 2, { delay: 0, duration: 150 });

      this.selected = false;
    },
  });
}]);

angular.module('designer.workspace.views.list.control', ["designer.app-scope"])
  .directive('listControl',
    ["$rootScope", "$appScope", "$window", function($rootScope, $appScope, $window) {
      return {
        templateUrl: '/designer/workspace/views/list/control.html',
        replace: true,
        controllerAs: "ListControl",
        controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
          this.options = {
            sort_by: "name",
            sort_dir: "asc",
            display_types: [],
            show_service_select: false
          };
          this.sort_options = ["name", "price", "type"];
          this.types = { "AWS": [], "Azure": [], "GCP": [], "Kubernetes": [] };
          this.types_readable = "All";
          this.resources = _.compact($scope.resources);
          this.unfiltered_resources = angular.copy(this.resources);
          this.selected_resource = null;

          this.loadResourceTypes = function() {
            _.each(this.resources, function(resource) {
              var parts = resource.type.split("::");
              var provider = parts[1];
              var type = parts[2];

              if(this.types[provider]) {
                var exists = _.filter(this.types[provider], function(t) { return t === type }).length > 0;
                if (!exists) {
                  this.types[provider].push(type);
                }
              }
            }.bind(this));

            this.types["AWS"] = _.sortBy(this.types["AWS"], function(type) { return type; });
            this.types["Azure"] = _.sortBy(this.types["Azure"], function(type) { return type; });
            this.types["GCP"] = _.sortBy(this.types["GCP"], function(type) { return type; });
            this.types["Kubernetes"] = _.sortBy(this.types["Kubernetes"], function(type) { return type; });
          };
          
          this.sortResources = function() {
            this.resources = _.sortBy(this.resources, function(resource) {
              if(this.options.sort_by === 'name') {
                return (resource.name || "").toLowerCase();
              }
              else if(this.options.sort_by === 'type') {
                return resource.type;
              }
              else if(this.options.sort_by === 'price') {
                return resource.price || 0;
              }
              else {
                return resource.provider_id;
              }
            }.bind(this));

            if (this.options.sort_dir === "desc") {
              this.resources.reverse();
            }
          };

          this.toggleTypeDisplay = function(provider, type) {
            if (!provider) {
              this.options.display_types = [];
            }
            else if (this.isToggled(provider, type)) {
              this.options.display_types = _.reject(this.options.display_types, function(v) { return v.provider === provider && v.type === type });
            }
            else {
              this.options.display_types.push({ provider: provider, type: type});
            }

            // Filter by type then re-sort
            this.resources = _.filter(this.unfiltered_resources, function(r) {
              var parts = r.type.split("::");
              var provider = parts[1];
              var type = parts[2];

              return this.options.display_types.length === 0 || this.isToggled(provider, type);
            }.bind(this));
            this.sortResources();

            // Update display
            if (this.options.display_types.length === 0) {
              this.types_readable = "All";
            }
            else if (this.options.display_types.length === 1) {
              this.types_readable = this.options.display_types[0].type;
            }
            else {
              this.types_readable = this.options.display_types.length + " types";
            }
          };

          this.isToggled = function(provider, type) {
            return _.filter(this.options.display_types, function(t) { return t.provider === provider && t.type === type }).length;
          };

          this.toggleSortDirection = function() {
            this.options.sort_dir = (this.options.sort_dir === "asc" ? "desc" : "asc");
          };

          this.selectResource = function(resource) {
            var resource = _.find(this.resources, function(res) { return res.id === resource.id }) 
            if (this.selected_resource && resource && this.selected_resource.id === resource.id) return;
            this.selected_resource = resource;
            $rootScope.$broadcast("resource:selected", this.selected_resource);
          };

          this.toggleServiceSelect = function() {
            this.options.show_service_select = !this.options.show_service_select;

            this.options.show_service_select ?
              angular.element($window).on("click", $scope.handleWindowClick) :
              angular.element($window).off("click", $scope.handleWindowClick);
          };
        }],

        link: function(scope, element, attrs, ctrl) {
          ctrl.loadResourceTypes();

          scope.$watch(function() { return ctrl.options.sort_by }, function() { ctrl.sortResources() });
          scope.$watch(function() { return ctrl.options.sort_dir }, function() { ctrl.sortResources() });

          scope.$on("resource:select", function(evt, resource) {
            ctrl.selectResource(resource);

            var el = document.getElementById(resource.id);
            if(el)
              el.scrollIntoView({ behavior: "smooth" });
          });

          scope.handleWindowClick = function(event) {
            var target = $(event.target);

            if (!target.parents('.list-control-types').length) {
              $appScope.safeApply(function() {
                ctrl.toggleServiceSelect();
              }, scope);
            }
          };
        }
      }
    }]);

angular.module('designer.model.resources.aws.apigateway.api_key', ['designer.model.resource'])
  .factory('AWS_APIKey', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'API KEY';

        resource.info = function() {
          var info = {};

          info.stages = this.getStages();
          info.usage_plans = this.getUsagePlans();

          return info;
        };

        // Do we want to keep it? currently the API is not returning in get_api_keys only on get_api_key
        resource.getStages = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Stage");
        };

        resource.getUsagePlans = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::UsagePlan");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.authorizer', ['designer.model.resource'])
  .factory('AWS_Authorizer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'AUTHORIZER';

        resource.info = function() {
          var info = {};

          info.rest_api = this.getRestAPI();

          return info;
        };

        resource.getRestAPI = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.deployment', ['designer.model.resource'])
  .factory('AWS_Deployment', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DEPLOYMENT';

        resource.info = function() {
          var info = {};

          info.rest_api = this.getRestAPI();
          info.stages = this.getStages();

          return info;
        };

        resource.getRestAPI = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI")[0];
        };


        resource.getStages = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Stage");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.domain', ['designer.model.resource'])
  .factory('AWS_Domain', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DOMAIN';

        resource.info = function() {
          var info = {};

          info.rest_apis = this.getRestAPIs();

          return info;
        };

        resource.getRestAPIs = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.method', ['designer.model.resource'])
  .factory('AWS_Method', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'API GATEWAY  METHOD';

        resource.info = function() {
          var info = {};

          info.authorizer = this.getAuthorizer();
          info.rest_api = this.getRestAPI();
          info.api_resource = this.getResource();
          info.lambda = this.getLambda();

          return info;
        };

        resource.getAuthorizer = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Authorizer")[0];
        };

        resource.getRestAPI = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI")[0];
        };

        resource.getResource = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Resource")[0];
        };

        resource.getLambda = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.model', ['designer.model.resource'])
  .factory('AWS_Model', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'MODEL';

        resource.info = function() {
          var info = {};
          
          info.schema = JSON.stringify(JSON.parse(this.schema), null, 2);
          info.rest_api = this.getRestAPI();

          return info;
        };

        resource.getRestAPI = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.resource', ['designer.model.resource'])
  .factory('AWS_APIGatewayResource', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'API GATEWAY RESOURCE';

        resource.info = function() {
          var info = {};

          info.rest_api = this.getRestAPI();
          info.methods = this.getMethods();
          info.resource_tree = this.getResourceTree();

          return info;
        };

        resource.getRestAPI = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI")[0];
        };

        resource.getResources = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Resource");
        };

        resource.getMethods = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Method");
        };

        resource.getResourceTree = function() {
          var parent = null;

          _.each(this.getResources(), function(resource) {
            if(this.provider_id === resource.parent_id){
              this.children = [resource];
            } else if(resource.provider_id === this.parent_id) {
              resource.children = [this];
              parent = resource;
            }
          }.bind(this));
          return parent;
        };

        return resource;
      }
    }
  }]);

angular.module("designer.model.resources.aws.apigateway.resource.tree", [])
  .directive("apiResourceTree", ["$rootScope", function($rootScope) {
    return {
      templateUrl: "/designer/data/resources/aws/apigateway/resource.tree.html",
      scope: {
        resource: "=",
        parent: "="
      },
      link: function (scope, element, attrs, ctrl) {
        scope.selectResource = function(resource) {
          $rootScope.$broadcast("resource:select", resource);
        };
      }
    }
  }]
);

angular.module('designer.model.resources.aws.apigateway.rest_api', ['designer.model.resource', 'designer.model.resources.aws.apigateway.resource.tree'])
  .factory('AWS_RestAPI', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REST API';

        resource.info = function() {
          var info = {};

          info.deployments_map = {};

          if (info.policy) {
            info.policy = JSON.stringify(JSON.parse(this.policy), null, 2);
          }

          info.deployments = this.getDeployments();
          info.authorizers = this.getAuthorizers();
          info.models = this.getModels();
          info.stages = this.getStages();
          info.resource_tree = this.getResourceTree(this.getResources());

          _.each(info.stages, function(stage) {
            info.deployments_map[stage.provider_id] = stage.getDeployments();
          });
     
          return info;
        };

        resource.getDeployments = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Deployment");
        };

        resource.getAuthorizers = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Authorizer");
        };

        resource.getModels = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Model");
        };

        resource.getStages = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Stage");
        };

        resource.getResources = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Resource");
        };

        resource.getResourceTree = function(resources) {
          var resource_tree = {};
          var parent = null;

          _.each(resources, function(resource) {
            resource_tree[resource.provider_id] = resource;
            resource.children = [];
          });

          _.each(_.sortBy(resource_tree, function(r) {return r.name}), function(resource) {
            if(resource.parent_id) {
              resource_tree[resource.parent_id].children.push(resource)
            }
            else {
              parent = resource;
            }
          });
          return parent;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.stage', ['designer.model.resource'])
  .factory('AWS_Stage', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'STAGE';

        resource.info = function() {
          var info = {};

          info.deployment_map = {};
          info.rest_api = this.getRestAPI();
          info.deployments = this.getDeployments();

          _.each(info.deployments, function(deployment) {
            info.deployment_map[deployment.name] = deployment;
          });

          return info;
        };

        resource.getDeployments = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Deployment");
        };

        resource.getRestAPI = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.usage_plan', ['designer.model.resource'])
  .factory('AWS_UsagePlan', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'USAGE PLAN';

        resource.info = function() {
          var info = {};
          
          info.api_keys = this.getAPIKeys();
          info.api_stages = this.getStages();
          info.rest_apis = this.getRestAPIs();

          return info;
        };

        resource.getStages = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Stage");
        };

        resource.getAPIKeys = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::APIKey");
        };

        resource.getRestAPIs = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI");
        };

        

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.apigateway.vpc_link', ['designer.model.resource'])
  .factory('AWS_VPCLink', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPC LINK';
        resource.status_list = {
          "available": "good",
          "pending": "warn",
          "deleting": "warn",
          "failed": "bad"
        };

        resource.info = function() {
          var info = {};

          info.load_balancers = this.getNetworkLoadBalancers().concat(this.getApplicationLoadBalancers());

          return info;
        };

        resource.getApplicationLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer");
        };

        resource.getNetworkLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.directory_service.directory', ['designer.model.resource'])
.factory('AWS_Directory', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'DIRECTORY SERVICE';
      resource.status = resource.stage;

      resource.status_list = {
        "requested": "warn",
        "creating": "warn",
        "created": "good",
        "active": "good",
        "inoperable": "bad",
        "impaired": "bad",
        "restoring": "warn",
        "restoreFailed": "bad",
        "deleting": "warn",
        "deleted": "stopped",
        "failed": "bad"
      };

      resource.info = function() {
        var info = {};
        
        var vpcs    = this.getVpcs();
        var subnets = this.getSubnets();
        if(vpcs)      info.vpcs = vpcs;
        if(subnets)   info.subnets = subnets;

        info.domain_controllers = this.getDomainControllers();
        info.trusts = this.getTrusts();

        return info;
      };

      resource.getStatus = function() {
        return {
          'available': resource.stage === 'Active',
          'unavailable': _.includes(['Inoperable','Impaired','RestoreFailed','Failed'], resource.stage),
          'problem': _.includes(['Requested','Creating','Created','Restoring','Deleting','Deleted'], resource.stage),
        };
      };

      resource.getExtendedInformation = function() {
        return {
          info1: this.provider_id,
          info2: this.directory_type,
          info3: this.size
        }
      };

      resource.getDomainControllers = function() {
        return environment.connectedTo(this, "Resources::AWS::DirectoryService::DomainController");
      };

      resource.getTrusts = function() {
        return environment.connectedTo(this, "Resources::AWS::DirectoryService::Trust");
      };

      resource.getVpcs = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::VPC");
      };

      resource.getSubnets = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
      };

      

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.directory_service.domain_controller', ['designer.model.resource'])
  .factory('AWS_DomainController', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DOMAIN CONTROLLER';
        resource.status_list = {
          "creating": "warn",
          "active": "good",
          "impaired": "bad",
          "restoring": "warn",
          "deleting": "warn",
          "deleted": "stopped",
          "failed":  "bad",
        };

        resource.info = function() {
          var info = {};
          var vpc    = this.getVpc();
          var subnet = this.getSubnet();
          info.directory = this.getDirectory();

          if(vpc)      info.vpc = vpc;
          if(subnet)   info.subnet = subnet;

          return info;
        };

        resource.getDirectory = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectoryService::Directory")[0];
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.directory_service.trust', ['designer.model.resource'])
  .factory('AWS_Trust', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TRUST';

        resource.info = function() {
          var info = {};

          info.directory = this.getDirectory();

          return info;
        };

        resource.getDirectory = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectoryService::Directory")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.cloudfront.distribution', ['designer.model.resource'])
  .factory('AWS_CloudFront_Distribution', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CLOUDFRONT DISTRIBUTION';
        resource.status_list = {
          "inprogress": "warn",
          "deployed": "good"
        };

        resource.protocol_policy_map = {
          "allow-all": "Allow all",
          "https-only": "HTTPS only",
          "redirect-to-https": "Redirect HTTP to HTTPS"
        }

        resource.custom_origin_protocol_policy_map = {
          "http-only": "HTTP Only",
          "match-viewer": "Match Viewer",
          "https-only": "HTTPS Only"
        }

        resource.info = function() {
          var info = {};
          var lambdas = {};
          var load_balancers = {};
          var buckets = {};

          // Setup some lookups for linking behaviours and origins
          _.each(this.getLambdaFunctions(), function(f) { lambdas[f.provider_id] = f });
          _.each(this.getLoadBalancers(), function(lb) { load_balancers[lb.dns_name] = lb });
          _.each(this.getS3Buckets(), function(b) { buckets[b.name] = b });

          info.behaviors = this.cache_behaviors.items.concat([this.default_cache_behavior]);
          info.web_acl = this.getWebACL();

          // Link behaviours to lambda functions if possible
          _.each(info.behaviors, function(b) {
            _.each(b.lambda_function_associations.items, function(i) {
              // ARN is for a version, we need the function arn
              var parts = i.lambda_function_arn.split(":");
              parts.pop()

              i.lambda_function = lambdas[parts.join(":")];
            });
          });

          // Link origins to buckets and LB's if possible
          _.each(this.origins.items, function(origin) {
            if (origin.domain_name.indexOf("elb.amazonaws.com") !== -1) {
              origin.origin_resource = load_balancers[origin.domain_name];
            }
            else if (origin.domain_name.indexOf("s3.amazonaws.com") !== -1 || origin.domain_name.indexOf(".s3-website") !== -1) {
              var bucket_name = origin.domain_name.split(".s3")[0];
              origin.origin_resource = buckets[bucket_name];
            }
          });

          return info;
        };

        resource.getLambdaFunctions = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function");
        };

        resource.getLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancing::LoadBalancer").concat(
            environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer")
          );
        };

        resource.getS3Buckets = function() {
          return environment.connectedTo(this, "Resources::AWS::S3::Bucket");
        };

        resource.getWebACL = function() {
          return environment.connectedTo(this, "Resources::AWS::WAF::WebACL")[0];
        };

        resource.getConnectables = function() {
          var connectables = []

          var acl = this.getWebACL()
          if(acl) {
            connectables.push(acl);
          }

          connectables = connectables.concat(this.getLambdaFunctions());
          connectables = connectables.concat(this.getLoadBalancers());
          connectables = connectables.concat(this.getS3Buckets());

          return connectables;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.cloudfront.streamingdistribution', ['designer.model.resource'])
  .factory('AWS_CloudFront_StreamingDistribution', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CLOUDFRONT STREAMING DISTRIBUTION';
        resource.status_list = {
          "deployed": "good"
        };

        resource.info = function() {
          var info = {};

          info.bucket = this.getS3Bucket();

          return info;
        };

        resource.getS3Bucket = function() {
          return environment.connectedTo(this, "Resources::AWS::S3::Bucket")[0];
        };

        resource.getConnectables = function() {
          return _.compact([this.getS3Bucket()]);
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.direct_connect.connection', ['designer.model.resource'])
  .factory('AWS_Connection', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DIRECT CONNECT CONNECTION';
        resource.status_list = {
          "available": "good",
          "down": "bad",
          "ordering": "warn",
          "requested": "warn",
          "pending": "warn",
          "deleting": "warn",
          "deleted": "stopped",
          "rejected": "bad",
          "unknown":  "warn",
        };

        resource.info = function() {
          var info = {};

          info.virtual_interface = this.getVirtualInterface();
          info.lag = this.getLAG();

          return info;
        };

        resource.getVirtualInterface = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::VirtualInterface")[0];
        };

        resource.getLAG = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::LAG")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.direct_connect.direct_connect_gateway', ['designer.model.resource'])
  .factory('AWS_DirectConnectGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DIRECT CONNECT GATEWAY';
        resource.status_list = {
          "available": "good",
          "associated": "good"
        };

        resource.info = function() {
          var info = {};

          info.virtual_interface = this.getVirtualInterface();
          info.gateway_associations = _.map(this.getDirectConnectGatewayAssociations(), function(association) {
            association.associated_resource = association.getVPNGateway() || association.getTransitGateway();

            return association;
          }.bind(this));

          return info;
        };

        resource.getVirtualInterface = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::VirtualInterface")[0];
        };

        resource.getDirectConnectGatewayAssociations = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::DirectConnectGatewayAssociation");
        };

        resource.getConnectables = function() {
          var connectables = [];

          _.each(this.getDirectConnectGatewayAssociations(), function(association) {
            var connectable = association.getVPNGateway() || association.getTransitGateway();
            if (connectable) {
              connectables.push(connectable);
            }
          });

          return connectables;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.direct_connect.direct_connect_gateway_association', ['designer.model.resource'])
  .factory('AWS_DirectConnectGatewayAssociation', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DIRECT CONNECT GATEWAY ASSOCIATION';
        resource.status_list = {
          "associating": "warn",
          "associated": "good",
          "disassociating": "warn",
          "disassociated": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.direct_connect_gateway = this.getDirectConnectGateway();
          info.vpn_gateway = this.getVPNGateway();

          return info;
        };

        resource.getDirectConnectGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::DirectConnectGateway")[0];
        };

        resource.getVPNGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPNGateway")[0];
        };

        resource.getTransitGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::TransitGateway")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.direct_connect.lag', ['designer.model.resource'])
  .factory('AWS_LAG', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LAG';
        resource.status_list = {
          "requested": "warn",
          "pending": "warn",
          "available": "good",
          "down": "bad",
          "deleting": "warn",
          "deleted": "stopped",
          "unknown":  "warn",
        };

        resource.info = function() {
          var info = {};

          info.virtual_interfaces = this.getVirtualInterfaces();
          info.connections = this.getConnections();

          return info;
        };

        resource.getConnections = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::Connection");
        };

        resource.getVirtualInterfaces = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::VirtualInterface");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.direct_connect.virtual_interface', ['designer.model.resource'])
  .factory('AWS_VirtualInterface', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL INTERFACE';
        resource.status_list = {
          "confirming": "warn",
          "verifying": "warn",
          "pending": "warn",
          "available": "good",
          "down": "bad",
          "deleting": "warn",
          "deleted": "stopped",
          "rejected": "bad",
          "unknown":  "warn",
        };

        resource.info = function() {
          var info = {};

          info.vpn_gateways = this.getVPNGateway();
          info.connection = this.getConnection();
          info.lag = this.getLAG();

          return info;
        };

        resource.getVPNGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPNGateway");
        };

        resource.getConnection = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::Connection")[0];
        };

        resource.getLAG = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::LAG")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.autoscaling.auto_scaling_group', ['designer.model.resource'])
  .factory('AWS_AutoScalingGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'AUTOSCALING GROUP';

        resource.has_badge = true;

        resource.info = function() {
          var info = {};

          info.instances = this.getInstances();
          info.scaling_policy = this.getScalingPolicy();
          info.launch_config = this.getLaunchConfiguration();
          info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: "Min: " + this.min_size,
            info3: "Max: " + this.max_size
          }
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
        };

        resource.getElbs = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancing::LoadBalancer")
        };

        resource.getALBs = function() {
          var albs = [];
          var instances = this.getInstances();

          _.each(instances, function(instance) {
            albs = albs.concat(instance.getALBs());
          });

          return albs;
        };

        resource.getNLBs = function() {
          var nlbs = [];
          var instances = this.getInstances();

          _.each(instances, function(instance) {
            nlbs = nlbs.concat(instance.getNLBs());
          });

          return nlbs;
        };

        resource.getScalingPolicy = function() {
          return environment.connectedTo(this, "Resources::AWS::AutoScaling::ScalingPolicy")[0];
        };

        resource.getLaunchConfiguration = function() {
          return environment.connectedTo(this, "Resources::AWS::AutoScaling::LaunchConfiguration")[0];
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
        };

        resource.badgeContent = function(subnet) {
          if(!subnet) return;

          return _.filter(this.getInstances(), function(i) {
            return i.availability_zone === subnet.get("resource").availability_zone;
          }).length;
        };

        resource.getConnectables = function() {
          var connectables = _.map(this.getInstances(), function(i) { return i.getELBs() });
          connectables = connectables.concat(this.getElbs());
          connectables = connectables.concat(this.getALBs());
          connectables = connectables.concat(this.getNLBs());

          return _.uniq(_.flatten(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.autoscaling.launch_configuration', ['designer.model.resource'])
  .factory('AWS_AutoScalingLaunchConfiguration', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LAUNCH CONFIGURATION';

        resource.info = function() {
          var info = {};

          info.autoscaling_group = this.getAutoscalingGroup();

          return info;
        };

        resource.getAutoscalingGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::AutoScaling::AutoScalingGroup")[0];
        };

        resource.highlightableConnections = function() {
          return [this.getAutoscalingGroup()];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.autoscaling.scaling_policy', ['designer.model.resource'])
  .factory('AWS_AutoScalingScalingPolicy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SCALING POLICY';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.dynamodb.table', ['designer.model.resource'])
.factory('AWS_DynamoDBTable', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'DYNAMODB TABLE';
      resource.status = resource.table_status.toLowerCase();
      resource.status_list = {
        "creating": "warn",
        "updating": "warn",
        "deleting": "warn",
        "active": "good",
        "inaccessible_encryption_credentials": "bad",
        "archiving": "warn",
        "archived": "stopped"
      };

      resource.index_status_list = {
        "CREATING": "warn",
        "UPDATING": "warn",
        "DELETING": "warn",
        "ACTIVE": "good"
      };

      resource.replica_status_list = {
        "CREATING": "warn",
        "CREATION_FAILED": "bad",
        "UPDATING": "warn",
        "DELETING": "warn",
        "ACTIVE": "good"
      };

      resource.attribute_types = {
        "S": "String",
        "N": "Number",
        "B": "Binary",
        null: "-"
      }

      resource.info = function() {
        var info = {};

        //  Primary keys
        var values = this.parseKeySchema(this.key_schema);
        info.primary_partition_key = values.partition_key;
        info.primary_sort_key = values.sort_key;

        // Indexes
        _.each(this.local_secondary_indexes.concat(this.global_secondary_indexes), function(index) {
          var values = this.parseKeySchema(index.key_schema);
          index.partition_key = values.partition_key;
          index.sort_key = values.sort_key;

        }.bind(this));

        return info;
      };

      resource.parseKeySchema = function(key_schema) {
        var values = { partition_key: null, sort_key: null };

        _.each(key_schema, function(schema) {
          var definition = _.find(this.attribute_definitions, function(def) { return def.attribute_name === schema.attribute_name });

          if(schema.key_type === "HASH") {
            values.partition_key = { name: schema.attribute_name, type: this.attribute_types[definition.attribute_type] };
          }
          else if(schema.key_type === 'RANGE') {
            values.sort_key = { name: schema.attribute_name, type: this.attribute_types[definition.attribute_type] };
          }
        }.bind(this));

        return values;
      };

      return resource;
    }
  }
}]);


angular.module('designer.model.resources.aws.ec2.address', ['designer.model.resource'])
.factory('AWS_Address', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'ELASTIC IP';

      resource.info = function() {
        var info = {};

        info.vpc = this.getVpc();
        info.instance = this.getInstance();
        info.network_interface = this.getNetworkInterface();

        return info;
      };

      resource.getVpc = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
      };

      resource.getInstance = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Instance")[0];
      };

      resource.getNetworkInterface = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::NetworkInterface")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.customer_gateway', ['designer.model.resource'])
  .factory('AWS_CustomerGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CUSTOMER GATEWAY';
        resource.status_list = {
          "available": "good",
          "pending": "warn",
          "deleting": "warn",
          "deleted": "stopped"
        };
        
        resource.info = function() {
          var info = {};

          info.vpn_connection = this.getVPNConnection();

          return info;
        };

        resource.getVPNConnection = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPNConnection")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.dhcp_options', ['designer.model.resource'])
  .factory('AWS_DHCPOptions', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DHCP OPTIONS';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.egress_only_internet_gateway', ['designer.model.resource'])
  .factory('AWS_EgressOnlyInternetGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EGRESS ONLY INTERNET GATEWAY';

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.instance', ['designer.model.resource'])
.factory('AWS_Instance', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'INSTANCE';
      resource.status_list = {
        "pending": "warn",
        "running": "good",
        "stopping": "warn",
        "stopped": "stopped",
        "rebooting": "warn",
        "shutting-down": "warn",
        "terminated": "stopped"
      };

      resource.summary_line =
        '<span class="resource-summary">' +
          resource.instance_type + " (" + resource.architecture + ")" + "&nbsp;&nbsp;&nbsp;" +
          resource.private_ip_address +
        '</span>';

      // If the resource is stopped then display it faded out
      resource.display_faded = (resource.status === 'stopped');

      resource.info = function() {
        var info = {};

        info.subnet = this.getSubnet();
        info.addresses = this.getAddresses();
        info.volumes = this.getVolumes();
        info.security_groups = this.getSecurityGroups();
        info.autoscaling_group = this.getAutoscalingGroup();
        info.network_interfaces = this.getNetworkInterfaces();
        info.ecs_clusters = this.getECSClusters();
        info.placement_group = this.getPlacementGroup();
        info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

        // Can have multiple IP's based on NICs, and they all link to different subnets. Weeee.
        var primary_ips = [];
        var secondary_ips = [];
        _.each(info.network_interfaces, function(nic) {
          var primary     = nic.getPrimaryPrivateIP();
          var secondaries = nic.getSecondaryPrivateIPs();
          var subnet      = nic.getSubnet();

          if(primary) {
            primary_ips.push({
              ip: primary.private_ip_address,
              subnet: subnet,
              nic: nic
            });
          }
          if(secondaries.length) {
            _.each(secondaries, function(ip) {
              secondary_ips.push({
                ip: ip.private_ip_address,
                subnet: subnet,
                nic: nic
              });
            });
          }
        });

        info.primary_private_ips = primary_ips;
        info.secondary_private_ips = secondary_ips;

        return info;
      };

      resource.summary = {
        "AMI": resource.ami,
        "AZ": resource.availability_zone,
        "Instance Type": resource.instance_type,
        "Private IP": resource.private_ip_address,
        "Arch": resource.architecture
      };

      resource.getExtendedInformation = function() {
        return {
          info1: this.provider_id,
          info2: this.private_ip_address,
          info3: this.public_ip_address
        }
      };

      resource.getIconInformation = function() {
        var txt = this.instance_type.split(".")[0].toUpperCase();

        return {
          txt: txt,
          fill: "#d86613",
          'font-size': 18,
          dx: txt.length === 3 ? 20 : 22,
          dy: 40
        }
      };

      resource.getSubnet = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Subnet")[0];
      };

      resource.getAddresses = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Address");
      };

      resource.getSecurityGroups = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
      };

      resource.getVolumes = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Volume");
      };

      resource.getNetworkInterfaces = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::NetworkInterface");
      };

      resource.getPlacementGroup = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::PlacementGroup")[0];
      };

      // TODO: we actually have a direct link to the VPC now ... will we always have it though? Gots to checks out CF
      resource.getVpc = function() {
        var subnet = this.getSubnet();

        return (subnet) ? subnet.getVpc() : null;
      };

      resource.getELBs = function() {
        return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancing::LoadBalancer");
      };

      resource.getALBs = function() {
        var albs = [];

        _.each(environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup"), function(target_group) {
          albs = albs.concat(target_group.getApplicationLoadBalancers());
        });

        return albs;
      };

      resource.getNLBs = function() {
        var nlbs = [];

        _.each(environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup"), function(target_group) {
          nlbs = nlbs.concat(target_group.getNetworkLoadBalancers());
        });

        return nlbs;
      };

      resource.getAutoscalingGroup = function() {
        return environment.connectedTo(this, "Resources::AWS::AutoScaling::AutoScalingGroup")[0];
      };

      resource.getElasticBeanstalkEnvironment = function() {
        return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
      };

      resource.getConnectables = function() {
        return this.getELBs().concat(this.getALBs()).concat(this.getNLBs());
      };

      // Can we have more than one ECS cluster?
      resource.getECSClusters = function() {
        var clusters = [];

        _.each(environment.connectedTo(this, "Resources::AWS::ECS::ContainerInstance"), function(container_instance) {
          clusters.push(container_instance.getCluster());
        });

        return _.uniq(clusters);
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.internet_gateway', ['designer.model.resource'])
.factory('AWS_InternetGateway', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'INTERNET GATEWAY';

      resource.getVpc = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.nat_gateway', ['designer.model.resource'])
  .factory('AWS_NATGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NAT GATEWAY';
        resource.status_list = {
          "available": "good",
          "pending": "warn",
          "deleting": "warn",
          "failed": "bad",
          "deleted": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.address = this.getAddress();
          info.network_interfaces = _.map(this.getNetworkInterfaces(), function(nic) {
            nic.instance = nic.getInstance();

            return nic;
          });

          return info;
        };

        resource.getExtendedInformation = function() {
          var address = this.getAddress();
          var info = {
            info1: this.provider_id,
            info2: null,
            info3: null
          };

          if (address) {
            info.info2 = address.private_ip_address;
            info.info3 = address.public_ip;
          }

          return info;
        };

        resource.getNetworkInterfaces = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::NetworkInterface");
        };

        resource.getAddress = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Address")[0];
        };

        // We can match on address ip for nat gateway
        resource.hasIPMatch = function(ip) {
          var address = this.getAddress();
          var matched = false;

          if(address) {
            if(address.public_ip.lastIndexOf(ip, 0) === 0)          matched = true;
            if(address.private_ip_address.lastIndexOf(ip, 0) === 0) matched = true;
          }

          return matched;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.network_acl', ['designer.model.resource', 'designer.model.helpers.protocols'])
.factory('AWS_NetworkACL', ["Resource", "ProtocolHelpers", function(Resource, ProtocolHelpers) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'NETWORK ACL';

      resource.info = function() {
        var info = {};

        if(this.entries.length > 0) {
          info.entries = { inbound: [], outbound: [] };

          _.each(this.entries, function(entry) {
            // Convert entry into fields we can show
            var parsed_entry = {
              rule_number: entry.rule_number === 32767 ? "*" : entry.rule_number,
              rule_action: entry.rule_action,
              cidr_block: entry.cidr_block,
              icmp_type_code: entry.icmp_type_code,
              port_range: this.formatPortRange(entry.port_range),
              protocol: ProtocolHelpers.protocolNumberToName(entry.protocol)
            };

            if(entry.egress) {
              info.entries.outbound.push(parsed_entry);
            }
            else {
              info.entries.inbound.push(parsed_entry);
            }
          }.bind(this));
        }

        info.subnets = this.getSubnets();

        return info;
      };

      resource.formatPortRange = function(range) {
        if (range) {
          if (range["from"] === range["to"]) {
            return range["from"];
          }
          else {
            return range["from"] + " to " + range["to"];
          }
        }

        return "all";
      };

      resource.getSubnets = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
      };

      resource.highlightableConnections = function() {
        return this.getSubnets();
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.network_interface', ['designer.model.resource'])
  .factory('AWS_NetworkInterface', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NETWORK INTERFACE';
        resource.status_list = {
          "in-use": "good",
          "available": "good",
          "attached": "good",
          "pending": "warn",
          "attaching": "warn",
          "detaching": "warn",
          "detached": "stopped",
        };

        resource.info = function() {
          var info = {};

          info.instance = this.getInstance();
          info.subnet = this.getSubnet();
          info.address = this.getAddress();
          info.route_tables = this.getRouteTables();
          info.security_groups = this.getSecurityGroups();
          info.nat_gateway = this.getNATGateway();
          info.primary_ip_address = this.getPrimaryPrivateIP();
          info.secondary_ip_addresses = this.getSecondaryPrivateIPs();

          return info;
        };

        resource.getPrimaryPrivateIP = function() {
          return _.find(this.private_ip_addresses, function(ip) { return ip["primary"] });
        };

        resource.getSecondaryPrivateIPs = function() {
          return _.filter(this.private_ip_addresses, function(ip) { return !ip["primary"] });
        };

        resource.getInstance = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance")[0];
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet")[0];
        };

        resource.getAddress = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Address")[0];
        };

        resource.getRouteTables = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::RouteTable");
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getNATGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::NATGateway")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.placement_group', ['designer.model.resource'])
.factory('AWS_PlacementGroup', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'PLACEMENT GROUP';
      resource.status_list = {
        "pending": "warn",
        "available": "good",
        "deleting": "warn",
        "deleted": "stopped"
      };

      resource.info = function() {
        var info = {};

        info.instances = this.getInstances()

        return info;
      };

      resource.getInstances = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.route_table', ['designer.model.resource'])
  .factory('AWS_RouteTable', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE TABLE';
        resource.route_state_list = {
          "active": "good",
          "blackhole": "bad"
        };

        resource.info = function() {
          var info = {};

          info.subnets = this.getSubnets();

          var connections = environment.connectedTo(this);
          info.connection_ids = {
            egress_only_internet_gateway_id: "egress_only_internet_gateway",
            gateway_id: "gateway",
            instance_id: "instance",
            nat_gateway_id: "nat_gateway",
            transit_gateway_id: "transit_gateway",
            network_interface_id: "network_interface",
            vpc_peering_connection_id: "vpc_peering_connection"
          };

          info.routes = _.map(this.routes, function(route) {
            _.each(info.connection_ids, function(property_value, property_id) {
              if (route[property_id]) {
                route[property_value] = _.find(connections, function(c) { return c.provider_id === route[property_id] } );
              }
            });

            return route;
          }.bind(this));

          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        resource.highlightableConnections = function() {
          var types = [
            "Resources::AWS::EC2::NetworkInterface",
            "Resources::AWS::EC2::NATGateway",
            "Resources::AWS::EC2::Instance",
            "Resources::AWS::EC2::Subnet",
            "Resources::AWS::EC2::InternetGateway",
            "Resources::AWS::EC2::EgressOnlyInternetGateway",
            "Resources::AWS::EC2::VPCEndpoint",
            "Resources::AWS::EC2::VPCPeeringConnection",
            "Resources::AWS::EC2::TransitGateway",
            "Resources::AWS::EC2::VPNGateway"
          ];
          var connectables = _.map(types, function(type) { return environment.connectedTo(this, type) }.bind(this));

          return _.flatten(connectables);
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.security_group', ['designer.model.resource'])
  .factory('AWS_SecurityGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SECURITY GROUP';

        resource.info = function() {
          var info = {};

          var sg_permissions = this.getSecurityGroupPermissions();
          var ingress_rules = sg_permissions.filter(function(rule) {return rule.permission_type === "ingress";});
          var egress_rules = sg_permissions.filter(function(rule) {return rule.permission_type === "egress";});

          info.ingress_rules = _.map(ingress_rules, function(r) {
            return {
              range: this.translateRange(r),
              protocol: this.translateProtocol(r.ip_protocol),
              ip_ranges: r.ip_ranges,
              prefix_list_ids: r.prefix_list_ids,
              sources: r.getSourceGroups()
            }
          }.bind(this));

          info.egress_rules = _.map(egress_rules, function(r) {
            return {
              range: this.translateRange(r),
              protocol: this.translateProtocol(r.ip_protocol),
              ip_ranges: r.ip_ranges,
              prefix_list_ids: r.prefix_list_ids,
              sources: r.getSourceGroups()
            }
          }.bind(this));

          info.children = _.reject(environment.connectedTo(this, null, true), function(r) {
            return _.includes(["Resources::AWS::EC2::SecurityGroup","Resources::AWS::EC2::SecurityGroupPermission"], r.type);
          });

          return info;
        };

        resource.translateRange = function(rule) {
          var from_port = rule.from_port;
          var to_port   = rule.to_port;
          var protocol  = rule.ip_protocol;

          if(!from_port && !to_port && protocol === -1)
            return "ALL";

          return (from_port === to_port) ? from_port : from_port + " : " + to_port;
        };

        // TODO: for now we just care about ALL - will we want to handle all number versions at some point?
        resource.translateProtocol = function(protocol) {
          return (protocol == -1) ? "ALL" : protocol;
        };
        
        resource.highlightableConnections = function() {
          var highlightable = [];

          var connected = environment.connectedTo(this, null, true);
          _.each(connected, function(c) {
            if(c.type === "Resources::AWS::EC2::NetworkInterface") {
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if(c.type === "Resources::AWS::EFS::MountTarget") {
              // TODO: can we specify the actual icon? Each service is in multiple subnets but a sg can apply to only one sub
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if(c.type === "Resources::AWS::Redshift::Cluster") {
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if(c.type === "Resources::AWS::ElastiCache::CacheCluster") {
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if (c.type === "Resources::AWS::AutoScaling::LaunchConfiguration") {
              highlightable = highlightable.concat(c.highlightableConnections())
            }
            else {
              highlightable.push(c);
            }
          });

          return highlightable;
        };

        // SO I can get the permissions directly attached to this group, then from that I can link it to other groups
        resource.getSecurityGroupPermissions = function() {
          var permissions = [];

          _.each(this.connections, function(connection) {
            if (connection.remote_resource_type === "Resources::AWS::EC2::SecurityGroupPermission" && connection.resource_id === this.id) {
              permissions.push(environment.getResource(connection.remote_resource_id));
            }
          }.bind(this));

          return _.compact(permissions);
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.security_group_permission', ['designer.model.resource'])
  .factory('AWS_SecurityGroupPermission', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        // Get the source group for this rule, not it's other attachments
        resource.getSecurityGroup = function() {
          var parent = null;

          _.each(this.connections, function(connection) {
            if (connection.remote_resource_type === "Resources::AWS::EC2::SecurityGroupPermission" &&
                connection.remote_resource_id === this.id) {
              parent = environment.getResource(connection.resource_id);
            }
          }.bind(this));

          return parent;
        };

        resource.getSourceGroups = function() {
          var groups = [];

          _.each(this.connections, function(connection) {
            if (connection.remote_resource_type === "Resources::AWS::EC2::SecurityGroup" &&
                connection.resource_id === this.id) {
              groups.push(environment.getResource(connection.remote_resource_id));
            }
          }.bind(this));

          return _.compact(groups);
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.subnet', ['designer.model.resource'])
  .factory('AWS_Subnet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SUBNET';
        resource.status_list = {
          "available": "good",
          "pending": "warn"
        };

        resource.rerender = ["cidr_block", "availability_zone"];

        resource.info = function() {
          var info = {};

          info.children = environment.connectedTo(this, null, true);
          info.vpc = this.getVpc();

          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        resource.getSubnetGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::RDS::DBSubnetGroup")
            .concat(environment.connectedTo(this, "Resources::AWS::ElastiCache::CacheSubnetGroup"))
            .concat(environment.connectedTo(this, "Resources::AWS::Redshift::ClusterSubnetGroup"));
        };

        resource.getNetworkACLs = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::NetworkACL");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.transitgateway', ['designer.model.resource'])
.factory('AWS_TransitGateway', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TRANSIT GATEWAY';
      resource.status_list = {
        "pending": "warn",
        "available": "good",
        "modifying": "warn",
        "deleting": "warn",
        "deleted": "stopped"
      };

      resource.info = function() {
        var info = {};

        info.attachments = this.getTransitGatewayAttachments();

        // We'll reference route tables using values from resource.options
        info.route_tables = {};
        _.each(this.getTransitGatewayRouteTables(), function(rt) {
          info.route_tables[rt.provider_id] = rt;
        });

        return info;
      };

      resource.getTransitGatewayRouteTables = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::TransitGatewayRouteTable");
      };

      resource.getTransitGatewayAttachments = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::TransitGatewayAttachment").
          concat(environment.connectedTo(this, "Resources::AWS::EC2::TransitGatewayVPCAttachment"));
      };

      resource.getConnectables = function() {
        var connected = [];

        _.each(environment.connectedTo(this, "Resources::AWS::EC2::TransitGatewayAttachment"), function(attachment) {
          var c = attachment.getVPNConnection();
          if(c) {
            var gateway = c.getCustomerGateway();
            if (gateway)
              connected.push(gateway);
          }
        });

        return connected;
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.transitgatewayattachment', ['designer.model.resource'])
.factory('AWS_TransitGatewayAttachment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TRANSIT GATEWAY ATTACHMENT';
      resource.status_list = {
        "pendingAcceptance": "warn",
        "rollingBack": "warn",
        "pending": "warn",
        "available": "good",
        "modifying": "warn",
        "deleting": "warn",
        "deleted": "stopped",
        "failed": "bad",
        "rejected": "bad",
        "rejecting": "warn",
        "failing": "bad",
        "initiatingRequest": "warn"
      };

      resource.tgw_association_status_list = {
        "associating": "warn",
        "associated": "good",
        "disassociating": "warn",
        "disassociated": "bad"
      };

      resource.info = function() {
        var info = {};

        info.attached_to = this.getVPNConnection() || this.getDirectConnectGateway();
        info.transit_gateway = this.getTransitGateway();
        info.associated_route_table = this.getAssociatedTransitGatewayRouteTable();

        return info;
      };

      resource.getAssociatedTransitGatewayRouteTable = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::TransitGatewayRouteTable")[0];
      };

      resource.getDirectConnectGateway = function() {
        return environment.connectedTo(this, "Resources::AWS::DirectConnect::DirectConnectGateway")[0];
      };

      resource.getVPNConnection = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::VPNConnection")[0];
      };

      resource.getTransitGateway = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::TransitGateway")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.transitgatewayroutetable', ['designer.model.resource'])
.factory('AWS_TransitGatewayRouteTable', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.status_list = {
        "pending": "warn",
        "available": "good",
        "deleting": "warn",
        "deleted": "stopped"
      };

      resource.type_name = 'TRANSIT GATEWAY ROUTE TABLE';
      
      resource.info = function() {
        var info = {};

        info.transit_gateway = this.getTransitGateway();

        return info;
      };

      resource.getTransitGateway = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::TransitGateway")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.transitgatewayvpcattachment', ['designer.model.resource'])
.factory('AWS_TransitGatewayVPCAttachment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TRANSIT GATEWAY VPC ATTACHMENT';
      resource.status_list = {
        "initiatingRequest": "warn",
        "pendingAcceptance": "warn",
        "rollingBack": "warn",
        "pending": "warn",
        "available": "good",
        "modifying": "warn",
        "deleting": "warn",
        "deleted": "stopped",
        "failed": "bad",
        "rejected": "bad",
        "rejecting": "bad",
        "failing": "bad"
      };

      resource.info = function() {
        var info = {};

        info.transit_gateway = this.getTransitGateway();
        info.vpc = this.getVPC();
        info.subnets = this.getSubnets();

        return info;
      };

      resource.getTransitGateway = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::TransitGateway")[0];
      };

      resource.getVPC = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
      };

      resource.getSubnets = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ec2.volume', ['designer.model.resource'])
  .factory('AWS_Volume', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VOLUME';
        resource.status_list = {
          "creating": "warn",
          "in-use": "good",
          "available": "good",
          "deleting": "warn",
          "deleted": "stopped",
          "error": "bad"
        };

        // TODO: bit of a dodgy hack for the minute to get this working for datapipe
        _.each(resource.tags, function(tag) {
          if(tag["key"].toLowerCase() === "name") {
            resource.name = tag["value"];
          }
        });

        resource.info = function() {
          var info = {};

          info.attachments = this.getAttachments();

          return info;
        };

        // Get attachments and add the resource so we can link to it
        resource.getAttachments = function() {
          // TODO: just get attached instances, none of this interface 'attached_to' crap
          var volumes = [];

          return volumes;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.vpc', ['designer.model.resource'])
  .factory('AWS_VPC', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPC';
        resource.status_list = {
          "pending": "warn",
          "available": "good"
        };

        resource.rerender = ["cidr_block"];

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();
          info.route_tables    = this.getRouteTables();
          info.network_acls    = this.getNetworkACLs();
          info.dhcp_options    = this.getDhcpOptions();
          info.s3_buckets      = this.getS3Buckets();

          return info;
        };

        resource.getVpc = function() {
          return this;
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getRouteTables = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::RouteTable");
        };

        resource.getDhcpOptions = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::DHCPOptions")[0];
        };

        resource.getNetworkACLs = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::NetworkACL");
        };

        resource.getS3Buckets = function() {
          return environment.connectedTo(this, "Resources::AWS::S3::Bucket");
        };

        resource.getInternetGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::InternetGateway");
        };

        resource.getEgressOnlyInternetGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::EgressOnlyInternetGateway");
        };

        resource.getVPNGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPNGateway");
        };

        resource.getCustomerGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::CustomerGateway");
        };

        resource.getWAFWebACLs = function() {
          return environment.connectedTo(this, "Resources::AWS::WAF::WebACL").concat(
            environment.connectedTo(this, "Resources::AWS::WAFV2::WebACL")
          );
        };

        resource.getTransitGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::TransitGateway");
        };

        resource.getHostedZones = function() {
          return environment.connectedTo(this, "Resources::AWS::Route53::HostedZone");
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::AWS::CloudFront::Distribution").concat(
            environment.connectedTo(this, "Resources::AWS::CloudFront::StreamingDistribution")
          );
        };

        resource.getVPCEndpoints = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPCEndpoint");
        };

        resource.getDirectConnectGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::DirectConnectGateway");
        };

        resource.getVPCPeeringConnections = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPCPeeringConnection");
        };

        resource.getAPIGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::RestAPI");
        };

        // Some workspaces aren't connected to subnets, so we return them here
        resource.getWorkSpaces = function() {
          var workspaces = environment.connectedTo(this, "Resources::AWS::WorkSpaces::WorkSpace");
          return _.reject(workspaces, function(r) { return environment.connectedTo(r, "Resources::AWS::EC2::Subnet").length > 0 })
        };

        resource.getElasticBeanstalkEnvironments = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.vpc_endpoint', ['designer.model.resource'])
  .factory('AWS_VPCEndpoint', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPC ENDPOINT';
        resource.status_list = {
          "pendingAcceptance": "warn",
          "pending": "warn",
          "available": "good",
          "deleting": "warn",
          "deleted": "stopped",
          "rejecting": "warn",
          "rejected": "bad",
          "failed": "bad",
          "failing": "warn"
        };

        resource.info = function() {
          var info = {};

          info.policy_document = JSON.stringify(JSON.parse(this.policy_document), null, 2);
          info.s3_buckets      = this.getS3Buckets();

          return info;
        };

        resource.getS3Buckets = function() {
          return environment.connectedTo(this, "Resources::AWS::S3::Bucket");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.vpc_peering_connection', ['designer.model.resource'])
  .factory('AWS_VpcPeeringConnection', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPC PEERING CONNECTION';
        resource.status_list = {
          "pending": "warn",
          "deleting": "warn",
          "deleted": "stopped",
          "failed": "bad",
          "rejected": "bad",
          "rejecting": "warn",
          "failing": "bad",
          "expired": "bad",
          "provisioning": "good",
          "active": "good",
        };
        _.each(resource.status_list, function(k, v){ if(_.includes(resource.status.toLowerCase(), v)) resource.status = v});

        resource.info = function() {
          var info = {};

          info.vpc_map = {};
          _.each(this.getVPCs(), function(vpc) {
            info.vpc_map[vpc.provider_id] = vpc;
          });

          return info;
        };

        resource.getVPCs = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.vpn_connection', ['designer.model.resource'])
  .factory('AWS_VpnConnection', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPN CONNECTION';
        resource.status_list = {
          "pending": "warn",
          "available": "good",
          "deleting": "warn",
          "deleted": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.vpn_gateway = this.getVPNGateway();
          info.customer_gateway = this.getCustomerGateway();

          return info;
        };

        resource.getVPNGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPNGateway")[0];
        };

        resource.getCustomerGateway = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::CustomerGateway")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ec2.vpn_gateway', ['designer.model.resource'])
  .factory('AWS_VpnGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPN GATEWAY';
        resource.status_list = {
          "pending": "warn",
          "available": "good",
          "deleting": "warn",
          "deleted": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.vpn_connections = this.getVPNConnections();
          info.gateway_associations = _.map(this.getDirectConnectGatewayAssociations(), function(association) {
            association.dc_gateway = association.getDirectConnectGateway();

            return association;
          }.bind(this));

          return info;
        };

        resource.getVPNConnections = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPNConnection");
        };

        resource.getDirectConnectGatewayAssociations = function() {
          return environment.connectedTo(this, "Resources::AWS::DirectConnect::DirectConnectGatewayAssociation");
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.efs.file_system', ['designer.model.resource'])
  .factory('AWS_EFSFileSystem', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EFS FILE SYSTEM';

        resource.info = function() {
          var info = {};

          info.mount_targets = _.map(this.getMountTargets(), function(target) {
            return {
              target: target,
              subnet: target.getSubnet(),
              nic: target.getNetworkInterface(),
              security_groups: target.getSecurityGroups()
            }
          });

          return info;
        };

        resource.getExtendedInformation = function() {
          var size = this.size_in_bytes || 0;

          return {
            info1: this.provider_id,
            info2: (Math.round((size / 1000 / 1000 / 1000) * 100) / 100) + "Gb",
            info3: null
          }
        };

        resource.getMountTargets = function() {
          return environment.connectedTo(this, "Resources::AWS::EFS::MountTarget");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.efs.mount_target', ['designer.model.resource'])
  .factory('AWS_EFSMountTarget', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EFS MOUNT TARGET';

        resource.info = function() {
          var info = {};

          info.subnet = this.getSubnet();
          info.network_interface = this.getNetworkInterface();

          return info;
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet")[0];
        };

        resource.getNetworkInterface = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::NetworkInterface")[0];
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getFileSystems = function() {
          return environment.connectedTo(this, "Resources::AWS::EFS::FileSystem");
        };

        resource.highlightableConnections = function() {
          return this.getFileSystems();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticache.cache_cluster', ['designer.model.resource'])
  .factory('AWS_ElastiCacheCacheCluster', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICACHE CLUSTER';
        resource.status = resource.cache_cluster_status;
        resource.status_list = {
          "available": "good",
          "creating": "warn",
          "deleted": "stopped",
          "deleting": "warn",
          "incompatible-network": "bad",
          "modifying": "warn",
          "rebooting cluster nodes": "warn",
          "restore-failed": "bad",
          "snapshotting": "warn"
        };

        resource.info = function() {
          var info = {};

          info.nodes = this.getNodes();

          return info;
        };

        resource.getNodes = function() {
          return environment.connectedTo(this, "Resources::AWS::ElastiCache::CacheNode");
        };

        resource.highlightableConnections = function() {
          return this.getNodes();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticache.cache_node', ['designer.model.resource'])
  .factory('AWS_ElastiCacheCacheNode', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICACHE CLUSTER NODE';
        resource.status = resource.cache_node_status;

        resource.status_list = {
          "available": "good",
          "creating": "warn",
          "rebooting": "warn",
          "deleting": "warn"
        };
        
        resource.info = function() {
          var info = {};

          info.cache_cluster = this.getCacheCluster();

          return info;
        };

        resource.getExtendedInformation = function() {
          var cluster = this.getCacheCluster();

          return {
            info1: this.provider_id,
            info2: cluster.name,
            info3: null
          }
        };

        resource.getIconInformation = function() {
          return {
            txt: this.getCacheCluster().engine[0].toUpperCase(),
            fill: "#3b48cc",
            'font-size': 18,
            dx: 29, 
            dy: 50
          }
        };

        resource.getCacheCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::ElastiCache::CacheCluster")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticache.parameter_group', ['designer.model.resource'])
  .factory('AWS_ElastiCacheParameterGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticache.subnet_group', ['designer.model.resource'])
  .factory('AWS_ElastiCacheSubnetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICACHE SUBNET GROUP';

        resource.info = function() {
          var info = {};

          info.cache_clusters = this.getCacheClusters();
          info.subnets = this.getSubnets();

          return info;
        };

        resource.getCacheClusters = function() {
          return environment.connectedTo(this, "Resources::AWS::ElastiCache::CacheCluster");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticbeanstalk.application', ['designer.model.resource'])
  .factory('AWS_ElasticBeanstalk_Application', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICBEANSTALK APPLICATION';

        resource.info = function() {
          var info = {};

          info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

          return info;
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticbeanstalk.applicationversion', ['designer.model.resource'])
  .factory('AWS_ElasticBeanstalk_ApplicationVersion', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICBEANSTALK APPLICATION VERSION';
        resource.status_list = {
          "processed": "good",
          "unprocessed": "stopped",
          "failed":  "bad",
          "processing": "warn",
          "building": "warn"
        };

        resource.info = function() {
          var info = {};

          info.beanstalk_environment = this.getElasticBeanstalkEnvironment();
          info.application = this.getElasticBeanstalkApplication();

          return info;
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
        };

        resource.getElasticBeanstalkApplication = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elasticbeanstalk.environment', ['designer.model.resource'])
  .factory('AWS_ElasticBeanstalk_Environment', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICBEANSTALK ENVIRONMENT';
        resource.status_list = {
          "launching": "warn",
          "updating": "warn",
          "ready": "good",
          "terminating": "warn",
          "terminated": "stopped"
        };

        resource.health_list = {
          "Green": "good",
          "Yellow": "warn",
          "Red": "bad",
          "Grey": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.load_balancers = this.getLoadBalancers();
          info.instances = this.getInstances();
          info.autoscaling_group = this.getAutoscalingGroup();
          info.application = this.getApplication();
          info.application_version = this.getApplicationVersion();
          info.environment_map = {};

          _.each(this.getEnvironments(), function(e) {
            info.environment_map[e.environment_name] = e;
          });

          return info;
        };

        resource.getLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancing::LoadBalancer").concat(
            environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer")
          ).concat(
            environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer")
          );
        }

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
        };

        resource.getAutoscalingGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::AutoScaling::AutoScalingGroup")[0];
        };

        resource.getApplication = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Application")[0];
        };

        resource.getApplicationVersion = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::ApplicationVersion")[0];
        };

        resource.getEnvironments = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ecs.cluster', ['designer.model.resource'])
  .factory('AWS_ECSCluster', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ECS CLUSTER';
        resource.status_list = {
          "active": "good",
          "provisioning": "good",
          "deprovisioning": "warn",
          "failed": "bad",
          "inactive": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.services = this.getServices();
          info.tasks = this.getTasks();
          info.container_instances = this.getContainerInstances();

          return info;
        };

        resource.getServices = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Service");
        };

        resource.getTasks = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Task");
        };

        resource.getContainerInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::ContainerInstance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ecs.container', ['designer.model.resource'])
  .factory('AWS_ECSContainer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ECS CONTAINER';
        resource.status = resource.last_status.toLowerCase();

        resource.status_list = {
          "provisioning": "warn",
          "registering": "warn",
          "pending": "warn",
          "activating": "warn",
          "active": "good",
          "running": "good",
          "deactivating": "warn",
          "deregistering": "warn",
          "stopping": "warn",
          "draining": "warn",
          "deprovisioning": "warn",
          "inactive": "stopped",
          "stopped": "stopped", 
          "registration_failed": "bad"
        };

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.task = this.getTask();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Cluster")[0];
        };

        resource.getTask = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Task")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ecs.container_instance', ['designer.model.resource'])
  .factory('AWS_ECSContainerInstance', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ECS CONTAINER INSTANCE';
        resource.status_list = {
          "registering": "warn",
          "registration_failed": "bad",
          "active": "good",
          "inactive": "stopped",
          "deregistering": "warn",
          "draining": "warn"
        };

        resource.agent_status_list = {
          "PENDING": "warn",
          "STAGING": "warn",
          "STAGED": "warn",
          "UPDATING": "warn",
          "UPDATED": "good",
          "FAILED": "bad"
        };

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.instance = this.getInstance();
          info.tasks = this.getTasks();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Cluster")[0];
        };

        resource.getInstance = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance")[0];
        };

        resource.getTasks = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Task");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ecs.deployment', ['designer.model.resource'])
.factory('AWS_ECSDeployment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'ECS DEPLOYMENT';
      resource.status_list = {
        "primary": "good", 
        "active": "good", 
        "inactive": "bad"
      };

      resource.info = function() {
        var info = {};

        info.service = this.getService();

        return info;
      };

      resource.getService = function() {
        return environment.connectedTo(this, "Resources::AWS::ECS::Service")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.ecs.service', ['designer.model.resource'])
  .factory('AWS_ECSService', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ECS SERVICE';
        resource.status_list = {
          "active": "good",
          "inactive": "stopped",
          "draining": "warn"
        };

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.load_balancer = this.getLoadBalancer();
          info.target_group = this.getTargetGroup();
          info.tasks = this.getTasks();
          info.load_balancer_info = this.getLoadBalancerConnection()["data"];
          info.task_definition = this.getTaskDefinition();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Cluster")[0];
        };

        resource.getTasks = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Task");
        };

        resource.getTaskDefinition = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::TaskDefinition")[0];
        };

        resource.getLoadBalancer = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancing::LoadBalancer")[0];
        };

        resource.getTargetGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup")[0];
        };

        resource.getLoadBalancerConnection = function() {
          return _.find(this.connections, function(c) {
            return c.remote_resource_type === "Resources::AWS::ElasticLoadBalancing::LoadBalancer" ||
              c.remote_resource_type === "Resources::AWS::ElasticLoadBalancingV2::TargetGroup"
          }) || {};
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ecs.task', ['designer.model.resource'])
  .factory('AWS_ECSTask', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ECS TASK';
        resource.status = resource.last_status.toLowerCase();
        resource.task_definition = resource.task_definition_arn.split("/")[1];
        resource.status_list = {
          "provisioning": "warn",
          "pending": "warn",
          "activating": "warn",
          "running": "good",
          "deactivating": "warn",
          "stopping": "warn",
          "deprovisioning": "warn",
          "stopped": "stopped"
        };
        resource.label_status_list = {
          "provisioning": "warning",
          "pending": "warning",
          "activating": "warning",
          "running": "success",
          "deactivating": "warning",
          "stopping": "warning",
          "deprovisioning": "warning",
          "stopped": "secondary"
        };

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.container_instance = this.getContainerInstance();
          info.containers = this.getContainers();
          info.service = this.getService();
          info.attachments = this.getAttachments();
          info.attachment_info = this.getAttachmentInfo();
          info.task_definition = this.getTaskDefinition();

          return info;
        };

        resource.getTaskDefinition = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::TaskDefinition")[0];
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Cluster")[0];
        };

        resource.getService = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Service")[0];
        };

        resource.getContainerInstance = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::ContainerInstance")[0];
        };

        resource.getContainers = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Container");
        };

        resource.getAttachments = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::NetworkInterface");
        };

        resource.getAttachmentInfo = function() {
          var attachments = {};

          _.each(this.attachments, function(info) {
            var nic_provider_details = _.find(info["details"], function(detail) { return detail["name"] === "networkInterfaceId" }) || {};
            attachments[nic_provider_details["value"]] = info;
          });

          return attachments;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.ecs.task_definition', ['designer.model.resource'])
.factory('AWS_ECSTaskDefinition', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'ECS TASK DEFINITION';
      resource.status_list = {
        "active": "good",
        "inactive": "stopped"
      };
      
      resource.info = function() {
        var info = {};

        info.services = this.getServices();
        info.tasks = this.getTasks();

        return info;
      };

      resource.getServices = function() {
        return environment.connectedTo(this, "Resources::AWS::ECS::Service");
      };

      resource.getTasks = function() {
        return environment.connectedTo(this, "Resources::AWS::ECS::Task");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.elastic_load_balancing.load_balancer', ['designer.model.resource'])
  .factory('AWS_LoadBalancer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELB';

        resource.info = function() {
          var info = {};
          var autoscaling_groups = [];
          info.instances = [];

          var instances = this.getConnectedInstances();

          _.each(instances, function(instance) {
            var autoscaling_group = instance.getAutoscalingGroup();

            if (autoscaling_group) {
              autoscaling_group.instances = autoscaling_group.instances ? _.uniq(autoscaling_group.instances.concat(instance)) : [instance];
              autoscaling_groups = autoscaling_groups.concat(autoscaling_group);
            } else {
              info.instances = info.instances.concat(instance);
            }
          });

          info.autoscaling_groups = _.uniq(autoscaling_groups);
          info.security_groups = this.getSecurityGroups();
          info.subnets = this.getSubnets();
          info.services = this.getECSServices();
          info.cloudfront_distributions = this.getCloudFrontDistributions();
          info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

          return info;
        };

        resource.getConnectedInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getECSServices = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Service");
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::AWS::CloudFront::Distribution");
        };

        // TODO: do we even use direct anymore? Also we don't really have a guaranteed direct link to VPC anymore
        resource.getVpc = function(direct) {
          var vpc = environment.connectedTo(this, "Interfaces::AWS::VPC::ELB")[0];

          // When getting the VPC for security groups we may want to go through subnet. When connecting to subnets we MUST have a VPC - so we go direct
          if(direct || vpc) {
            return vpc;
          }

          var subnet = this.getSubnet();
          return (subnet) ? subnet.getVpc() : null;
        };

        resource.getWebACLs = function() {
          return environment.connectedTo(this, "Resources::AWS::WAF::WebACL");
        };

        resource.getConnectables = function() {
          return this.getWebACLs();
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elastic_load_balancing_v2.application_load_balancer', ['designer.model.resource'])
  .factory('AWS_ApplicationLoadBalancer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'APPLICATION LOAD BALANCER';

        resource.rule_status = {};
        resource.built_info = null;

        resource.info = function() {
          if (this.built_info)
            return this.built_info;
          
          this.built_info = {};
          this.built_info.expanded = {};
          this.built_info.target_groups = [];
          this.built_info.instances = [];
          this.built_info.subnets = this.getSubnets();
          this.built_info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

          this.built_info.listeners = _.map(this.getListeners(), function(listener) {
            listener.rules = _.map(listener.getRules(), function(rule) {
              rule.target_group = rule.getTargetGroup();
              if (rule.priority == 'default') return rule;
            });

            return listener;
          });

          var autoscaling_groups = [];
          this.built_info.target_groups = _.map(this.getTargetGroups(), function(target_group) {
            _.each(target_group.getInstances(), function(instance) {
              var autoscaling_group = instance.getAutoscalingGroup();

              if (autoscaling_group) {
                if(!autoscaling_group["target_groups"])
                  autoscaling_group.target_groups = [];

                autoscaling_group.instances = autoscaling_group.instances ? _.uniq(autoscaling_group.instances.concat(instance)) : [instance];
                autoscaling_group.target_groups.push(target_group);
                autoscaling_groups = autoscaling_groups.concat(autoscaling_group);
              } else {
                if(!instance["target_groups"])
                  instance.target_groups = [];

                instance.target_groups.push(target_group);
                this.built_info.instances = this.built_info.instances.concat(instance);
              }
            }.bind(this));
            return target_group;
          }.bind(this));

          this.built_info.autoscaling_groups = _.uniq(autoscaling_groups);
          this.built_info.web_acls = this.getWebACLs();
          this.built_info.vpc_link = this.getVPCLinks();
          this.built_info.instances = _.uniq(this.built_info.instances);
          this.built_info.cloudfront_distributions = this.getCloudFrontDistributions();

          if (this.built_info.instances.length == 0) {
            var instances = this.getDirectInstances();
            instances.forEach(instance => {
              this.built_info.instances.push(instance)
            });
          }

          return this.built_info;
        };

        resource.getListeners = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::Listener");
        };

        resource.getTargetGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        resource.getWebACLs = function() {
          return environment.connectedTo(this, "Resources::AWS::WAF::WebACL");
        };

        resource.getConnectables = function() {
          return this.getWebACLs();
        };

        resource.getVPCLinks = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::VpcLink");
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::AWS::CloudFront::Distribution");
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticBeanstalk::Environment")[0];
        };

        resource.getDirectInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elastic_load_balancing_v2.listener', ['designer.model.resource'])
  .factory('AWS_ALBListener', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LISTENER';

        resource.info = function() {
          var info = {};
          info.rules = this.getRules();
          info.load_balancers = this.getApplicationLoadBalancers().concat(this.getNetworkLoadBalancers());

          return info;
        };

        resource.getRules = function() {
          var val = _.map(environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::Rule"), function(rule){
            rule.loadData();
            return rule;
          });
          return val;
        };

        resource.getTargetGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup");
        };

        resource.getApplicationLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer");
        };

        resource.getNetworkLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elastic_load_balancing_v2.network_load_balancer', [
  'designer.model.resource',
  'designer.model.resources.aws.elastic_load_balancing_v2.application_load_balancer'
])
  .factory('AWS_NetworkLoadBalancer', ["AWS_ApplicationLoadBalancer", function(AWS_ApplicationLoadBalancer) {
    return {
      load: function(resource, environment) {
        resource = AWS_ApplicationLoadBalancer.load(resource, environment);
        resource.type_name = "NETWORK LOAD BALANCER";
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elastic_load_balancing_v2.rule', ['designer.model.resource'])
  .factory('AWS_ALBRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};

          return info;
        };

        // TODO: format condition info too? Maaaybe?
        resource.loadData = function() {
          _.each(this.actions, function(action, i){
            var config = {};
            if (action.type === 'forward'){
              config = action.forward_config;
            } else if (action.type === 'redirect'){
              config = action.redirect_config;
              this.actions[i].description = config["protocol"] + "://" + config["host"] + ":" + config["port"] + config["path"] + "?" + config["query"]
            } else if (action.type === 'fixed-response') {
              config = action.fixed_response_config;
              this.actions[i].description = config["status_code"]
            } else if (action.type === 'authenticate-cognito') {
              config = action.authenticate_cognito_config;
              this.actions[i].description = config["on_unauthenticated_request"]
            } else if (action.type ==='authenticate-oidc') {
              config = action.authenticate_oidc_config;
              this.actions[i].description = config["on_unauthenticated_request"]
            }
            this.actions[i].config = config

          }.bind(this));
        };

        resource.getTargetGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup")[0];
        };


        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.elastic_load_balancing_v2.target_group', ['designer.model.resource'])
  .factory('AWS_ALBTargetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET GROUP';

        resource.info = function() {
          var info = {};
          info.instances = this.getInstances();
          info.services = this.getECSServices();
          info.load_balancers = this.getApplicationLoadBalancers().concat(this.getNetworkLoadBalancers());
          
          return info;
        };

        resource.getApplicationLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer");
        };

        resource.getNetworkLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer");
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
        };

        resource.getECSServices = function() {
          return environment.connectedTo(this, "Resources::AWS::ECS::Service");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.redshift.cluster', ['designer.model.resource'])
  .factory('AWS_RedshiftCluster', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REDSHIFT CLUSTER';
        resource.status_list = {
          "available": "good",
          "cancelling-resize": "warn",
          "creating": "warn",
          "deleting": "warn",
          "final-snapshot": "warn",
          "hardware-failure": "bad",
          "incompatible-hsm": "bad",
          "incompatible-network": "bad",
          "incompatible-parameters": "bad",
          "incompatible-restore": "bad",
          "modifying": "warn",
          "paused": "stopped",
          "rebooting": "warn",
          "renaming": "warn",
          "resizing": "warn",
          "rotating-keys": "warn",
          "storage-full": "bad",
          "updating-hsm": "warn",
        };

        resource.info = function() {
          var info = {};

          info.subnet_group = this.getSubnetGroup();
          info.security_groups = this.getSecurityGroups();
          info.parameter_groups = this.getClusterParameterGroups();
          info.nodes = this.getNodes();

          return info;
        };

        resource.getClusterParameterGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::Redshift::ClusterParameterGroup");
        };

        resource.getSubnetGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::Redshift::ClusterSubnetGroup");
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getNodes = function() {
          return environment.connectedTo(this, "Resources::AWS::Redshift::ClusterNode");
        };

        resource.highlightableConnections = function() {
          return this.getNodes();
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.redshift.cluster_node', ['designer.model.resource'])
  .factory('AWS_RedshiftClusterNode', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REDSHIFT CLUSTER NODE';

        resource.info = function() {
          var info = {};

          info.cluster = this.getRedshiftCluster();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.private_ip_address,
            info3: this.public_ip_address
          }
        };

        resource.getRedshiftCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::Redshift::Cluster")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.redshift.parameter_group', ['designer.model.resource'])
  .factory('AWS_RedshiftParameterGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CLUSTER PARAMETER GROUP';

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.redshift.cluster_subnet_group', ['designer.model.resource'])
  .factory('AWS_RedshiftClusterSubnetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CLUSTER SUBNET GROUP';

        resource.info = function() {
          var info = {};

          info.subnets = this.getSubnets();
          info.clusters = this.getRedshiftClusters();


          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        resource.getRedshiftClusters = function() {
          return environment.connectedTo(this, "Resources::AWS::Redshift::Cluster");
        };

        resource.highlightableConnections = function() {
          return this.getSubnets();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.rds.db_cluster', ['designer.model.resource'])
  .factory('AWS_DBCluster', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.type_name = 'RDS CLUSTER';
        resource.status_list = {
          "available": "good",
          "backing-up": "warn",
          "backtracking": "warn",
          "cloning-failed": "warn",
          "creating": "warn",
          "deleting": "warn",
          "failing-over": "warn",
          "inaccessible-encryption-credentials": "warn",
          "maintenance": "warn",
          "migrating": "warn",
          "migration-failed": "bad",
          "modifying": "warn",
          "promoting": "warn",
          "renaming": "warn",
          "resetting-master-credentials": "warn",
          "starting": "warn",
          "stopped": "stopped",
          "stopping": "warn",
          "update-iam-db-auth": "bad",
          "upgrading": "warn"
        };

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();
          info.hosted_zone = this.getHostedZone();
          info.db_cluster_members = this.getRDSInstances();
          info.subnet_group = this.getSubnetGroup();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.engine,
            info2: this.allocated_storage + " GB",
            info3: this.capacity + " CU"
          }
        };

        resource.getHostedZone = function() {
          return environment.connectedTo(this, "Resources::AWS::Route53::HostedZone")[0];
        };

        resource.getRDSInstances = function() {
          return environment.connectedTo(this, "Resources::AWS::RDS::DBInstance");
        };

        resource.getSubnetGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::RDS::DBSubnetGroup")[0];
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.rds.db_instance', ['designer.model.resource'])
  .factory('AWS_DBInstance', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        var ENGINE_FORMAT = {
          "mariadb": { txt: "MariaDB", 'font-size': 15, dy: 21 },
          "mysql": { txt: "MySQL", 'font-size': 15, dy: 21 },
          "oracle": { txt: "Oracle", 'font-size': 19, dy: 21 },
          "postgres": { txt: "PostgreSQL", 'font-size': 12, dy: 21, textLength: "60", lengthAdjust: "spacingAndGlyphs" },
          "docdb": { txt: "DocumentDB", 'font-size': 12, dy: 21, textLength: "60", lengthAdjust: "spacingAndGlyphs" },
          "aurora": { txt: "Amazon Aurora", 'font-size': 12, dy: 15, dx2: -46  },
          "rds": { txt: "Amazon RDS", 'font-size': 12, dy: 15, dx2: -46 },
          "proxy": { txt: "RDS Proxy", 'font-size': 12, dy: 15, dx2: -24 },
          "sqlserver": { txt: "SQL Server", 'font-size': 12, dy: 15, dx2: -24 },
        };
        
        resource = Resource.load(resource, environment);
        resource.type_name = 'RDS INSTANCE';
        resource.status_list = {
          "available": "good",
          "backing-up": "warn",
          "backtracking": "warn",
          "configuring-enhanced-monitoring": "warn",
          "configuring-iam-database-auth": "warn",
          "configuring-log-exports": "warn",
          "converting-to-vpc": "warn",
          "creating": "warn",
          "deleting": "warn",
          "failed": "bad",
          "inaccessible-encryption-credentials": "warn",
          "incompatible-network": "bad",
          "incompatible-option-group": "bad",
          "incompatible-parameters": "bad",
          "incompatible-restore": "bad",
          "maintenance": "warn",
          "modifying": "warn",
          "moving-to-vpc": "warn",
          "rebooting": "warn",
          "renaming": "warn",
          "resetting-master-credentials": "warn",
          "restore-error": "bad",
          "starting": "warn",
          "stopped": "stopped",
          "stopping": "warn",
          "storage-full": "bad",
          "storage-optimization": "warn",
          "upgrading": "warn"
        };

        resource.summary_line =
          '<span class="resource-summary">' +
          resource.engine + " (" + resource.engine_version + ")" + "&nbsp;&nbsp;&nbsp;" +
          resource.instance_class +
          '</span>';

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();
          info.cluster = this.getDBCluster();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.engine,
            info3: this.allocated_storage + " GB"
          }
        };

        resource.getIconInformation = function() {
          var base_engine_type = this.engine.split("-")[0] || this.engine;
          var attrs = {
            txt: "",
            fill: "#3b48cc",
            dx: 6, 
            dy2: 14
          }
          return _.assign(attrs, ENGINE_FORMAT[base_engine_type]);
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getDBCluster = function() {
          return environment.connectedTo(this, "Resources::AWS::RDS::DBCluster")[0];
        };

        // TODO: do we have this connection? Do we need it anywhere?
        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.rds.db_security_group', ['designer.model.resource'])
  .factory('AWS_DBSecurityGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DB SECURITY GROUP';
        resource.status_list = {
          "authorizing": "warn",
          "authorized": "good",
          "revoking": "warn",
          "revoked": "stopped"
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.rds.db_subnet_group', ['designer.model.resource'])
  .factory('AWS_DBSubnetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'RDS SUBNET GROUP';

        resource.info = function() {
          var info = {};

          info.subnets = this.getSubnets();

          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::VPC")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        resource.highlightableConnections = function() {
          return this.getSubnets();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.lambda.event_source_mapping', ['designer.model.resource'])
  .factory('AWS_EventSourceMapping', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EVENT SOURCE MAPPING';
        resource.status_list = {
          "enabled": "good",
          "creating": "warn",
          "enabling": "warn",
          "disabling": "warn",
          "disabled": "stopped",
          "updating": "warn",
          "deleting": "warn",
          "deleted": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.function = this.getFunction();

          return info;
        };

        resource.getFunction = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.lambda.function', ['designer.model.resource'])
  .factory('AWS_LambdaFunction', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LAMBDA FUNCTION';

        resource.info = function() {
          var info = {};

          info.function_versions = this.getFunctionVersion();
          info.event_source_mappings = this.getEventSourceMappings();
          info.aliases = this.getAliases();
          info.layer_versions = this.getLayerVersions();
          info.api_gateways = this.getAPIGateways();
          info.security_group = this.getSecurityGroup();
          info.cloudfront_distributions = this.getCloudFrontDistributions();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.runtime,
            info3: this.version
          }
        };

        resource.getFunctionVersion = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::FunctionVersion");
        };

        resource.getEventSourceMappings = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::EventSourceMapping");
        };

        resource.getAliases = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::LambdaAlias");
        };

        resource.getLayerVersions = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::LayerVersion");
        };

        resource.getAPIGateways = function() {
          return environment.connectedTo(this, "Resources::AWS::APIGateway::Resource");
        };

        resource.getSecurityGroup = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup")[0];
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::AWS::CloudFront::Distribution");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.lambda.function_version', ['designer.model.resource'])
  .factory('AWS_FunctionVersion', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'FUNCTION VERSION';

        resource.info = function() {
          var info = {};

          info.function = this.getFunction();

          return info;
        };

        resource.getFunction = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.lambda.lambda_alias', ['designer.model.resource'])
  .factory('AWS_LambdaAlias', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LAMBDA ALIAS';

        resource.info = function() {
          var info = {};

          info.function = this.getFunction();
          info.function_version = this.getFunctionVersion();

          return info;
        };

        resource.getFunction = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function")[0];
        };

        resource.getFunctionVersion = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::FunctionVersion")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.lambda.layer', ['designer.model.resource'])
  .factory('AWS_Layer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'FUNCTION LAYER';

        resource.info = function() {
          var info = {};

          info.function = this.getFunction();
          info.layer_versions = this.getLayerVersions();

          return info;
        };

        resource.getFunction = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function")[0];
        };

        resource.getLayerVersions = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::LayerVersion");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.lambda.layer_version', ['designer.model.resource'])
  .factory('AWS_LayerVersion', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LAYER VERSION';

        resource.info = function() {
          var info = {};

          info.function = this.getFunction();
          info.layer = this.getLayer();

          return info;
        };

        resource.getFunction = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Function")[0];
        };

        resource.getLayer = function() {
          return environment.connectedTo(this, "Resources::AWS::Lambda::Layer")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.route53.hosted_zone', ['designer.model.resource'])
  .factory('AWS_Route53HostedZone', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE53 HOSTED ZONE';

        resource.info = function() {
          var info = {};

          info.resource_record_sets = this.getResourceRecordSets();

          return info;
        };

        resource.getResourceRecordSets = function() {
          return environment.connectedTo(this, "Resources::AWS::Route53::ResourceRecordSet");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.route53.resource_record_set', ['designer.model.resource'])
  .factory('AWS_Route53ResourceRecordSet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.s3.bucket', ['designer.model.resource'])
  .factory('AWS_S3Bucket', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'S3 BUCKET';

        resource.info = function() {
          var info = {};

          info.policy_document = JSON.stringify(JSON.parse(this.policy), null, 2);
          info.cloudfront_distributions = this.getCloudFrontDistributions();
          
          return info;
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::AWS::CloudFront::Distribution").concat(
            environment.connectedTo(this, "Resources::AWS::CloudFront::StreamingDistribution")
          );
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.workspaces.directory', ['designer.model.resource'])
  .factory('AWS_WorkSpacesDirectory', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WORKSPACES DIRECTORY';
        resource.status_list = {
          "deregistered": "stopped",
          "registered": "good"
        };

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();
          info.subnets = this.getSubnets();
          info.ip_groups = this.getIPGroups();
          info.workspaces = this.getWorkSpaces();

          return info;
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::Subnet");
        };

        resource.getIPGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::WorkSpaces::IPGroup");
        };

        resource.getWorkSpaces = function() {
          return environment.connectedTo(this, "Resources::AWS::WorkSpaces::WorkSpace");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.workspaces.ip_group', ['designer.model.resource'])
  .factory('AWS_WorkSpacesIPGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WORKSPACES IP GROUP';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.workspaces.workspace', ['designer.model.resource'])
  .factory('AWS_WorkSpacesWorkSpace', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WORKSPACE';
        resource.status_list = {
          "pending": "warn",
          "available": "good",
          "impaired": "bad",
          "unhealthy": "bad",
          "rebooting": "warn",
          "starting": "warn",
          "rebuilding": "warn",
          "restoring": "warn",
          "maintenance": "stopped",
          "admin_maintenance": "stopped",
          "terminating": "warn",
          "terminated": "stopped",
          "suspended": "stopped",
          "updating": "warn",
          "stopping": "warn",
          "stopped": "stopped",
          "error": "bad"
        };

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();
          info.ip_groups = this.getIPGroups();
          info.directory = this.getWorkSpaceDirectory();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.user_name,
            info3: this.ip_address
          }
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::EC2::SecurityGroup");
        };

        resource.getIPGroups = function() {
          return environment.connectedTo(this, "Resources::AWS::WorkSpaces::IPGroup");
        };

        resource.getWorkSpaceDirectory = function() {
          return environment.connectedTo(this, "Resources::AWS::WorkSpaces::Directory")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.cluster', ['designer.model.resource'])
  .factory('Kubernetes_Cluster', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CLUSTER';
        resource.launch_type = resource.namespace;
        
        resource.info = function() {
          var info = {};

          // TODO: need to sort all this out - don't need the length values, guess I need to review allthe attributes
          var deployments = this.getDeployments()
          info.deployments_length = deployments.length;
          info.deployments = this.groupNamespace(deployments)

          var daemon_sets = this.getDaemonSets()
          info.daemon_sets_length = daemon_sets.length;
          info.daemon_sets = this.groupNamespace(daemon_sets);

          var replica_sets = this.getReplicaSets()
          info.replica_sets_length = replica_sets.length;
          info.replica_sets = this.groupNamespace(replica_sets);

          var stateful_sets = this.getStatefulSets()
          info.stateful_sets_length = stateful_sets.length;
          info.stateful_sets = this.groupNamespace(stateful_sets);

          var pods = this.getPods()
          info.pods_length = pods.length;
          info.pods = this.groupNamespace(pods);

          info.persistent_volumes = this.getPersistentVolumes();
          info.nodes = this.getNodes();

          return info;
        };

        resource.groupNamespace = function(items) {
          var group = {};
          _.each(items, function(item) {
            if (!group[item.namespace]) { group[item.namespace] = [] }
            group[item.namespace].push(item);
          });
          return group;
        };

        resource.getDaemonSets = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::DaemonSet");
        };

        resource.getDeployments = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Deployment");
        };

        resource.getReplicaSets = function() {
          var sets = environment.connectedTo(this, "Resources::Kubernetes::Cluster::ReplicaSet");
          return _.filter(sets, (s) => !s.getDeployment());
        };

        resource.getStatefulSets = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::StatefulSet");
        };

        resource.getPods = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
        };

        resource.getNamespaces = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Namespace");
        };

        resource.getPersistentVolumes = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::PersistentVolume");
        };

        resource.getNodes = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Node");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.daemon_set', ['designer.model.resource'])
  .factory('Kubernetes_DaemonSet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DAEMON SET';

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.pods = this.getPods();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
        };

        resource.getPods = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
        };

        resource.highlightableConnections = function() {
          return this.getPods();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.deployment', ['designer.model.resource'])
.factory('Kubernetes_Deployment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'DEPLOYMENT';

      resource.info = function() {
        var info = {};

        info.replica_sets = this.getReplicaSets();
        info.replica_set_pods = {};

        _.each(info.replica_sets, function(replica_set) {
          info.replica_set_pods[replica_set.name] = replica_set.getPods();
        });

        info.primary_replica_set = _.sortBy(info.replica_sets, ["start_time"])[info.replica_sets.length-1];

        return info;
      };

      resource.getReplicaSets = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::ReplicaSet");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.kubernetes.cluster.namespace', ['designer.model.resource'])
.factory('Kubernetes_Namespace', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'NAMESPACE';

      resource.info = function() {
        var info = {};

        info.cluster = this.getCluster();

        return info;
      };

      resource.getCluster = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
      };

      resource.getDaemonSets = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::DaemonSet");
      };

      resource.getDeployments = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Deployment");
      };

      resource.getReplicaSets = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::ReplicaSet");
      };

      resource.getStatefulSets = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::StatefulSet");
      };

      resource.getServices = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Service");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.kubernetes.cluster.node', ['designer.model.resource'])
  .factory('Kubernetes_Node', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NODE';
        
        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.pods = this.getPods();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
        };

        resource.getPods = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
        };

        resource.highlightableConnections = function() {
          var highlightable = [];

          highlightable = highlightable.concat(this.getPods());

          return highlightable;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.persistent_volume', ['designer.model.resource'])
  .factory('Kubernetes_PersistentVolume', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'PERSISTENT VOLUME';

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.claim = this.getPersistentVolumeClaim();
          info.claim.pod = info.claim.getPod();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
        };

        resource.getPersistentVolumeClaim = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::PersistentVolumeClaim")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.persistent_volume_claim', ['designer.model.resource'])
.factory('Kubernetes_PersistentVolumeClaim', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'PERSISTENT VOLUME CLAIM';

      resource.info = function() {
        var info = {};

        info.cluster = this.getCluster();
        info.namespace = this.getNamespace();
        info.volume = this.getPersistentVolume();
        info.pod = this.getPod();

        return info;
      };

      resource.getCluster = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
      };

      resource.getNamespace = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Namespace")[0];
      };

      resource.getPersistentVolume = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::PersistentVolume")[0];
      };

      resource.getPod = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.kubernetes.cluster.pod', ['designer.model.resource'])
  .factory('Kubernetes_Pod', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'POD';

        resource.status_list = {
          "pending": "warn",
          "running": "good",
          "succeeded": "good",
          "failed": "bad",
          "unknown": "stopped"
        };
        
        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.node = this.getNode();
          info.deployment = this.getDeployment();
          info.replica_set = this.getReplicaSet();
          info.stateful_set = this.getStatefulSet();
          info.service_account = this.getServiceAccount();
          info.namespace = this.getNamespace();
          info.claims = _.map(this.getPersistentVolumeClaims(), function(claim) {
            claim.volume = claim.getPersistentVolume();
            return claim;
          });

          info.containers = _.map(resource.containers, function(c) {
            var status = _.find(resource.container_statuses, (cs) => cs.name === c.name) || {};
            status.state_name = Object.keys(status.state || {})[0];
            c.container_status = status;
            return c;
          })

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
        };

        resource.getDeployment = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Deployment")[0];
        };

        resource.getServiceAccount = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::ServiceAccount")[0];
        };

        resource.getNamespace = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Namespace")[0];
        };

        resource.getNode = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Node")[0];
        };

        resource.getReplicaSet = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::ReplicaSet")[0];
        };

        resource.getStatefulSet = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::StatefulSet")[0];
        };

        resource.getPersistentVolumeClaims = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::PersistentVolumeClaim");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.replica_set', ['designer.model.resource'])
  .factory('Kubernetes_ReplicaSet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REPLICA SET';

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.deployment = this.getDeployment();
          info.pods = this.getPods();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
        };

        resource.getDeployment = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Deployment")[0];
        };

        resource.getPods = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
        };

        resource.highlightableConnections = function() {
          return this.getPods();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.kubernetes.cluster.service', ['designer.model.resource'])
.factory('Kubernetes_Service', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE';

      resource.info = function() {
        var info = {};

        info.cluster = this.getCluster();
        info.namespace = this.getNamespace();
        info.pods = this.getPods();
        info.load_balancer_status_ips = _.map((this.load_balancer_status || []), (s) => s.ip);

        // Map pod details to endpoints
        var endpoint = this.getEndpoint();
        if(endpoint) {
          _.each(endpoint["subsets"] || [], function(subset) {
            _.each(subset["addresses"] || [], function(address) {
              var pod = _.find(info.pods, (p) => p.name === address.targetRef.name);
              if(pod)
                pod.endpoint_ip = address.ip;
            });
          });
        }

        return info;
      };

      resource.getCluster = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
      };

      resource.getNamespace = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Namespace")[0];
      };

      resource.getPods = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
      };

      resource.getEndpoint = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Endpoint")[0];
      };

      resource.highlightableConnections = function() {
        return this.getPods();
      };

      resource.getConnectables = function() {
        return this.getPods();
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.kubernetes.cluster.service_account', ['designer.model.resource'])
.factory('Kubernetes_ServiceAccount', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE ACCOUNT';

      resource.info = function() {
        var info = {};

        info.cluster = this.getCluster();
        info.namespace = this.getNamespace();
        info.pods = this.getPods();

        return info;
      };

      resource.getCluster = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
      };

      resource.getNamespace = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Namespace")[0];
      };

      resource.getPods = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
      };

      resource.highlightableConnections = function() {
        return this.getPods();
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.kubernetes.cluster.stateful_set', ['designer.model.resource'])
  .factory('Kubernetes_StatefulSet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'STATEFUL SET';

        resource.info = function() {
          var info = {};

          info.cluster = this.getCluster();
          info.pods = this.getPods();

          return info;
        };

        resource.getCluster = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Cluster")[0];
        };

        resource.getPods = function() {
          return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
        };

        resource.highlightableConnections = function() {
          return this.getPods();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.wafv2.web_acl', ['designer.model.resource'])
  .factory('AWS_WAFV2WebACL', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WAF WEB ACL';

        resource.info = function() {
          var info = {};

          info.load_balancers = this.getAllLoadBalancers();
          // TODO: can connect to cloudfront and api gateway too

          return info;
        };

        resource.getAllLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer")
            .concat(environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer"));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.sqs.queue', ['designer.model.resource'])
.factory('AWS_SQSQueue', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SQS QUEUE';

      resource.info = function() {
        var info = {};

        info.created = moment(this.created_timestamp * 1000).format('MMMM Do YYYY, HH:mm');
        info.modified = moment(this.last_modified_timestamp * 1000).format('MMMM Do YYYY, HH:mm');
        info.retention = this.secondsToDMS(this.message_retention_period || 0);
        info.queue = this.getQueue();

        return info;
      };

      resource.getQueue = function() {
        return environment.connectedTo(this, "Resources::AWS::SQS::Queue")[0];
      };

      resource.secondsToDMS = function(seconds) {
        seconds = Number(seconds);
        var d = Math.floor(seconds / (3600*24));
        var h = Math.floor(seconds % (3600*24) / 3600);
        var m = Math.floor(seconds % 3600 / 60);
        var s = Math.floor(seconds % 60);

        var dDisplay = d > 0 ? d + (d === 1 ? " day " : " days ") : "";
        var hDisplay = h > 0 ? h + (h === 1 ? " hour " : " hours ") : "";
        var mDisplay = m > 0 ? m + (m === 1 ? " minute " : " minutes ") : "";
        var sDisplay = s > 0 ? s + (s === 1 ? " second" : " seconds") : "";

        return dDisplay + hDisplay + mDisplay + sDisplay;
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.aws.waf.rate_based_rule', ['designer.model.resource'])
  .factory('AWS_WAFRateBasedRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WAF RATE BASED RULE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.waf.rule', ['designer.model.resource'])
  .factory('AWS_WAFRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WAF RULE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.waf.rule_group', ['designer.model.resource'])
  .factory('AWS_WAFRuleGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WAF RULE GROUP';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.aws.waf.web_acl', ['designer.model.resource'])
  .factory('AWS_WAFWebACL', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'WAF CLASSIC WEB ACL';

        resource.info = function() {
          var info = {};

          info.rules = this.getRuleInfo();
          info.load_balancers = this.getAllLoadBalancers();

          return info;
        };

        // Get all connections for rules and then grab the remote resource
        resource.getRuleInfo = function() {
          var rules = this.getAllRules();

          return _.map(this.rules, function(r) {
            r.rule = _.find(rules, function(x) { return x.provider_id === r.rule_id });

            return r;
          }.bind(this));
        };

        resource.getAllRules = function() {
          return environment.connectedTo(this, "Resources::AWS::WAF::RateBasedRule")
            .concat(environment.connectedTo(this, "Resources::AWS::WAF::Rule"))
            .concat(environment.connectedTo(this, "Resources::AWS::WAF::RuleGroup"));
        };

        resource.getAllLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer")
            .concat(environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer"));
        };


        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.batch.application', ['designer.model.resource'])
  .factory('Azure_BatchApplication', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'BATCH ACCOUNT APPLICATION';

        resource.info = function() {
          var info = {};

          return info;
        };

        resource.getApplicationPackages = function() {
          return environment.connectedTo(this, "Resources::Azure::Batch::ApplicationPackage");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.batch.batch_account', ['designer.model.resource'])
  .factory('Azure_BatchAccount', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};

          info.storage = {};
          _.each(this.getStorage(), function(store) {
            info.storage[store.provider_id] = store;
          });

          info.pools = [];
          _.each(resource.getPools(), function(pool) {
            var pool_info = pool;
            pool_info.subnet = pool.getSubnet();
            info.pools.push(pool_info);
          });

          info.resource_group = resource.getResourceGroup();

          info.applications = [];
          _.each(resource.getApplications(), function(app) {
            var app_info = app;
            app_info.packages = app.getApplicationPackages();
            info.applications.push(app_info);
          });

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.account_endpoint,
            info3: null
          }
        };

        resource.getStorage = function() {
          return environment.connectedTo(this, "Resources::Azure::Storage::StorageAccount");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet");
        };

        resource.getPools = function() {
          return environment.connectedTo(this, "Resources::Azure::Batch::Pool");
        };

        resource.getApplications = function() {
          return environment.connectedTo(this, "Resources::Azure::Batch::Application");
        };

        resource.getResourceGroup = function() {
          return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
        };

        resource.getConnectables = function() {
          return this.getPools();
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.batch.pool', ['designer.model.resource'])
  .factory('Azure_BatchPool', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'BATCH ACCOUNT POOL';

        resource.info = function() {
          var info = {};
          info.resource_group = resource.getResourceGroup();
          info.subnet = resource.getSubnet();
          info.application_packages = {};
          _.each(this.getApplicationPackages(), function(pckg) {
            info.application_packages[pckg.provider_id] = pckg;
          });

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.vm_size,
            info3: null
          }
        };

        resource.getResourceGroup = function() {
          return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet")[0];
        };

        resource.getApplicationPackages = function() {
          return environment.connectedTo(this, "Resources::Azure::Batch::Application");
        };

        resource.isSubnetPool = function() {
          if (this.network_configuration && this.network_configuration.subnet_id) return true;
          return false;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.compute.availability_set', ['designer.model.resource'])
  .factory('Azure_AvailabilitySet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'AVAILABILITY SET';

        resource.info = function() {
          var info = {};

          info.virtual_machines = resource.getVirtualMachines();

          return info;
        };

        // TODO: this seems to return duplicates :/ ALL THE DAMN TIME
        resource.getVirtualMachines = function() {
          return environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachine");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.compute.virtual_machine', ['designer.model.resource'])
  .factory('Azure_VirtualMachine', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL MACHINE';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };

        // If the resource is stopped then display it faded out
        // resource.display_faded = (resource.status === 'stopped'); // TODO: which states?

        resource.info = function() {
          var info = {};

          info.virtualmachine_scaleset = resource.getVirtualMachineScaleSet();
          info.network_interfaces = resource.getNetworkInterfaces();
          info.security_groups = resource.getSecurityGroups();
          info.application_security_groups = resource.getApplicationSecurityGroups();
          info.availability_set = resource.getAvailabilitySet();
          info.extensions = resource.getVirtualMachineExtensions();

          return info;
        };

        resource.getPrimaryPrivateIP = function() {
          var nic = resource.getNetworkInterfaces()[0];

          if (nic) {
            var ipconf = nic.getIpConfigurations()[0];

            return ipconf ? ipconf.private_ipaddress : null;
          }

          return null;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.vm_size,
            info3: this.getPrimaryPrivateIP()
          }
        };

        resource.getAvailabilitySet = function() {
          return environment.connectedTo(this, "Resources::Azure::Compute::AvailabilitySet")[0];
        };

        resource.getVirtualMachineScaleSet = function() {
          return environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachineScaleSet");
        };

        resource.getVirtualMachineExtensions = function() {
          return environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachineExtension");
        };

        resource.getNetworkInterfaces = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface");
        };

        resource.getBackendAddressPools = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer::BackendAddressPool");
        };
        
        resource.getLBs = function() {
          var load_balancers = [];

          _.each(this.getNetworkInterfaces(), function(nic) {
            _.each(nic.getIpConfigurations(), function(ip) {
              _.each(ip.getBackendAddressPools(), function(bk) {
                load_balancers.push(bk.getLoadBalancer());
              });
            });
          });

          // This can also be directly connected directly to a backend address pool if it's a scale set VM
          _.each(this.getBackendAddressPools(), function(bk) {
            load_balancers.push(bk.getLoadBalancer());
          });

          // Add if any resources are connected via different routes
          if(resource.terraformMode()) {
            const lbs = environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer")
            load_balancers = load_balancers.concat(lbs)
          }

          return _.uniq(load_balancers);
        };

        resource.getSecurityGroups = function() {
          var security_groups = [];

          _.each(this.getNetworkInterfaces(), function(nic){
            security_groups.push(nic.getSecurityGroups());
          });

          // Can also have direct connections if it's a scale set VM
          security_groups = security_groups.concat(environment.connectedTo(this, "Resources::Azure::Network::NetworkSecurityGroup"));

          return _.uniq(_.flatten(security_groups));
        };

        resource.getApplicationSecurityGroups = function() {
          var app_security_groups = [];

          _.each(this.getNetworkInterfaces(), function(nic){
            _.each(nic.getIpConfigurations(), function(ip){
              var app_sg = ip.getApplicationSecurityGroup();
              if(app_sg)
                app_security_groups.push(app_sg);
            });
          });

          return _.uniq(app_security_groups);
        };

        resource.getConnectables = function() {
          return this.getLBs();
        };

        resource.hasIPMatch = function(ip) {
          var matched = false;

          _.each(this.getNetworkInterfaces(), function(nic) {
            if(nic.hasIPMatch(ip)) {
              matched = true;
            }
          });

          return matched;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.compute.virtual_machine_extension', ['designer.model.resource'])
  .factory('Azure_VirtualMachineExtension', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL MACHINE EXTENSION';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "succeeded": "good",
          "failed": "bad",
          "canceled": "stopped"
        };
        
        resource.info = function() {

        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.compute.virtual_machine_scale_set', ['designer.model.resource'])
  .factory('Azure_VirtualMachine_Scaleset', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL MACHINE SCALE SET';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "succeeded": "good",
          "failed": "bad",
          "canceled": "stopped"
        };

        resource.info = function() {
          var info = {};
          
          info.virtual_machines = resource.getVirtualMachines();

          return info;
        };

        resource.getVirtualMachines = function() {
          return environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachine");
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.dns.record_set', ['designer.model.resource'])
.factory('Azure_DNSRecordSet', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);

      resource.formatted_type = resource.record_set_type.replace("Microsoft.Network/dnszones/", "");

      resource.info = function() {
        var info = {};

        info.zone = this.getZone();
        info.resource_group = this.getResourceGroup();
        info.records = {
          "A Records": this.a_records,
          "AAAA Records": this.aaaa_records,
          "MX Records": this.mx_records,
          "NS Records": this.ns_records,
          "CAA Records": this.caa_records,
          "PTR Records": this.ptr_records,
          "SRV Records": this.srv_records
        }

        return info;
      };

      resource.getZone = function() {
        return environment.connectedTo(this, "Resources::Azure::DNS::Zone")[0];
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };


      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.dns.zone', ['designer.model.resource'])
  .factory('Azure_DNSZone', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.extended = { rs: true };

        resource.info = function() {
          var info = {};

          info.record_sets = this.getRecordSets();
          info.resource_group = this.getResourceGroup();

          var vnets = this.getVirtualNetworks();
          var find_network = function(vnet_id) {
            var vnet = _.find(vnets, (v) => v.id === vnet_id);

            return vnet ? vnet : { type: "not_found", name: vnet_id }
          }

          // TODO: we don't have any of these in prod so test with some dummy data
          info.registration_virtual_networks = _.map(this.registration_virtual_networks, find_network);
          info.resolution_virtual_networks = _.map(this.resolution_virtual_networks, find_network);

          return info;
        };

        resource.getResourceGroup = function() {
          return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
        };

        resource.getRecordSets = function() {
          return environment.connectedTo(this, "Resources::Azure::DNS::RecordSet");
        };

        resource.getVirtualNetworks = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::VirtualNetwork");
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.mariadb.server', ['designer.model.resource'])
.factory('Azure_MariaDBServer', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'MARIADB SERVER';

      resource.info = function() {
        var data = {};

        data.databases = this.getDatabases();
        data.firewall_rules = this.getFirewallRules();
        data.configurations = this.getConfigurations();
        data.master_server = this.getMasterServer();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getDatabases = function() {
        return environment.connectedTo(this, "Resources::Azure::MariaDB::Database");
      };

      resource.getFirewallRules = function() {
        return environment.connectedTo(this, "Resources::Azure::MariaDB::FirewallRule");
      };

      resource.getConfigurations = function() {
        return environment.connectedTo(this, "Resources::Azure::MariaDB::Configuration");
      };

      resource.getMasterServer = function() {
        return environment.connectedTo(this, "Resources::Azure::MariaDB::Server")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.eventhub.eventhub', ['designer.model.resource'])
.factory('Azure_EHEventHub', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'EVENT HUB';

      resource.info = function() {
        var data = {};

        data.namespace = this.getNamespace();
        data.consumer_groups = this.getConsumerGroups();
        data.storage_account = this.getStorageAccount();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getNamespace = function() {
        return environment.connectedTo(this, "Resources::Azure::EventHub::Namespace")[0];
      };

      resource.getStorageAccount = function() {
        return environment.connectedTo(this, "Resources::Azure::Storage::StorageAccount")[0];
      };

      resource.getConsumerGroups = function() {
        return environment.connectedTo(this, "Resources::Azure::EventHub::ConsumerGroup");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.eventhub.namespace', ['designer.model.resource'])
.factory('Azure_EHNamespace', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'EVENT HUB NAMESPACE';

      resource.info = function() {
        var data = {};

        data.event_hubs = this.getEventHubs();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getEventHubs = function() {
        return environment.connectedTo(this, "Resources::Azure::EventHub::EventHub");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.mysql.server', ['designer.model.resource'])
.factory('Azure_MySQLServer', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'MYSQL SERVER';

      resource.info = function() {
        var data = {};

        data.databases = this.getDatabases();
        data.firewall_rules = this.getFirewallRules();
        data.configurations = this.getConfigurations();
        data.master_server = this.getMasterServer();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getDatabases = function() {
        return environment.connectedTo(this, "Resources::Azure::Mysql::Database");
      };

      resource.getFirewallRules = function() {
        return environment.connectedTo(this, "Resources::Azure::Mysql::FirewallRule");
      };

      resource.getConfigurations = function() {
        return environment.connectedTo(this, "Resources::Azure::Mysql::Configuration");
      };

      resource.getMasterServer = function() {
        return environment.connectedTo(this, "Resources::Azure::Mysql::Server")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.network.application_gateway', ['designer.model.resource'])
  .factory('Azure_ApplicationGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'APPLICATION GATEWAY';

        resource.info = function() {
          var info = {};

          info.frontend_ip_addresses = resource.getFrontendIpConfigurations();
          info.backend_address_pools = resource.getBackendAddressPools();
          info.rules = resource.getRules();
          info.probes = resource.getProbes();

          return info;
        };

        resource.getFrontendIpConfigurations = function() {
          var frontend_ip_configurations = [];

          var frontend_ipconfs = environment.connectedTo(this, "Resources::Azure::Network::ApplicationGateway::FrontendIpConfiguration");
          
          _.each(frontend_ipconfs, function(fic){
            var fic_info = fic;
            fic_info.public_ip_address = fic.getPublicIpAddress();
          
            frontend_ip_configurations.push(fic_info);
          });

          return frontend_ip_configurations
        };

        resource.getBackendAddressPools = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ApplicationGateway::BackendAddressPool");
        };

        resource.getRules = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ApplicationGateway::Rule");
        };

        resource.getProbes = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ApplicationGateway::Probe");
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.application_security_group', ['designer.model.resource'])
  .factory('Azure_ApplicationSecurityGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'APPLICATION SECURITY GROUP';
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };
        
        resource.status = resource.provisioning_state;

        resource.info = function() {
          var info = {};

          info.rule_nsgs = resource.getRulesNetworkSecurityGroups();
          
          info.ip_configurations = _.map(resource.getIpConfigurations(), function(ip_conf) {
            ip_conf.nic = ip_conf.getNetworkInterface();
            ip_conf.vm = ip_conf.getVirtualMachine();

            return ip_conf;
          });

          return info;
        };

        resource.getSecurityRules = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkSecurityGroup::SecurityRule");
        };

        resource.getIpConfigurations = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface::IpConfiguration");
        };

        resource.getVirtualMachines = function() {
          var vms = [];
          var ip_confs = this.getIpConfigurations();

          _.each(ip_confs, function(ip_conf) {
            vms.push(ip_conf.getVirtualMachine());
          });
          return vms;
        };

        resource.getRulesNetworkSecurityGroups = function() {
          var security_rules = this.getSecurityRules();
          var rules = [];

          _.each(security_rules, function(security_rule) {
            var rule_info = security_rule.formatSecurityRule();
            rule_info.nsg = security_rule.getNetworkSecurityGroup();
            rules.push(rule_info);
          });
          return rules;
        };

        resource.highlightableConnections = function() {
          return this.getVirtualMachines();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.express_route_circuit', ['designer.model.resource'])
  .factory('Azure_ExpressRouteCircuit', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EXPRESS ROUTE CIRCUIT';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };

        resource.info = function() {
          var info = {};

          info.peerings = resource.getPeerings();

          return info;
        };

        resource.getPeerings = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ExpressRouteCircuit::Peering");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.firewall', ['designer.model.resource'])
  .factory('Azure_Firewall', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};
          var subnets = resource.getSubnets();
          var public_ip_addresses = resource.getPublicIpAddresses();
          info.subnets_map = {}
          info.public_ip_map = {}
          
          _.each(subnets, function(subnet) {
            info.subnets_map[subnet.provider_id] = subnet;
          });

          _.each(public_ip_addresses, function(public_ip) {
            info.public_ip_map[public_ip.provider_id] = public_ip;
          });

          return info;
        };

        resource.getPublicIpAddresses = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::PublicIpAddress");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet");
        };


        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.ip_configuration', ['designer.model.resource'])
  .factory('Azure_IpConfiguration', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'IP CONFIGURATION';

        resource.info = function() {
          var info = {};

          return info;
        };

        resource.getNetworkInterfaces = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface::IpConfiguration");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.load_balancer', ['designer.model.resource'])
  .factory('Azure_LoadBalancer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LOAD BALANCER';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };
        
        resource.info = function() {
          var info = {};

          info.virtual_machines    = resource.getVirtualMachines();
          info.frontend_ip_addresses = resource.getFrontendIpConfigurations();
          info.backend_address_pools = resource.getBackendAddressPools();
          info.rules = resource.getRules();
          info.probes = resource.getProbes();

          return info;
        };

        resource.getVirtualMachines = function() {
          var vms = [];
          var backend_address_pools = this.getBackendAddressPools();

          _.each(backend_address_pools, function(backend_address_pool){
            var ip_configs = backend_address_pool.getNetworkInterfaceIpConfiguration();

            _.each(ip_configs, function(ip_config) {
              vms.push(ip_config.getVirtualMachine());
            });

            // Scale set VMs can also be directly connected
            vms = vms.concat(backend_address_pool.getVirtualMachines());
          });

          // Add if any resources are connected via different routes
          if(resource.terraformMode()) {
            const virtual_machines = environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachine")
            vms = vms.concat(virtual_machines)
          }

          return _.uniq(vms);
        };

        resource.getFrontendIpConfigurations = function() {
          var frontend_ip_configurations = [];

          var frontend_ipconfs = environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer::FrontendIpConfiguration");

          _.each(frontend_ipconfs, function(fic){
            var fic_info = fic;
            fic_info.public_ip_address = fic.getPublicIpAddress();

            frontend_ip_configurations.push(fic_info);
          });

          return frontend_ip_configurations
        };

        resource.getBackendAddressPools = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer::BackendAddressPool");
        };

        resource.getRules = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer::Rule");
        };

        resource.getProbes = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer::Probe");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.local_network_gateway', ['designer.model.resource'])
  .factory('Azure_LocalNetworkGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LOCAL NETWORK GATEWAY';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };
        
        resource.info = function() {
          var info = {};

          info.vng_connections = this.getVirtualNetworkGatewayConnections();
          
          return info;
        };

        resource.getVirtualNetworkGatewayConnections = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::VirtualNetworkGatewayConnection");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.network_interface', ['designer.model.resource'])
  .factory('Azure_NetworkInterface', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NETWORK INTERFACE';

        resource.info = function() {
          var info = {};
          info.security_groups = resource.getSecurityGroups();
          info.virtual_machine = resource.getVirtualMachine();
          info.subnets = resource.getSubnets();
          info.ip_configurations = resource.getIpConfigurations();
          info.private_endpoints = resource.getPrivateEndpoints();
          info.app_security_groups = [];

          var public_ip_addresses = [];
          _.each(info.ip_configurations, function(ip_conf){
            public_ip_addresses.push(ip_conf.getPublicIpAddress());
            var app_sg = ip_conf.getApplicationSecurityGroup();
            if (app_sg) info.app_security_groups.push(app_sg);
          });

          info.public_ip_addresses = _.uniq(_.flatten(public_ip_addresses));

          return info;
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkSecurityGroup");
        };

        resource.getVirtualMachine = function() {
          return environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachine")[0];
        };
        
        resource.getIpConfigurations = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface::IpConfiguration");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet");
        };

        resource.getPrivateEndpoints = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::PrivateEndpoint");
        };

        resource.hasIPMatch = function(ip) {
          var matched = false;

          _.each(this.getIpConfigurations(), function(ip_config) {
            if(ip_config.private_ipaddress.lastIndexOf(ip, 0) === 0) {
              matched = true;
            }

            _.each(ip_config.public_ip_address, function(public_ip) {
              if(public_ip.ip_address.lastIndexOf(ip, 0) === 0) {
                matched = true;
              }
            }.bind(this));
          });

          return matched;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.network_security_group', ['designer.model.resource'])
  .factory('Azure_NetworkSecurityGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NETWORK SECURITY GROUP';

        resource.info = function() {
          var info = {};

          // Compile dem rules!
          info.subnets = resource.getSubnets();
          info.rules = resource.getRules();

          // Nics they is connected to!
          // TODO: can also connect directly to scale set vms
          var nics = [];
          _.each(this.getNetworkInterfaces(), function(nic) {
            var nic_info = nic;

            // Attach the ip address and such ...
            nic_info.vm = nic.getVirtualMachine();
            nic_info.ip_config = nic.getIpConfigurations();

            nics.push(nic_info);
          });
          info.nics = _.uniq(nics);

          return info;
        };

        resource.getRules = function() {
          var rules = { inbound: [], outbound: [] };
          var security_rules = this.getSecurityRules();

          _.each(security_rules, function(rule) {
            var rule_info = rule.formatSecurityRule();
            
            if(rule.direction == "Inbound") {
              rules.inbound.push(rule_info);
            }
            else {
              rules.outbound.push(rule_info);
            }
          });
          return rules;
        };

        resource.getSecurityRules = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkSecurityGroup::SecurityRule");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet");
        };

        resource.getNetworkInterfaces = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.private_endpoint', ['designer.model.resource'])
.factory('Azure_PrivateEndpoint', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);

      resource.info = function() {
        var info = {};

        info.subnet = this.getSubnet();
        info.network_interfaces = this.getNetworkInterfaces();

        var services = this.getConnectables();
        info.private_link_service_connections = _.map(this.private_link_service_connections, function(c) {
          c.connected_resource = _.find(services, (s) => s.provider_id.toLowerCase() === c.private_link_service_id.toLowerCase());

          return c;
        });

        info.manual_private_link_service_connections = _.map(this.manual_private_link_service_connections, function(c) {
          c.connected_resource = _.find(services, (s) => s.provider_id.toLowerCase() === c.private_link_service_id.toLowerCase());

          return c;
        });

        info.network_interfaces = this.getNetworkInterfaces();

        return info;
      };

      resource.getSubnet = function() {
        return environment.connectedTo(this, "Resources::Azure::Network::Subnet")[0];
      };

      resource.getNetworkInterfaces = function() {
        return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface");
      };

      resource.getConnectables = function() {
        return environment.findConnectedTo(this, [
          "Resources::Azure::Batch::BatchAccount",
          "Resources::Azure::EventHub::Namespace",
          "Resources::Azure::Redis::RedisCache",
          "Resources::Azure::Network::ApplicationGateway",
          "Resources::Azure::MariaDB::Server",
          "Resources::Azure::Mysql::Server",
          "Resources::Azure::Postgresql::Server",
          "Resources::Azure::ServiceBus::Namespace",
          "Resources::Azure::SQL::Server",
          "Resources::Azure::Storage::StorageAccount"
        ]);
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.network.public_ip_address', ['designer.model.resource'])
  .factory('Azure_PublicIpAddress', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'PUBLIC IP ADDRESS';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.route', ['designer.model.resource'])
  .factory('Azure_Route', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.route_table', ['designer.model.resource'])
  .factory('Azure_RouteTable', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE TABLE';

        resource.info = function() {
          var info = {};
          info.subnets = resource.getSubnets()
          info.routes = resource.getRoutes()

          return info;
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet");
        };

        resource.getRoutes = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Route");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.security_rule', ['designer.model.resource'])
  .factory('Azure_SecurityRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SECURITY RULE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.subnet', ['designer.model.resource'])
  .factory('Azure_Subnet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SUBNET';

        resource.info = function() {
          var info = {};
          info.security_groups = resource.getSecurityGroups();
          info.application_security_groups = resource.getApplicationSecurityGroups();
          info.route_tables = resource.getRouteTables();

          return info;
        };

        resource.getIpConfigurations = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface::IpConfiguration");
        };

        resource.getApplicationSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ApplicationSecurityGroup");
        };

        resource.getSecurityGroups = function() {
          var security_groups = environment.connectedTo(this, "Resources::Azure::Network::NetworkSecurityGroup");

          _.each(this.getIpConfigurations(), function(ip_conf){
            var network_interface = ip_conf.getNetworkInterface();
            if(network_interface) {
              security_groups.push(network_interface.getSecurityGroups());
            }
          });

          return _.uniq(_.flatten(security_groups));
        };

        resource.getRouteTables = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::RouteTable");
        };

        resource.getVirtualMachines = function() {
          return _.uniq(environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachine"));
        };

        resource.getLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer").concat(
            environment.connectedTo(this, "Resources::Azure::Network::ApplicationGateway")
          );
        };

        resource.getBatchPools = function() {
          return environment.connectedTo(this, "Resources::Azure::Batch::Pool");
        };

        resource.getPrivateEndpoints = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::PrivateEndpoint");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.virtual_network', ['designer.model.resource'])
  .factory('Azure_VirtualNetwork', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL NETWORK';

        resource.info = function() {
          var info = {};

          info.subnets = this.getSubnets();
          info.application_security_groups = this.getApplicationSecurityGroups();

          return info;
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet");
        };

        resource.getApplicationSecurityGroups = function() {
          var app_security_groups = [];

          _.each(this.getSubnets(), function(subnet){
              app_security_groups.push(subnet.getApplicationSecurityGroups());
          });

          return _.uniq(_.flatten(app_security_groups));
        };

        resource.getVirtualNetworkGateways = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::VirtualNetworkGateway");
        };

        resource.getLocalNetworkGateways = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LocalNetworkGateway");
        };

        resource.getFirewalls = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Firewall");
        };

        resource.getVirtualNetworkPeeringConnections = function() {
          return _.uniq(environment.connectedTo(this, "Resources::Azure::Network::VirtualNetworkPeering"));
        };

        resource.hasIPMatch = function(ip) {
          var matched = false;

          _.each(this.address_space_prefix, function(address) {
            if(address.lastIndexOf(ip, 0) === 0) {
              this.matched_search = true;
            }
          });

          return matched;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.virtual_network_gateway', ['designer.model.resource'])
  .factory('Azure_VirtualNetworkGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL NETWORK GATEWAY';

        resource.info = function() {
          var info = {};
          info.vn_gateway_ipconf = resource.getVNGatewayIpConfigurations();
          info.vng_connections = resource.getConnections();

          return info;
        };

        resource.getVNGatewayIpConfigurations = function() {
          var vn_gateway_ipconfigurations = [];

          var vngateway_ipconfs = environment.connectedTo(this, "Resources::Azure::Network::VirtualNetworkGateway::IpConfiguration");

          _.each(vngateway_ipconfs, function(vng_ip){
            var vng_ip_info = vng_ip;
            vng_ip_info.public_ip_address = vng_ip.getPublicIpAddress();

            vn_gateway_ipconfigurations.push(vng_ip_info);
          });

          return vn_gateway_ipconfigurations
        };

        resource.getConnections = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::VirtualNetworkGatewayConnection");
        };

        resource.getConnectables = function() {
          return _.compact(_.map(this.getConnections(), (con) => con.getLocalNetworkGateway()));
        }

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.virtual_network_gateway_connection', ['designer.model.resource'])
  .factory('Azure_VirtualNetworkGatewayConnection', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL NETWORK GATEWAY CONNECTION';

        resource.info = function() {
          var info = {};

          info.local_network_gateway = resource.getLocalNetworkGateway();
          info.virtual_network_gateways = resource.getVirtualNetworkGateways();

          return info;
        };

        resource.getLocalNetworkGateway = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LocalNetworkGateway")[0];
        };

        resource.getVirtualNetworkGateways = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::VirtualNetworkGateway");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.virtual_network_peering', ['designer.model.resource'])
  .factory('Azure_VirtualNetworkPeering', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VIRTUAL NETWORK PEERING';

        resource.info = function() {
          var info = {};

          const vnets = this.getVirtualNetworks();

          info.virtual_network = vnets.find((vnet) => vnet.provider_id.toLowerCase() === resource.virtual_network_id.toLowerCase());
          info.remote_virtual_network = vnets.find((vnet) => vnet.provider_id.toLowerCase() === resource.remote_virtual_network_id.toLowerCase());
          info.resource_group = resource.getResourceGroup();

          return info;
        };

        resource.getVirtualNetworks = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::VirtualNetwork");
        };

        resource.getResourceGroup = function() {
          return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.resources.resource', ['designer.model.resource'])
  .factory('Azure_Resource', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'RESOURCE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.resources.resource_group', ['designer.model.resource'])
  .factory('Azure_ResourceGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'RESOURCE GROUP';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };
        
        resource.resources_name = {
          "Resources::Azure::Batch::BatchAccount": "Batch Account",
          "Resources::Azure::Batch::Pool": "Batch Account Pool",
          "Resources::Azure::Compute::AvailabilitySet": "Availability Set",
          "Resources::Azure::Compute::VirtualMachine": "Virtual Machine",
          "Resources::Azure::Compute::VirtualMachineScaleSet": "Virtual Machine Scale Set",
          "Resources::Azure::DNS::Zone": "DNS Zone",
          "Resources::Azure::EventHub::Namespace": "Event Hub Namespace",
          "Resources::Azure::MariaDB::Server": "MariaDB Server",
          "Resources::Azure::Mysql::Server": "MySQL Server",
          "Resources::Azure::Network::ApplicationGateway": "Application Gateway",
          "Resources::Azure::Network::ApplicationSecurityGroup": "Application Security Group",
          "Resources::Azure::Network::ExpressRouteCircuit": "Express Route Circuit",
          "Resources::Azure::Network::LoadBalancer": "Load Balancer",
          "Resources::Azure::Network::LocalNetworkGateway": "Local Network Gateway",
          "Resources::Azure::Network::NetworkInterface": "Network Interface",
          "Resources::Azure::Network::NetworkSecurityGroup": "Network Security Group",
          "Resources::Azure::Network::PublicIpAddress": "Public IP Address",
          "Resources::Azure::Network::RouteTable": "Route Table",
          "Resources::Azure::Network::Subnet": "Subnet",
          "Resources::Azure::Network::VirtualNetwork": "Virtual Network",
          "Resources::Azure::Network::VirtualNetworkGateway": "Virtual Network Gateway",
          "Resources::Azure::Network::VirtualNetworkPeering": "Virtual Network Peering",
          "Resources::Azure::Postgresql::Server": "PostgreSQL Server",
          "Resources::Azure::Redis::RedisCache": "Redis Cache",
          "Resources::Azure::ServiceBus::Namespace": "Service Bus Namespace",
          "Resources::Azure::SQL::DataBase": "SQL Database",
          "Resources::Azure::Storage::StorageAccount": "Storage Account"
        };

        resource.info = function() {
          var info = {};

          var resources = resource.getAll();

          info.all = resources.reduce(function (types, currentValue) {
            if (types.indexOf(currentValue.type) === -1 && resource.resources_name[currentValue.type]) {
              types.push(currentValue.type);
            }
            return types;
          }, []).map(function (type) {
            return {
              type: type,
              name: resource.resources_name[type],
              resources: resources.filter(function (_el) {
                return _el.type === type;
              }).map(function (_el) {
                return _el;
              })
            }
          });

          return info;
        };

        resource.getAll = function() {
          return environment.connectedTo(this);
        };

        resource.getExpressRouteCircuits = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ExpressRouteCircuit");
        };

        resource.getStorageAccounts = function() {
          return environment.connectedTo(this, "Resources::Azure::Storage::StorageAccount");
        };

        resource.getBatchAccounts = function() {
          return environment.connectedTo(this, "Resources::Azure::Batch::BatchAccount");
        };

        resource.getBatchPools = function() {
          var pools_unassociated_subnet = []
          var all_batch_pools = environment.connectedTo(this, "Resources::Azure::Batch::Pool");
          _.each(all_batch_pools, function(pool){
            if(!pool.isSubnetPool()) pools_unassociated_subnet.push(pool);
          });
          return pools_unassociated_subnet;
        };

        resource.getEventHubNamespaces = function() {
          return environment.connectedTo(this, "Resources::Azure::EventHub::Namespace");
        };

        resource.getServicebusNamespaces = function() {
          return environment.connectedTo(this, "Resources::Azure::ServiceBus::Namespace");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.redis.redis_cache', ['designer.model.resource'])
  .factory('Azure_RedisCache', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REDIS CACHE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.servicebus.namespace', ['designer.model.resource'])
.factory('Azure_SBNamespace', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE BUS NAMESPACE';

      resource.info = function() {
        var data = {};

        data.topics = this.getTopics();
        data.queues = this.getQueues();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getTopics = function() {
        return environment.connectedTo(this, "Resources::Azure::ServiceBus::Topic");
      };

      resource.getQueues = function() {
        return environment.connectedTo(this, "Resources::Azure::ServiceBus::Queue");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.servicebus.queue', ['designer.model.resource'])
.factory('Azure_SBQueue', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE BUS QUEUE';

      resource.info = function() {
        var data = {};

        data.namespace = this.getNamespace();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getNamespace = function() {
        return environment.connectedTo(this, "Resources::Azure::ServiceBus::Namespace")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.servicebus.subscription', ['designer.model.resource'])
.factory('Azure_SBSubscription', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE BUS SUBSCRIPTION';

      resource.info = function() {
        var data = {};

        data.topic = this.getTopic();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getTopic = function() {
        return environment.connectedTo(this, "Resources::Azure::ServiceBus::Topic")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.servicebus.topic', ['designer.model.resource'])
.factory('Azure_SBTopic', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE BUS TOPIC';

      resource.info = function() {
        var data = {};

        data.namespace = this.getNamespace();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getNamespace = function() {
        return environment.connectedTo(this, "Resources::Azure::ServiceBus::Namespace")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.postgresql.server', ['designer.model.resource'])
.factory('Azure_PostgreSQLServer', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'POSTGRESQL SERVER';

      resource.info = function() {
        var data = {};

        data.databases = this.getDatabases();
        data.firewall_rules = this.getFirewallRules();
        data.configurations = this.getConfigurations();
        data.master_server = this.getMasterServer();

        return data;
      };

      resource.getResourceGroup = function() {
        return environment.connectedTo(this, "Resources::Azure::Resources::ResourceGroup")[0];
      };

      resource.getDatabases = function() {
        return environment.connectedTo(this, "Resources::Azure::Postgresql::Database");
      };

      resource.getFirewallRules = function() {
        return environment.connectedTo(this, "Resources::Azure::Postgresql::FirewallRule");
      };

      resource.getConfigurations = function() {
        return environment.connectedTo(this, "Resources::Azure::Postgresql::Configuration");
      };

      resource.getMasterServer = function() {
        return environment.connectedTo(this, "Resources::Azure::Postgresql::Server")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.azure.storage.storage_account', ['designer.model.resource'])
  .factory('Azure_StorageAccount', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'STORAGE ACCOUNT';
        resource.status = resource.provisioning_state;
        resource.status_list = {
          "deleting": "warn",
          "succeeded": "good",
          "updating": "warn",
          "failed": "bad"
        };
        
        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.sql.data_base', ['designer.model.resource'])
  .factory('Azure_SQL_DataBase', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SQL DATABASE';
        resource.status_list = {
          "online": "good",
          "offline": "stopped",
          "restoring": "warn",
          "recovering": "warn",
          "recovery pending": "warn",
          "suspect": "warn",
          "emergency": "bad"
        };

        resource.info = function() {
          var info = {};
          info.servers = resource.getServers()

          return info;
        };

        resource.getServers = function () {
          return environment.connectedTo(this, "Resources::Azure::SQL::Server")
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.sql.server', ['designer.model.resource'])
  .factory('Azure_SQL_Server', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SQL SERVER';

        resource.info = function() {
          var info = {};
          info.data_bases = resource.getDataBases()

          return info;
        };

        resource.getDataBases = function () {
          return environment.connectedTo(this, "Resources::Azure::SQL::DataBase")
        }

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.address', ['designer.model.resource'])
.factory('IBM_Address', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'ELASTIC IP';

      resource.info = function() {
        var info = {};

        info.vpc = this.getVpc();
        info.instance = this.getInstance();
        info.network_interface = this.getNetworkInterface();

        return info;
      };

      resource.getVpc = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
      };

      resource.getInstance = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Instance")[0];
      };

      resource.getNetworkInterface = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::NetworkInterface")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.customer_gateway', ['designer.model.resource'])
  .factory('IBM_CustomerGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CUSTOMER GATEWAY';

        resource.info = function() {
          var info = {};

          info.vpn_connection = this.getVPNConnection();

          return info;
        };

        resource.getVPNConnection = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPNConnection")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.dhcp_options', ['designer.model.resource'])
  .factory('IBM_DHCPOptions', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DHCP OPTIONS';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.egress_only_internet_gateway', ['designer.model.resource'])
  .factory('IBM_EgressOnlyInternetGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EGRESS ONLY INTERNET GATEWAY';

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.instance', ['designer.model.resource'])
.factory('IBM_Instance', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'INSTANCE';

      resource.summary_line =
        '<span class="resource-summary">' +
          resource.instance_type + " (" + resource.architecture + ")" + "&nbsp;&nbsp;&nbsp;" +
          resource.private_ip_address +
        '</span>';

      // If the resource is stopped then display it faded out
      resource.display_faded = (resource.status === 'stopped');

      resource.info = function() {
        var info = {};

        info.subnet = this.getSubnet();
        info.addresses = this.getAddresses();
        info.volumes = this.getVolumes();
        info.security_groups = this.getSecurityGroups();
        info.autoscaling_group = this.getAutoscalingGroup();
        info.network_interfaces = this.getNetworkInterfaces();
        info.ecs_clusters = this.getECSClusters();
        info.placement_group = this.getPlacementGroup();
        info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

        // Can have multiple IP's based on NICs, and they all link to different subnets. Weeee.
        var primary_ips = [];
        var secondary_ips = [];
        _.each(info.network_interfaces, function(nic) {
          var primary     = nic.getPrimaryPrivateIP();
          var secondaries = nic.getSecondaryPrivateIPs();
          var subnet      = nic.getSubnet();

          if(primary) {
            primary_ips.push({
              ip: primary.private_ip_address,
              subnet: subnet,
              nic: nic
            });
          }
          if(secondaries.length) {
            _.each(secondaries, function(ip) {
              secondary_ips.push({
                ip: ip.private_ip_address,
                subnet: subnet,
                nic: nic
              });
            });
          }
        });

        info.primary_private_ips = primary_ips;
        info.secondary_private_ips = secondary_ips;

        return info;
      };

      resource.summary = {
        "AMI": resource.ami,
        "AZ": resource.availability_zone,
        "Instance Type": resource.instance_type,
        "Private IP": resource.private_ip_address,
        "Arch": resource.architecture
      };

      resource.getExtendedInformation = function() {
        return {
          info1: this.provider_id,
          info2: this.private_ip_address,
          info3: this.public_ip_address
        }
      };

      resource.getIconInformation = function() {
        var txt = this.instance_type.split(".")[0].toUpperCase();

        return {
          txt: txt,
          fill: "#d86613",
          'font-size': 18,
          dx: txt.length === 3 ? 20 : 22,
          dy: 40
        }
      };

      resource.getSubnet = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Subnet")[0];
      };

      resource.getAddresses = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Address");
      };

      resource.getSecurityGroups = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::SecurityGroup");
      };

      resource.getVolumes = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Volume");
      };

      resource.getNetworkInterfaces = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::NetworkInterface");
      };

      resource.getPlacementGroup = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::PlacementGroup")[0];
      };

      // TODO: we actually have a direct link to the VPC now ... will we always have it though? Gots to checks out CF
      resource.getVpc = function() {
        var subnet = this.getSubnet();

        return (subnet) ? subnet.getVpc() : null;
      };

      resource.getELBs = function() {
        return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancing::LoadBalancer");
      };

      resource.getALBs = function() {
        var albs = [];

        _.each(environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::TargetGroup"), function(target_group) {
          albs = albs.concat(target_group.getApplicationLoadBalancers());
        });

        return albs;
      };

      resource.getNLBs = function() {
        var nlbs = [];

        _.each(environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::TargetGroup"), function(target_group) {
          nlbs = nlbs.concat(target_group.getNetworkLoadBalancers());
        });

        return nlbs;
      };

      resource.getAutoscalingGroup = function() {
        return environment.connectedTo(this, "Resources::IBM::AutoScaling::AutoScalingGroup")[0];
      };

      resource.getElasticBeanstalkEnvironment = function() {
        return environment.connectedTo(this, "Resources::IBM::ElasticBeanstalk::Environment")[0];
      };

      resource.getConnectables = function() {
        return this.getELBs().concat(this.getALBs()).concat(this.getNLBs());
      };

      // Can we have more than one ECS cluster?
      resource.getECSClusters = function() {
        var clusters = [];

        _.each(environment.connectedTo(this, "Resources::IBM::ECS::ContainerInstance"), function(container_instance) {
          clusters.push(container_instance.getCluster());
        });

        return _.uniq(clusters);
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.internet_gateway', ['designer.model.resource'])
.factory('IBM_InternetGateway', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'PUBLIC GATEWAY';

      resource.getVpc = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.nat_gateway', ['designer.model.resource'])
  .factory('IBM_NATGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTER';

        resource.info = function() {
          var info = {};

          info.address = this.getAddress();
          info.network_interfaces = _.map(this.getNetworkInterfaces(), function(nic) {
            nic.instance = nic.getInstance();

            return nic;
          });

          return info;
        };

        resource.getExtendedInformation = function() {
          var address = this.getAddress();
          var info = {
            info1: this.provider_id,
            info2: null,
            info3: null
          };

          if (address) {
            info.info2 = address.private_ip_address;
            info.info3 = address.public_ip;
          }

          return info;
        };

        resource.getNetworkInterfaces = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::NetworkInterface");
        };

        resource.getAddress = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Address")[0];
        };

        // We can match on address ip for nat gateway
        resource.hasIPMatch = function(ip) {
          var address = this.getAddress();
          var matched = false;

          if(address) {
            if(address.public_ip.lastIndexOf(ip, 0) === 0)          matched = true;
            if(address.private_ip_address.lastIndexOf(ip, 0) === 0) matched = true;
          }

          return matched;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.network_acl', ['designer.model.resource', 'designer.model.helpers.protocols'])
.factory('IBM_NetworkACL', ["Resource", "ProtocolHelpers", function(Resource, ProtocolHelpers) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'NETWORK ACL';

      resource.info = function() {
        var info = {};

        if(this.entries.length > 0) {
          info.entries = { inbound: [], outbound: [] };

          _.each(this.entries, function(entry) {
            // Convert entry into fields we can show
            var parsed_entry = {
              rule_number: entry.rule_number === 32767 ? "*" : entry.rule_number,
              rule_action: entry.rule_action,
              cidr_block: entry.cidr_block,
              icmp_type_code: entry.icmp_type_code,
              port_range: this.formatPortRange(entry.port_range),
              protocol: ProtocolHelpers.protocolNumberToName(entry.protocol)
            };

            if(entry.egress) {
              info.entries.outbound.push(parsed_entry);
            }
            else {
              info.entries.inbound.push(parsed_entry);
            }
          }.bind(this));
        }

        info.subnets = this.getSubnets();

        return info;
      };

      resource.formatPortRange = function(range) {
        if (range) {
          if (range["from"] === range["to"]) {
            return range["from"];
          }
          else {
            return range["from"] + " to " + range["to"];
          }
        }

        return "all";
      };

      resource.getSubnets = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
      };

      resource.highlightableConnections = function() {
        return this.getSubnets();
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.network_interface', ['designer.model.resource'])
  .factory('IBM_NetworkInterface', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NETWORK INTERFACE';

        resource.info = function() {
          var info = {};

          info.instance = this.getInstance();
          info.subnet = this.getSubnet();
          info.address = this.getAddress();
          info.route_tables = this.getRouteTables();
          info.security_groups = this.getSecurityGroups();
          info.nat_gateway = this.getNATGateway();
          info.primary_ip_address = this.getPrimaryPrivateIP();
          info.secondary_ip_addresses = this.getSecondaryPrivateIPs();

          return info;
        };

        resource.getPrimaryPrivateIP = function() {
          return _.find(this.private_ip_addresses, function(ip) { return ip["primary"] });
        };

        resource.getSecondaryPrivateIPs = function() {
          return _.filter(this.private_ip_addresses, function(ip) { return !ip["primary"] });
        };

        resource.getInstance = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Instance")[0];
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet")[0];
        };

        resource.getAddress = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Address")[0];
        };

        resource.getRouteTables = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::RouteTable");
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::SecurityGroup");
        };

        resource.getNATGateway = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::NATGateway")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.placement_group', ['designer.model.resource'])
.factory('IBM_PlacementGroup', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'PLACEMENT GROUP';

      resource.status_list = {
        "pending": "warn",
        "available": "good",
        "deleting": "warn",
        "deleted": "stopped"
      };

      resource.info = function() {
        var info = {};

        info.instances = this.getInstances()

        return info;
      };

      resource.getInstances = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Instance");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.route_table', ['designer.model.resource'])
  .factory('IBM_RouteTable', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE TABLE';

        resource.route_status_list = {
          "active": "good",
          "blackhole": "bad"
        };

        resource.info = function() {
          var info = {};

          info.subnets = this.getSubnets();

          var connections = environment.connectedTo(this);
          info.connection_ids = {
            egress_only_internet_gateway_id: "egress_only_internet_gateway",
            gateway_id: "gateway",
            instance_id: "instance",
            nat_gateway_id: "nat_gateway",
            transit_gateway_id: "transit_gateway",
            network_interface_id: "network_interface",
            vpc_peering_connection_id: "vpc_peering_connection"
          };

          info.routes = _.map(this.routes, function(route) {
            _.each(info.connection_ids, function(property_value, property_id) {
              if (route[property_id]) {
                route[property_value] = _.find(connections, function(c) { return c.provider_id === route[property_id] } );
              }
            });

            return route;
          }.bind(this));

          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
        };

        resource.highlightableConnections = function() {
          var types = [
            "Resources::IBM::EC2::NetworkInterface",
            "Resources::IBM::EC2::NATGateway",
            "Resources::IBM::EC2::Instance",
            "Resources::IBM::EC2::Subnet",
            "Resources::IBM::EC2::InternetGateway",
            "Resources::IBM::EC2::EgressOnlyInternetGateway",
            "Resources::IBM::EC2::VPCEndpoint",
            "Resources::IBM::EC2::VPCPeeringConnection",
            "Resources::IBM::EC2::VPNGateway"
          ];
          var connectables = _.map(types, function(type) { return environment.connectedTo(this, type) }.bind(this));

          return _.flatten(connectables);
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.security_group', ['designer.model.resource'])
  .factory('IBM_SecurityGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SECURITY GROUP';

        resource.info = function() {
          var info = {};

          var sg_permissions = this.getSecurityGroupPermissions();
          var ingress_rules = sg_permissions.filter(function(rule) {return rule.permission_type === "ingress";});
          var egress_rules = sg_permissions.filter(function(rule) {return rule.permission_type === "egress";});

          info.ingress_rules = _.map(ingress_rules, function(r) {
            return {
              range: this.translateRange(r),
              protocol: this.translateProtocol(r.ip_protocol),
              ip_ranges: r.ip_ranges,
              prefix_list_ids: r.prefix_list_ids,
              sources: r.getSourceGroups()
            }
          }.bind(this));

          info.egress_rules = _.map(egress_rules, function(r) {
            return {
              range: this.translateRange(r),
              protocol: this.translateProtocol(r.ip_protocol),
              ip_ranges: r.ip_ranges,
              prefix_list_ids: r.prefix_list_ids,
              sources: r.getSourceGroups()
            }
          }.bind(this));

          info.children = _.reject(environment.connectedTo(this, null, true), function(r) {
            return _.includes(["Resources::IBM::EC2::SecurityGroup","Resources::IBM::EC2::SecurityGroupPermission"], r.type);
          });

          return info;
        };

        resource.translateRange = function(rule) {
          var from_port = rule.from_port;
          var to_port   = rule.to_port;
          var protocol  = rule.ip_protocol;

          if(!from_port && !to_port && protocol === -1)
            return "ALL";

          return (from_port === to_port) ? from_port : from_port + " : " + to_port;
        };

        // TODO: for now we just care about ALL - will we want to handle all number versions at some point?
        resource.translateProtocol = function(protocol) {
          return (protocol == -1) ? "ALL" : protocol;
        };
        
        resource.highlightableConnections = function() {
          var highlightable = [];

          // If the linked resource is a nic then get what IT is connected to
          var connected = environment.connectedTo(this, null, true);
          _.each(connected, function(c) {
            if(c.type === "Resources::IBM::EC2::NetworkInterface") {
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if(c.type === "Resources::IBM::EFS::MountTarget") {
              // TODO: can we specify the actual icon? Each service is in multiple subnets but a sg can apply to only one sub
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if(c.type === "Resources::IBM::Redshift::Cluster") {
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else if(c.type === "Resources::IBM::ElastiCache::CacheCluster") {
              highlightable = highlightable.concat(c.highlightableConnections());
            }
            else {
              highlightable.push(c);
            }
          });

          return highlightable;
        };

        // SO I can get the permissions directly attached to this group, then from that I can link it to other groups
        resource.getSecurityGroupPermissions = function() {
          var permissions = [];

          _.each(this.connections, function(connection) {
            if (connection.remote_resource_type === "Resources::IBM::EC2::SecurityGroupPermission" && connection.resource_id === this.id) {
              permissions.push(environment.getResource(connection.remote_resource_id));
            }
          }.bind(this));

          return _.compact(permissions);
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.security_group_permission', ['designer.model.resource'])
  .factory('IBM_SecurityGroupPermission', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        // Get the source group for this rule, not it's other attachments
        resource.getSecurityGroup = function() {
          var parent = null;

          _.each(this.connections, function(connection) {
            if (connection.remote_resource_type === "Resources::IBM::EC2::SecurityGroupPermission" &&
                connection.remote_resource_id === this.id) {
              parent = environment.getResource(connection.resource_id);
            }
          }.bind(this));

          return parent;
        };

        resource.getSourceGroups = function() {
          var groups = [];

          _.each(this.connections, function(connection) {
            if (connection.remote_resource_type === "Resources::IBM::EC2::SecurityGroup" &&
                connection.resource_id === this.id) {
              groups.push(environment.getResource(connection.remote_resource_id));
            }
          }.bind(this));

          return _.compact(groups);
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.subnet', ['designer.model.resource'])
  .factory('IBM_Subnet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SUBNET';

        resource.rerender = ["cidr_block", "availability_zone"];

        resource.info = function() {
          var info = {};

          info.children = environment.connectedTo(this, null, true);
          info.vpc = this.getVpc();

          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
        };

        resource.getSubnetGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::RDS::DBSubnetGroup")
            .concat(environment.connectedTo(this, "Resources::IBM::ElastiCache::CacheSubnetGroup"))
            .concat(environment.connectedTo(this, "Resources::IBM::Redshift::ClusterSubnetGroup"));
        };

        resource.getNetworkACLs = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::NetworkACL");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.transitgateway', ['designer.model.resource'])
.factory('IBM_TransitGateway', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TRANSIT GATEWAY';

      resource.status_list = {
        "pending": "warn",
        "available": "good",
        "modifying": "warn",
        "deleting": "warn",
        "deleted": "stopped"
      };

      resource.info = function() {
        var info = {};

        info.attachments = this.getTransitGatewayAttachments();

        // We'll reference route tables using values from resource.options
        info.route_tables = {};
        _.each(this.getTransitGatewayRouteTables(), function(rt) {
          info.route_tables[rt.provider_id] = rt;
        });

        return info;
      };

      resource.getTransitGatewayRouteTables = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::TransitGatewayRouteTable");
      };

      resource.getTransitGatewayAttachments = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::TransitGatewayAttachment").
          concat(environment.connectedTo(this, "Resources::IBM::EC2::TransitGatewayVPCAttachment"));
      };

      resource.getConnectables = function() {
        var connected = [];

        _.each(environment.connectedTo(this, "Resources::IBM::EC2::TransitGatewayAttachment"), function(attachment) {
          var c = attachment.getVPNConnection();
          if(c) {
            var gateway = c.getCustomerGateway();
            if (gateway)
              connected.push(gateway);
          }
        });

        return connected;
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.transitgatewayattachment', ['designer.model.resource'])
.factory('IBM_TransitGatewayAttachment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TRANSIT GATEWAY ATTACHMENT';

      resource.status_list = {
        "pendingAcceptance": "warn",
        "rollingBack": "warn",
        "pending": "warn",
        "available": "good",
        "modifying": "warn",
        "deleting": "warn",
        "deleted": "stopped",
        "failed": "bad",
        "rejected": "bad",
        "rejecting": "bad",
        "failing": "bad"
      };
      
      resource.tgw_association_status_list = {
        "associating": "warn",
        "associated": "good",
        "disassociating": "warn",
        "disassociated": "bad"
      };

      resource.info = function() {
        var info = {};

        info.attached_to = this.getVPNConnection() || this.getDirectConnectGateway();
        info.transit_gateway = this.getTransitGateway();
        info.associated_route_table = this.getAssociatedTransitGatewayRouteTable();

        return info;
      };

      resource.getAssociatedTransitGatewayRouteTable = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::TransitGatewayRouteTable")[0];
      };

      resource.getDirectConnectGateway = function() {
        return environment.connectedTo(this, "Resources::IBM::DirectConnect::DirectConnectGateway")[0];
      };

      resource.getVPNConnection = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::VPNConnection")[0];
      };

      resource.getTransitGateway = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::TransitGateway")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.transitgatewayroutetable', ['designer.model.resource'])
.factory('IBM_TransitGatewayRouteTable', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.status_list = {
        "pending": "warn",
        "available": "good",
        "deleting": "warn",
        "deleted": "stopped"
      };

      resource.type_name = 'TRANSIT GATEWAY ROUTE TABLE';
      
      resource.info = function() {
        var info = {};

        info.transit_gateway = this.getTransitGateway();

        return info;
      };

      resource.getTransitGateway = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::TransitGateway")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.transitgatewayvpcattachment', ['designer.model.resource'])
.factory('IBM_TransitGatewayVPCAttachment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TRANSIT GATEWAY VPC ATTACHMENT';

      resource.status_list = {
        "pendingAcceptance": "warn",
        "rollingBack": "warn",
        "pending": "warn",
        "available": "good",
        "modifying": "warn",
        "deleting": "warn",
        "deleted": "stopped",
        "failed": "bad",
        "rejected": "bad",
        "rejecting": "bad",
        "failing": "bad"
      };

      resource.info = function() {
        var info = {};

        info.transit_gateway = this.getTransitGateway();
        info.vpc = this.getVPC();
        info.subnets = this.getSubnets();

        return info;
      };

      resource.getTransitGateway = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::TransitGateway")[0];
      };

      resource.getVPC = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
      };

      resource.getSubnets = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.ibm.ec2.volume', ['designer.model.resource'])
  .factory('IBM_Volume', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VOLUME';

        // TODO: bit of a dodgy hack for the minute to get this working for datapipe
        _.each(resource.tags, function(tag) {
          if(tag["key"].toLowerCase() === "name") {
            resource.name = tag["value"];
          }
        });

        resource.info = function() {
          var info = {};

          info.attachments = this.getAttachments();

          return info;
        };

        // Get attachments and add the resource so we can link to it
        resource.getAttachments = function() {
          // TODO: just get attached instances, none of this interface 'attached_to' crap
          var volumes = [];

          return volumes;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.vpc', ['designer.model.resource'])
  .factory('IBM_VPC', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPC';

        resource.rerender = ["cidr_block"];

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();
          info.route_tables    = this.getRouteTables();
          info.network_acls    = this.getNetworkACLs();
          info.dhcp_options    = this.getDhcpOptions();
          info.s3_buckets      = this.getS3Buckets();

          return info;
        };

        resource.getVpc = function() {
          return this;
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::SecurityGroup");
        };

        resource.getRouteTables = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::RouteTable");
        };

        resource.getDhcpOptions = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::DHCPOptions")[0];
        };

        resource.getNetworkACLs = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::NetworkACL");
        };

        resource.getS3Buckets = function() {
          return environment.connectedTo(this, "Resources::IBM::S3::Bucket");
        };

        resource.getInternetGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::InternetGateway");
        };

        resource.getEgressOnlyInternetGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::EgressOnlyInternetGateway");
        };

        resource.getVPNGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPNGateway");
        };

        resource.getCustomerGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::CustomerGateway");
        };

        resource.getWAFWebACLs = function() {
          return environment.connectedTo(this, "Resources::IBM::WAF::WebACL");
        };

        resource.getTransitGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::TransitGateway");
        };

        resource.getHostedZones = function() {
          return environment.connectedTo(this, "Resources::IBM::Route53::HostedZone");
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::IBM::CloudFront::Distribution").concat(
            environment.connectedTo(this, "Resources::IBM::CloudFront::StreamingDistribution")
          );
        };

        resource.getVPCEndpoints = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPCEndpoint");
        };

        resource.getDirectConnectGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::DirectConnect::DirectConnectGateway");
        };

        resource.getVPCPeeringConnections = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPCPeeringConnection");
        };

        resource.getAPIGateways = function() {
          return environment.connectedTo(this, "Resources::IBM::APIGateway::RestAPI");
        };

        // Some workspaces aren't connected to subnets, so we return them here
        resource.getWorkSpaces = function() {
          var workspaces = environment.connectedTo(this, "Resources::IBM::WorkSpaces::WorkSpace");
          return _.reject(workspaces, function(r) { return environment.connectedTo(r, "Resources::IBM::EC2::Subnet").length > 0 })
        };

        resource.getElasticBeanstalkEnvironments = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticBeanstalk::Environment");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.vpc_endpoint', ['designer.model.resource'])
  .factory('IBM_VPCEndpoint', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DIRECT LINK';

        resource.info = function() {
          var info = {};

          info.policy_document = JSON.stringify(JSON.parse(this.policy_document), null, 2);
          info.s3_buckets      = this.getS3Buckets();

          return info;
        };

        resource.getS3Buckets = function() {
          return environment.connectedTo(this, "Resources::IBM::S3::Bucket");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.vpc_peering_connection', ['designer.model.resource'])
  .factory('IBM_VpcPeeringConnection', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPC PEERING CONNECTION';

        resource.info = function() {
          var info = {};

          info.vpc_map = {};
          _.each(this.getVPCs(), function(vpc) {
            info.vpc_map[vpc.provider_id] = vpc;
          });

          return info;
        };

        resource.getVPCs = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.vpn_connection', ['designer.model.resource'])
  .factory('IBM_VpnConnection', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPN CONNECTION';

        resource.info = function() {
          var info = {};

          info.vpn_gateway = this.getVPNGateway();
          info.customer_gateway = this.getCustomerGateway();

          return info;
        };

        resource.getVPNGateway = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPNGateway")[0];
        };

        resource.getCustomerGateway = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::CustomerGateway")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.ec2.vpn_gateway', ['designer.model.resource'])
  .factory('IBM_VpnGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPN GATEWAY';

        resource.info = function() {
          var info = {};

          info.vpn_connections = this.getVPNConnections();
          info.gateway_associations = _.map(this.getDirectConnectGatewayAssociations(), function(association) {
            association.dc_gateway = association.getDirectConnectGateway();

            return association;
          }.bind(this));

          return info;
        };

        resource.getVPNConnections = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPNConnection");
        };

        resource.getDirectConnectGatewayAssociations = function() {
          return environment.connectedTo(this, "Resources::IBM::DirectConnect::DirectConnectGatewayAssociation");
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elastic_load_balancing.load_balancer', ['designer.model.resource'])
  .factory('IBM_LoadBalancer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LOAD BALANCER';

        resource.info = function() {
          var info = {};
          var autoscaling_groups = [];
          info.instances = [];

          var instances = this.getConnectedInstances();

          _.each(instances, function(instance) {
            var autoscaling_group = instance.getAutoscalingGroup();

            if (autoscaling_group) {
              autoscaling_group.instances = autoscaling_group.instances ? _.uniq(autoscaling_group.instances.concat(instance)) : [instance];
              autoscaling_groups = autoscaling_groups.concat(autoscaling_group);
            } else {
              info.instances = info.instances.concat(instance);
            }
          });

          info.autoscaling_groups = _.uniq(autoscaling_groups);
          info.security_groups = this.getSecurityGroups();
          info.subnets = this.getSubnets();
          info.services = this.getECSServices();
          info.cloudfront_distributions = this.getCloudFrontDistributions();
          info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

          return info;
        };

        resource.getConnectedInstances = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Instance");
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::SecurityGroup");
        };

        resource.getECSServices = function() {
          return environment.connectedTo(this, "Resources::IBM::ECS::Service");
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::IBM::CloudFront::Distribution");
        };

        // TODO: do we even use direct anymore? Also we don't really have a guaranteed direct link to VPC anymore
        resource.getVpc = function(direct) {
          var vpc = environment.connectedTo(this, "Interfaces::IBM::VPC::ELB")[0];

          // When getting the VPC for security groups we may want to go through subnet. When connecting to subnets we MUST have a VPC - so we go direct
          if(direct || vpc) {
            return vpc;
          }

          var subnet = this.getSubnet();
          return (subnet) ? subnet.getVpc() : null;
        };

        resource.getWebACLs = function() {
          return environment.connectedTo(this, "Resources::IBM::WAF::WebACL");
        };

        resource.getConnectables = function() {
          return this.getWebACLs();
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticBeanstalk::Environment")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elastic_load_balancing_v2.application_load_balancer', ['designer.model.resource'])
  .factory('IBM_ApplicationLoadBalancer', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'APPLICATION LOAD BALANCER';

        resource.rule_status = {};
        resource.built_info = null;

        resource.info = function() {
          if (this.built_info)
            return this.built_info;
          
          this.built_info = {};
          this.built_info.expanded = {};
          this.built_info.target_groups = [];
          this.built_info.instances = [];
          this.built_info.subnets = this.getSubnets();
          this.built_info.beanstalk_environment = this.getElasticBeanstalkEnvironment();

          this.built_info.listeners = _.map(this.getListeners(), function(listener) {
            listener.rules = _.map(listener.getRules(), function(rule) {
              rule.target_group = rule.getTargetGroup();
              if (rule.priority == 'default') return rule;
            });

            return listener;
          });

          var autoscaling_groups = [];
          this.built_info.target_groups = _.map(this.getTargetGroups(), function(target_group) {
            _.each(target_group.getInstances(), function(instance) {
              var autoscaling_group = instance.getAutoscalingGroup();

              if (autoscaling_group) {
                if(!autoscaling_group["target_groups"])
                  autoscaling_group.target_groups = [];

                autoscaling_group.instances = autoscaling_group.instances ? _.uniq(autoscaling_group.instances.concat(instance)) : [instance];
                autoscaling_group.target_groups.push(target_group);
                autoscaling_groups = autoscaling_groups.concat(autoscaling_group);
              } else {
                if(!instance["target_groups"])
                  instance.target_groups = [];

                instance.target_groups.push(target_group);
                this.built_info.instances = this.built_info.instances.concat(instance);
              }
            }.bind(this));
            return target_group;
          }.bind(this));

          this.built_info.autoscaling_groups = _.uniq(autoscaling_groups);
          this.built_info.web_acls = this.getWebACLs();
          this.built_info.vpc_link = this.getVPCLinks();
          this.built_info.instances = _.uniq(this.built_info.instances);
          this.built_info.cloudfront_distributions = this.getCloudFrontDistributions();

          return this.built_info;
        };

        resource.getListeners = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::Listener");
        };

        resource.getTargetGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::TargetGroup");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
        };

        resource.getWebACLs = function() {
          return environment.connectedTo(this, "Resources::IBM::WAF::WebACL");
        };

        resource.getConnectables = function() {
          return this.getWebACLs();
        };

        resource.getVPCLinks = function() {
          return environment.connectedTo(this, "Resources::IBM::APIGateway::VpcLink");
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::IBM::CloudFront::Distribution");
        };

        resource.getElasticBeanstalkEnvironment = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticBeanstalk::Environment")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elastic_load_balancing_v2.listener', ['designer.model.resource'])
  .factory('IBM_ALBListener', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'LISTENER';

        resource.info = function() {
          var info = {};
          info.rules = this.getRules();
          info.load_balancers = this.getApplicationLoadBalancers().concat(this.getNetworkLoadBalancers());

          return info;
        };

        resource.getRules = function() {
          var val = _.map(environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::Rule"), function(rule){
            rule.loadData();
            return rule;
          });
          return val;
        };

        resource.getTargetGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::TargetGroup");
        };

        resource.getApplicationLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::ApplicationLoadBalancer");
        };

        resource.getNetworkLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::NetworkLoadBalancer");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elastic_load_balancing_v2.network_load_balancer', [
  'designer.model.resource',
  'designer.model.resources.ibm.elastic_load_balancing_v2.application_load_balancer'
])
  .factory('IBM_NetworkLoadBalancer', ["IBM_ApplicationLoadBalancer", function(IBM_ApplicationLoadBalancer) {
    return {
      load: function(resource, environment) {
        resource = IBM_ApplicationLoadBalancer.load(resource, environment);
        resource.type_name = "NETWORK LOAD BALANCER";
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elastic_load_balancing_v2.rule', ['designer.model.resource'])
  .factory('IBM_ALBRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};

          return info;
        };

        // TODO: format condition info too? Maaaybe?
        resource.loadData = function() {
          _.each(this.actions, function(action, i){
            var config = {};
            if (action.type === 'forward'){
              config = action.forward_config;
            } else if (action.type === 'redirect'){
              config = action.redirect_config;
              this.actions[i].description = config["protocol"] + "://" + config["host"] + ":" + config["port"] + config["path"] + "?" + config["query"]
            } else if (action.type === 'fixed-response') {
              config = action.fixed_response_config;
              this.actions[i].description = config["status_code"]
            } else if (action.type === 'authenticate-cognito') {
              config = action.authenticate_cognito_config;
              this.actions[i].description = config["on_unauthenticated_request"]
            } else if (action.type ==='authenticate-oidc') {
              config = action.authenticate_oidc_config;
              this.actions[i].description = config["on_unauthenticated_request"]
            }
            this.actions[i].config = config

          }.bind(this));
        };

        resource.getTargetGroup = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::TargetGroup")[0];
        };


        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elastic_load_balancing_v2.target_group', ['designer.model.resource'])
  .factory('IBM_ALBTargetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET GROUP';

        resource.info = function() {
          var info = {};
          info.instances = this.getInstances();
          info.services = this.getECSServices();
          info.load_balancers = this.getApplicationLoadBalancers().concat(this.getNetworkLoadBalancers());
          
          return info;
        };

        resource.getApplicationLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::ApplicationLoadBalancer");
        };

        resource.getNetworkLoadBalancers = function() {
          return environment.connectedTo(this, "Resources::IBM::ElasticLoadBalancingV2::NetworkLoadBalancer");
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Instance");
        };

        resource.getECSServices = function() {
          return environment.connectedTo(this, "Resources::IBM::ECS::Service");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elasticache.cache_cluster', ['designer.model.resource'])
  .factory('IBM_ElastiCacheCacheCluster', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTIC CACHE';
        resource.status = resource.cache_cluster_status;

        resource.info = function() {
          var info = {};

          info.nodes = this.getNodes();

          return info;
        };

        resource.getNodes = function() {
          return environment.connectedTo(this, "Resources::IBM::ElastiCache::CacheNode");
        };

        resource.highlightableConnections = function() {
          return this.getNodes();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elasticache.cache_node', ['designer.model.resource'])
  .factory('IBM_ElastiCacheCacheNode', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'CACHE NODE';
        resource.status = resource.cache_node_status;
        
        resource.info = function() {
          var info = {};

          info.cache_cluster = this.getCacheCluster();

          return info;
        };

        resource.getExtendedInformation = function() {
          var cluster = this.getCacheCluster();

          return {
            info1: this.provider_id,
            info2: cluster.name,
            info3: null
          }
        };

        resource.getIconInformation = function() {
          return {
            txt: this.getCacheCluster().engine[0].toUpperCase(),
            fill: "#3b48cc",
            'font-size': 18,
            dx: 29, 
            dy: 50
          }
        };

        resource.getCacheCluster = function() {
          return environment.connectedTo(this, "Resources::IBM::ElastiCache::CacheCluster")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elasticache.parameter_group', ['designer.model.resource'])
  .factory('IBM_ElastiCacheParameterGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.elasticache.subnet_group', ['designer.model.resource'])
  .factory('IBM_ElastiCacheSubnetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ELASTICACHE SUBNET GROUP';

        resource.info = function() {
          var info = {};

          info.cache_clusters = this.getCacheClusters();
          info.subnets = this.getSubnets();

          return info;
        };

        resource.getCacheClusters = function() {
          return environment.connectedTo(this, "Resources::IBM::ElastiCache::CacheCluster");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.route53.hosted_zone', ['designer.model.resource'])
  .factory('IBM_Route53HostedZone', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE53 HOSTED ZONE';

        resource.info = function() {
          var info = {};

          info.resource_record_sets = this.getResourceRecordSets();

          return info;
        };

        resource.getResourceRecordSets = function() {
          return environment.connectedTo(this, "Resources::IBM::Route53::ResourceRecordSet");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.route53.resource_record_set', ['designer.model.resource'])
  .factory('IBM_Route53ResourceRecordSet', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.s3.bucket', ['designer.model.resource'])
  .factory('IBM_S3Bucket', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'OBJECT STORE';

        resource.info = function() {
          var info = {};

          info.policy_document = JSON.stringify(JSON.parse(this.policy), null, 2);
          info.cloudfront_distributions = this.getCloudFrontDistributions();
          
          return info;
        };

        resource.getCloudFrontDistributions = function() {
          return environment.connectedTo(this, "Resources::IBM::CloudFront::Distribution").concat(
            environment.connectedTo(this, "Resources::IBM::CloudFront::StreamingDistribution")
          );
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.rds.db_instance', ['designer.model.resource'])
  .factory('IBM_DBInstance', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        var ENGINE_FORMAT = {
          "mariadb": { txt: "MariaDB", 'font-size': 15, dy: 21 },
          "mysql": { txt: "MySQL", 'font-size': 15, dy: 21 },
          "oracle": { txt: "Oracle", 'font-size': 19, dy: 21 },
          "postgres": { txt: "PostgreSQL", 'font-size': 12, dy: 21, textLength: "60", lengthAdjust: "spacingAndGlyphs" },
          "aurora": { txt: "Amazon Aurora", 'font-size': 12, dy: 15, dx2: -46  },
          "rds": { txt: "Amazon RDS", 'font-size': 12, dy: 15, dx2: -46 },
          "proxy": { txt: "RDS Proxy", 'font-size': 12, dy: 15, dx2: -24 },
          "sqlserver": { txt: "SQL Server", 'font-size': 12, dy: 15, dx2: -24 },
        };
        
        resource = Resource.load(resource, environment);
        resource.type_name = 'DATA STORE';

        resource.summary_line =
          '<span class="resource-summary">' +
          resource.engine + " (" + resource.engine_version + ")" + "&nbsp;&nbsp;&nbsp;" +
          resource.instance_class +
          '</span>';

        resource.info = function() {
          var info = {};

          info.security_groups = this.getSecurityGroups();

          return info;
        };

        resource.getExtendedInformation = function() {
          return {
            info1: this.provider_id,
            info2: this.engine,
            info3: this.allocated_storage + " GB"
          }
        };

        resource.getIconInformation = function() {
          var base_engine_type = this.engine.split("-")[0] || this.engine;
          var attrs = {
            txt: "",
            fill: "#3b48cc",
            dx: 6, 
            dy2: 14
          }
          return _.assign(attrs, ENGINE_FORMAT[base_engine_type]);
        };

        resource.getSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::SecurityGroup");
        };

        // TODO: do we have this connection? Do we need it anywhere?
        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.rds.db_security_group', ['designer.model.resource'])
  .factory('IBM_DBSecurityGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DB SECURITY GROUP';

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.ibm.rds.db_subnet_group', ['designer.model.resource'])
  .factory('IBM_DBSubnetGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'RDS SUBNET GROUP';

        resource.info = function() {
          var info = {};

          info.subnets = this.getSubnets();

          return info;
        };

        resource.getVpc = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::VPC")[0];
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::IBM::EC2::Subnet");
        };

        resource.highlightableConnections = function() {
          return this.getSubnets();
        };

        return resource;
      }
    }
  }]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.shapes.meshfactory", [
    "designer.workspace.canvases.jointjs.3dview.modelmap",
    "designer.workspace.canvases.jointjs.3dview.shapes.line",
    "designer.workspace.canvases.jointjs.3dview.shapes.boxmesh",
  ])
  .service("MeshFactory", [
    "ModelMap",
    "Line3D",
    "ResourceMeshFactory",
    function (modelMap, lineFactory, resourceMeshFactory) {
      class MeshFactory {
        constructor() {
          this.modelMap = modelMap;
        }

        createMesh(model, paper3d) {
          var { attributes, resource } = model;
          const { type } = attributes;
          switch (type) {
            case "container":
              resourceMeshFactory.initialize(paper3d, modelMap);
              return resourceMeshFactory.create(model, false);
            case "resource":
              if (resource) {
                const { type } = resource;
                const modelFlag = this.is3DModelAvailable(type);
                resourceMeshFactory.initialize(paper3d, modelMap);
                return resourceMeshFactory.create(model, modelFlag)
              } else {
                resourceMeshFactory.initialize(paper3d, modelMap);
                return resourceMeshFactory.create(model, false);
              }
            case "link":
              lineFactory.initialize(model, paper3d);
              return lineFactory.createThickLine(model);
          }
        }

        is3DModelAvailable(type) {
          return this.modelMap.map[type];
        }
      }
      const meshFactory = new MeshFactory();
      return meshFactory;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.scene", [
    "designer.workspace.canvases.jointjs.3dview.shapes.meshfactory",
    "designer.workspace.canvases.jointjs.3dview.modelmap",
    "designer.workspace.canvases.jointjs.3dview.scene.intiializer",
    "designer.workspace.canvases.jointjs.3dview.utils.attribute_helper",
    "designer.workspace.canvases.jointjs.3dview.scene.animator",
    "designer.workspace.canvases.jointjs.3dview.shapes.textRenderer",
  ])
  .service("Scene", [
    "MeshFactory",
    "ModelMap",
    "AttributeHelper",
    "SceneInitializer",
    "Animator",
    "TextRenderer",
    "$rootScope",
    function (
      meshFactory,
      modelMap,
      helper,
      initializer,
      animator,
      textRenderer,
      $rootScope
    ) {
      class Scene {
        constructor() {
          this.modelMap = modelMap;
          this.linkRGBColor = [0, 0, 1];
          this.meshCount = 0;
          this.link3dCount = 0;
        }

        createScene = async (paper3d) => {
          initializer.initialize(paper3d);
          Object.assign(this, initializer);
          textRenderer.initialize(this, this.paper3d);
        };

        /*
        Create a box shape with a texture on it
        */

        createShape = function (model) {
          helper.processAttributes(model);
          meshFactory.createMesh(model, this.paper3d).then((mesh) => {
            // Mesh is produced, add to the scene now
            this.group.add(mesh);
            this.meshCount++;

            // Adjust Z-Coordinate as 3D models come in different size and shape
            if (model.attributes.type === "resource") {
              this.AdjustZCoOrdinates(mesh);
            }

            // Adjust camera as the scene gets bigger and complex
            this.adjustCamera(true);
            this.checkAndPerformFinalSteps();
            mesh.type = "mesh";
            textRenderer.fontPromise.then((font) => {
              textRenderer.render(model, font);
            });
          });
        };

        /*
        Update text position
        */
        updateText = function (model) {
          textRenderer.updateTextPosition(model);
        };

        /*
        Create a line shape
        */
        createLink = function (model) {
          meshFactory.createMesh(model, this.paper3d).then((line) => {
            this.group.add(line);
            this.link3dCount++;

            this.adjustCamera(true);

            line.type = "line";
            line.castShadow = false;
            model.mesh = line;
          });
        };

        /*
        Update shape
        */
        updateShape = function (view) {
          const { mesh, attributes } = view.model;
          const { position, size, type } = attributes;
          const { width, height } = size;
          var { x, y } = position;
          if (!mesh) return;
          view.mesh = mesh;
          mesh.position.x = x;
          mesh.position.y = y;
          mesh.translateX(width / 2);
          mesh.translateY(height / 2);
          mesh.position.y *= -1;

          // Check and update geometry (client side layout)
          if (type === "container") {
            this.updateGeometry(mesh, size);
          }

          // Update text
          this.updateText(view.model);
        };

        /*
        Update geometry scale
        Do this for client side layout changes
        */
        updateGeometry = function (mesh, size) {
          const { width, height } = size;
          const sizeVector = new THREE.Vector3();
          mesh.geometry.computeBoundingBox();
          mesh.geometry.boundingBox.getSize(sizeVector);
          const { x, y } = sizeVector;
          mesh.geometry.scale(width / x, height / y, 1);
          this.adjustCamera();
        };

        /*
        Update link
        */
        updateLink = function (view) {
          const { model } = view;

          const {
            source: {
              attributes: { position: source, size },
            },
            target: {
              attributes: { position: target },
            },
          } = view;

          let { width, height } = size;

          const route = [];
          const origin = [source.x + width / 2, source.y + height / 2, 10];
          const destination = [target.x + width / 2, target.y + height / 2, 10];

          var path = [];
          var colors = [...this.linkRGBColor, ...this.linkRGBColor];

          // If there are any points other than starting/ending which make up the route
          // get those points and set the path
          route.forEach((point) => {
            const { x, y } = point;
            const position = [x, y, 10];
            path = path.concat(position);
            colors = colors.concat(this.linkRGBColor);
          });

          // Use the points that make up the route and create a 3D line
          const points = [...origin, ...path, ...destination];
          const { mesh } = model;
          if (!mesh) return;
          view.mesh = mesh;
          mesh.geometry.setPositions(points);
          mesh.geometry.setColors(colors);
          mesh.geometry.scale(1, -1, 1);
        };

        /*
        Keep updating camera position as meshes keep adding to the scene
        */
        adjustCamera = function (updateCamera = false) {
          var { camera, light, group, plane } = this;

          var bbox = new THREE.Box3().setFromObject(group);
          var boxSize = new THREE.Vector3();
          var center = new THREE.Vector3();

          // Get the center and calculate the size
          bbox.getCenter(center);
          bbox.getSize(boxSize);

          group.translateX(-center.x);
          group.translateY(-center.y);

          // Calculate the bounding box position
          // to scale the underlying plane
          // Scaling 2x as we are only taking one direction positive x||y
          // Scaling 2x more to make it look bigger than environment itself
          let scaleX = bbox.max.x * 4;
          let scaleY = bbox.max.y * 4;

          // Keep the minimum to 10000
          scaleX = scaleX > 10000 ? scaleX : 10000;
          scaleY = scaleY > 10000 ? scaleY : 10000;

          plane.scale.set(scaleX, scaleY, 1);

          // TODO:  Position camera
          if (updateCamera) {
            this.setCameraHeight(camera, boxSize);
          }

          // Save camera state so you can use it to reset to later
          this.controls.saveState();

          return bbox;
        };

        /*
        Set camera height by calculating it based on FOV and BBox length
        */
        setCameraHeight = function (camera, boxSize) {
          const maxSideLength = Math.max(boxSize.x, boxSize.y);
          const fov = (camera.fov / 2) * (Math.PI / 180);
          const cornerAngle = Math.PI / 2 - fov;
          const requiredHeight = (Math.tan(cornerAngle) * maxSideLength) / 2;

          // Set it a little lower than the required to hightlight center of environment
          // while displaying most of the resources
          camera.position.z = requiredHeight * 0.6;
        };

        /*
        Set Camera position to (0,0) on (x,y) 
        */
        resetCameraPosition = function () {
          var { controls } = this;
          controls.reset();
          this.adjustCamera(true);
        };

        /*
        Check if all resources are rendered and then add grid
        */
        checkAndPerformFinalSteps = function () {
          if (this.meshCount === this.elementCount) {
            this.addGrid();
            this.setupPostProcessing();
            this.adjustCamera(true);

            $rootScope.$broadcast("reset:layout");
          }
        };

        /*
        Toggle 3D view
        */
        enable3DControls = () => {
          var toggleButton = $("#htoggle");
          var rotateButton = $("#hrotate");

          toggleButton.unbind("click");
          toggleButton.click(() => {
            animator.toggleTopDown(this.controls);
          });

          rotateButton.unbind("click");
          rotateButton.click(() => {
            animator.rotateScene(this.controls);
          });

          animator.releaseAzimuthalLock(this.controls);
        };

        /*
        Empty outlinepass
        */
        removeVPCHighlighting = () => {
          const vpcMesh = this.outlinePass.selectedObjects.filter((mesh) => {
            const { shape } = mesh.model.attributes;
            if (
              shape == "aws.vpc" ||
              shape == "gcp.network" ||
              shape == "azure.resource-group"
            ) {
              return mesh;
            }
          })[0];

          if (!vpcMesh) return;

          const index = this.outlinePass.selectedObjects.findIndex(
            (object) => object.id === vpcMesh.id
          );
          this.outlinePass.selectedObjects.splice(index, 1);
        };

        /*
        Adjust Z location
        */
        AdjustZCoOrdinates = (mesh) => {
          mesh.geometry.computeBoundingBox();
          mesh.position.z = mesh.geometry.boundingBox.max.z + 5;
        };

        setupOutlinePass = () => {
          Object.assign(this, initializer);
          $(this.domElement).hover(angular.noop, (e) => {
            this.removeVPCHighlighting();
          });
        };

        registerToWindow = () => {
          Object.assign(window, this);
        };

        /*
        Destroy scene
        */
        destroyScene = () => {
          // Remove everything from group i.e
          // links, text, default geometries, meshes etc
          while (this.group.children[0]) {
            const child = this.group.children[0];
            const { geometry, material } = child;

            // Recommended by Three.js team to call the following
            if (geometry) geometry.dispose();
            if (material.dispose) material.dispose();

            this.group.remove(child);
          }

          // Remove lighting, grid, plane and etc..,
          while (this.scene.children[0]) {
            this.scene.remove(this.scene.children[0]);
          }

          // Not sure
          let { renderer, scene, camera } = this;
          let { outlinePass, renderPass, composer } = this;
          renderer = scene = camera = composer = null;
          outlinePass = renderPass = composer = null;
        };

        /*
        Add empty css box which can be used once the mesh is clicked
        */
        addEmptyCSSObject = () => {
          var element = $(document.createElement("div"));
          element.attr("id", "css3dObject");

          this.css3DObject = new THREE.CSS3DObject(element[0]);
          this.css3DObject.position.set(0, 0, 150);
          this.css3DObject.rotateX(Math.PI / 2);

          this.cssScene.add(this.css3DObject);
        };

        /*
        Show information about the resource
        */
        showCSSBox = (mesh) => {
          const pos = mesh.position;
          const offset = this.group.position;

          const { model } = mesh;
          const { resource } = model;

          // Set the position to where the mesh is placed
          let x = pos.x + offset.x;
          let y = pos.y + offset.y;
          this.css3DObject.position.x = x;
          this.css3DObject.position.y = y;

          // Set the content
          let { innerHTML } = this.css3DObject.element;

          innerHTML = "";
          innerHTML += `<p> id: ${resource.provider_id}</p>`;
          innerHTML += `<p> name: ${resource.name}</p>`;
          innerHTML += `<p> type: ${resource.type_name}</p>`;

          this.css3DObject.element.innerHTML = innerHTML;
        };
      }

      const scene = new Scene();

      return scene;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.views.elementview3d", [])
  .service("ElementView3D", [
    function () {
      const ElementView3D = joint.dia.ElementView.extend({
        initialize: function () {
          joint.dia.ElementView.prototype.initialize.apply(this, arguments);
        },
        getNodeBBox: function (magnet) {
          const { attributes, mesh } = this.model;
          let { x, y } = attributes.position;
          let sizeVector = new THREE.Vector3();
          if (!mesh) return new joint.g.Rect();
          mesh.geometry.computeBoundingBox();
          const { boundingBox } = mesh.geometry;
          boundingBox.getSize(sizeVector);
          const width = sizeVector.x;
          const height = sizeVector.y;
          x += width / 2;
          y += height / 2;
          return new joint.g.Rect(x, y, sizeVector.x, sizeVector.y);
        },
        unhighlight: function (outlinePass) {
          if (this.mesh && outlinePass.clicked !== this.mesh) {
            const index = outlinePass.selectedObjects.findIndex(
              (object) => object.id === this.mesh.id
            );
            outlinePass.selectedObjects.splice(index, 1);
          }
        },
        unhighlightClicks: function (outlinePass) {
          if (this.mesh) {
            const index = outlinePass.selectedObjects.findIndex(
              (object) => object.id === this.mesh.id
            );
            outlinePass.selectedObjects.splice(index, 1);
          }
        },
        highlight: function (outlinePass, clicked=false) {
          if (this.mesh) {
            outlinePass.selectedObjects.push(this.mesh);
          }

          if (clicked) {
            outlinePass.clicked = this.mesh;
          }
        },
      });
      return ElementView3D;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.views.linkview3d", [])
  .service("LinkView3D", [
    function () {
      const LinkView3D = joint.dia.LinkView.extend({
        initialize: function () {
          joint.dia.LinkView.prototype.initialize.apply(this, arguments);
          const {
            model: {
              attributes: { source, target },
            },
          } = this;

          // Get source/target
          const cells = this.model.graph.getCells();
          this.source = cells.find((c) => c.id === source.id);
          this.target = cells.find((c) => c.id === target.id);
        },
        toggleVisibility: function (visibility) {
          if (this.mesh) {
            this.mesh.visible = visibility;
          }
        },
        show: function () {
          if (this.mesh) {
            this.mesh.visible = true;
          }
        },
        hide: function () {
          if (this.mesh) {
            this.mesh.visible = false;
          }
        },
      });
      return LinkView3D;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.shapes.line", [])
  .service("Line3D", [
    function () {
      class Line {
        initialize(model, paper3d) {
          this.model = model;
          this.paper3d = paper3d;
        }

        async create() {
          var material = new THREE.LineBasicMaterial({ color: "black" });
          var points = [];
          var geometry = new THREE.BufferGeometry().setFromPoints(points);
          var line = new THREE.Line(geometry, material);
          line.castShadow = true;
          line.receiveShadow = true;
          line.model = this.model;
          line.visible = false;
          return line;
        }

        async createThickLine() {

          const color = new THREE.Color(
            SCENE_CONFIG.SCENE.LINK_COLOR
          );

          var material = new THREE.LineMaterial({
            color,
            linewidth: 1,
            dashed: true,
          });
          material.resolution.set(window.innerWidth, window.innerHeight);
          var points = [0, 0, 0, 0, 0, 0];
          var geometry = new THREE.LineGeometry();
          geometry.setPositions(points);
          var line = new THREE.Line2(geometry, material);
          line.computeLineDistances();
          line.castShadow = true;
          line.receiveShadow = true;
          line.model = this.model;
          line.visible = false;
          return line;
        }
      }
      const line = new Line()
      return line;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.material.factory", [
    "designer.workspace.canvases.jointjs.3dview.material.map",
  ])
  .service("MaterialFactory", [
    "MaterialMap",
    function (materialMap) {
      class MaterialFactory {
        constructor() {
          this.loader = new THREE.TextureLoader();
        }

        /**
         * Get material for the mesh
         */
        getMaterial(color, image, type, resourceType) {
          var mat = new THREE.MeshLambertMaterial({
            color,
            side: THREE.DoubleSide,
            // transparent: false, opacity: 1
          });
          var mats = [];
          if (image && type === "resource") {
            // Get images from the svg icon map
            var el = document.getElementById(image.substring(1)).cloneNode(true);

            // Set height and width manually or Firefox won't render the texture
            const { width, height } = el.viewBox.baseVal;
            el.setAttribute('width', width);
            el.setAttribute('height', height);

            var svg_string = new XMLSerializer()
              .serializeToString(el)
              .replace(/symbol/g, "svg");
            var encodedData =
              "data:image/svg+xml;base64," + window.btoa(svg_string);

            const map = this.loader.load(encodedData);
            map.minFilter = THREE.LinearFilter;
            const faceMat = new THREE.MeshBasicMaterial({
              map
            });

            // Set material array based on resource geometry type
            if (["Cylinder", "Hexagon"].includes(materialMap[resourceType])) {
              mats = [mat, faceMat, mat];
            } else {
              mats = [mat, mat, mat, mat, faceMat, mat];
            }
          }
          if (mats.length !== 0) {
            return mats;
          } else {
            return mat;
          }
        }

        getGeometry(width, height, breadth, type) {
          let geometry;
          if (materialMap[type] === "Cylinder") {
            geometry = new THREE.CylinderBufferGeometry(
              width / 2.83,
              height / 2.83,
              breadth / 2,
              32
            );
            geometry.rotateX(Math.PI / 2);
            geometry.rotateZ(Math.PI / 2);
          } else if (materialMap[type] === "Hexagon") {
            geometry = new THREE.CylinderBufferGeometry(
              width / 2.83,
              height / 2.83,
              breadth / 2,
              6
            );
            geometry.rotateX(Math.PI / 2);
            geometry.rotateZ(Math.PI / 2);
          } else {
            geometry = new THREE.BoxBufferGeometry(
              width / 2,
              height / 2,
              breadth / 2
            );
          }
          return geometry;
        }

        getCylinderMaterial() {}

        getCubeMaterial() {}
      }

      const materialFactory = new MaterialFactory();
      return materialFactory;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.material.map", [])
  .service("MaterialMap", [
    function () {
      return {
        "Resources::AWS::EC2::VPCEndpoint": "Cylinder",
        "Resources::AWS::EC2::VPCPeeringConnection": "Cylinder",
        "Resources::AWS::WAF::WebACL": "Cylinder",
        "Resources::AWS::Lambda::Function": "Cylinder",
        "Resources::GCP::Compute::BackendService": "Hexagon",
        "Resources::GCP::Compute::ExternalVPNGateway": "Hexagon",
        "Resources::GCP::Compute::Instance": "Hexagon",
        "Resources::GCP::Compute::Interconnect": "Hexagon",
        "Resources::GCP::Compute::NATGateway": "Hexagon",
        "Resources::GCP::Compute::NetworkEndpointGroup": "Hexagon",
        "Resources::GCP::Compute::NodeGroup": "Hexagon",
        "Resources::GCP::Compute::RegionBackendService": "Hexagon",
        "Resources::GCP::Compute::RegionURLMap": "Hexagon",
        "Resources::GCP::Compute::TargetPool": "Hexagon",
        "Resources::GCP::Compute::URLMap": "Hexagon",
        "Resources::GCP::Compute::VPNGateway": "Hexagon",
        "Resources::GCP::DNS::ManagedZone": "Hexagon",
        "Resources::GCP::MemoryStore::ManagedZone": "Hexagon",
        "Resources::GCP::MemoryStore::Instance": "Hexagon",
        "Resources::GCP::SQL::Instance": "Hexagon",
        "Resources::GCP::Storage::Bucket": "Hexagon",
        "Resources::Azure::Compute::VirtualMachine": "Cylinder",
        "Resources::Azure::Compute::VirtualMachineScaleSetVM": "Cylinder",
        "Resources::Azure::Network::ApplicationGateway": "Cylinder",
        "Resources::Azure::Network::ExpressRouteCircuit": "Cylinder",
        "Resources::Azure::Network::LoadBalancer": "Cylinder",
        "Resources::Azure::Network::LocalNetworkGateway": "Cylinder",
        "Resources::Azure::Network::VirtualNetworkGateway": "Cylinder",
        "Resources::Azure::Network::VirtualNetworkPeering": "Cylinder",
        "Resources::Azure::Storage::StorageAccount": "Cylinder",
      };
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.shapes.modelFactory", [
    "designer.workspace.canvases.jointjs.3dview.modelmap",
  ])
  .service("ModelFactory", [
    "ModelMap",
    function (modelMap) {
      class ModelFactory {
        constructor() {
          this.cacheMap = [];
          this.loader = new THREE.OBJLoader();
          this.textureLoader = new THREE.TextureLoader();
          this.loaded = false;
        }

        /**
         * load from url
         */
        async load(url, model) {
          const { attributes } = model;
          const { size3d, id } = attributes;
          const { width, height, breadth } = size3d;

          // Since 3D models are already loaded and cached, just load/clone it from cache
          const material = this.cacheMap[url].material.clone();
          const geometry = this.cacheMap[url].geometry;

          const mesh = new THREE.Mesh(geometry, material);

          // If a geometry is alrealdy scaled. Don't do it again
          // Geometries are shared for performance reason so cloing it again does not make sense
          if (!mesh.geometry.scaled) {
            mesh.geometry.scale(width / 2, height / 2, breadth);
            mesh.geometry.scaled = true;
          }

          return mesh;
        }

        /*
        Load into cache pre render
        */
        async preLoadModels() {
          this.setTextureMap();
          const { assetLocation, map } = modelMap;
          const keys = Object.keys(map);
          for (let i = 0; i < keys.length; i++) {
            await modelFactory.loadModel(`${assetLocation}${map[keys[i]]}`);
          }

          this.loaded = true;
          return this.cacheMap;
        }

        /*
        load model
        */
        async loadModel(url) {
          return await fetch(url).then(async (blob) => {
            return await blob.text().then((text) => {
              const mesh = this.loader.parse(text).children[0];
              mesh.material.map = this.texture;
              const { geometry } = mesh;
              geometry.center();
              geometry.rotateX(Math.PI / 2);
              this.cacheMap[url] = mesh;
              return this.cacheMap[url];
            });
          });
        }

        /**
         * Set texture map
         */
        setTextureMap = () => {
          this.texture = this.textureLoader.load(modelMap.texture);
        };
      }
      const modelFactory = new ModelFactory();
      return modelFactory;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.shapes.boxmesh", [
    "designer.workspace.canvases.jointjs.3dview.shapes.modelFactory",
    "designer.workspace.canvases.jointjs.3dview.material.factory",
    "designer.workspace.canvases.jointjs.3dview.event3d"
  ])
  .service("ResourceMeshFactory", [
    "$rootScope",
    "ModelFactory",
    "MaterialFactory",
    "EventHandler3D",
    function ($rootScope, modelFactory, materialFactory, eventHandler) {
      class ResourceMeshFactory {
        /**
         * Initialize with required dependenices
         */
        initialize(paper3d, modelMap) {
          this.paper3d = paper3d;
          this.sm = paper3d.sceneManager;
          this.outlinePass = this.sm.outlinePass;
          this.modelMap = modelMap;
        }

        /**
         * Create the mesh with passed attributes
         */
        async create(model, modelFlag) {
          // Parse attributes
          const { attributes, resource } = model;
          const { size3d, type } = attributes;
          const { width, height, breadth } = size3d;

          var display_faded = false;
          var { color } = attributes;
          var image;

          if (resource) {
            display_faded = resource.display_faded;
            color = display_faded ? "#2f3640" : color;
            image = resource.image;
          }

          // Get material from factory based on type
          const material = materialFactory.getMaterial(color, image, type, resource.type);

          // Create geometry based on it's type and custom model availability
          let geometry;
          if (type === "resource") {
            geometry = materialFactory.getGeometry(width, height, breadth, resource.type);
          } else if (type === "container") {
            geometry = new THREE.PlaneBufferGeometry(width, height);
          }
          
          // Create mesh and setup event handling on it
          const mesh = new THREE.Mesh(geometry, material);
          if (modelFlag) {
            return await this.loadModelAndProcess(model, display_faded, color);
          } else {
            return this.process(model, mesh);
          }
        }

        /**
         * Take the mesh generated and setup event handling,
         * scale geometry and setup required references
         */
        process = (model, box) => {
          // Parse attributes
          const { attributes } = model;
          const { size3d, type, pos3d } = attributes;
          const { x, y, z } = pos3d;
          const { width, height } = size3d;

          // Setup references for later use
          box.castShadow = type === "container" ? false : true;
          box.receiveShadow = true;
          box.model = model;
          model.mesh = box;

          // Translate to match SVG co-ordinate system
          box.position.set(x, y, z);
          box.translateX(width / 2);
          box.translateY(height / 2);
          box.position.y *= -1;

          // Setup event listening and update model
          eventHandler.addEventListeners(box, this.paper3d);
          model.position(x, y);
          return box;
        };

        /**
         * Load 3D model and then once loaded process it like normal mesh
         */
        async loadModelAndProcess(model, display_faded, color) {
          // Parse attributes
          const { attributes, resource } = model;
          const { size3d } = attributes;
          const { width, height, breadth } = size3d;

          // Load 3D models
          const objectURL = this.modelMap.map[resource.type];
          var loader = new THREE.OBJLoader();
          const url = this.modelMap.assetLocation + objectURL;
          return await modelFactory.load(url, model).then((m) => {
            const mesh = m;
            if (display_faded) {
              mesh.material.color.set(color);
            }
            return this.process(model, mesh);
          });
        }
      }
      const resourceMeshFactory = new ResourceMeshFactory();
      return resourceMeshFactory;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.shapes.textRenderer", [
    "designer.workspace.canvases.jointjs.3dview.css3d",
  ])
  .service("TextRenderer", [
    "CSS3D",
    function (css3d) {
      class TextRenderer {
        constructor() {
          this.fontPromise = this.loadFont();
          this.linkRGBColor = [120, 120, 120];
        }

        initialize(sceneManager, paper3d) {
          this.sm = sceneManager;
          this.paper3d = paper3d;
        }

        /*
        Create fonts
        */
        loadFont = function () {
          let fontLocation;

          // Get the font location
          if (window.icons_url) {
            fontLocation = `${window.icons_url}/proxima_nova.ttf`;
          } else {
            fontLocation = "/assets/icons/proxima_nova.ttf";
          }

          return new Promise((resolve, reject) => {
            var ttfLoader = new THREE.TTFLoader();
            ttfLoader.load(fontLocation, (data) => {
              var font = new THREE.FontLoader().parse(data);
              resolve(font);
            });
          });
        };

        /*
        Take the model and font object and render labels and extended information
        */
        render = function (model, font) {
          const { extendedInfo, labelInfo } = model;
          const { mesh, attributes } = model;
          const { type } = attributes;
          var extras = this.renderArray(extendedInfo, model, font, "right");
          var labels = this.renderArray(labelInfo, model, font, "bottom");
          mesh.extras = extras;
          mesh.labels = labels;
          this.processLabels(mesh, type);
          this.processExtras(mesh);
        };

        /*
        Display labels only for containers by default
        */
        processLabels(mesh, type) {
          mesh.labels.forEach((label) => {
            switch (type) {
              case "resource":
                label.visible = false;
            }
          });
        }

        /*
        Don't show extended information by default
        */
        processExtras(mesh) {
          mesh.extras.forEach((extra) => {
            if (!this.paper3d.isExtView()) {
              extra.visible = false;
            }
          });
        }

        /*
        Take an array, iterate, generate text mesh and position it
        */
        renderArray = function (textArray, cell, font, style) {
          const { attributes, mesh } = cell;
          const { fontColor } = attributes;
          var tmat = new THREE.MeshLambertMaterial({ color: fontColor });
          var textMeshes = [];
          textArray.forEach((text, i) => {
            const { fontSize } = attributes;
            var shapes = font.generateShapes(text, fontSize);
            var geometry = new THREE.ShapeBufferGeometry(shapes);
            var tMesh = new THREE.Mesh(geometry, tmat);

            // By default the text will be placed at the center
            // Adjust it to be at the desired position
            this.adjust(tMesh, mesh, i, attributes, style);
            this.sm.group.add(tMesh);
            tMesh.name = 'text';
            textMeshes.push(tMesh);
          });
          return textMeshes;
        };

        /*
        Update Text Position
        */
        updateTextPosition = function (model) {
          // Update extras
          const { mesh, attributes} = model;
          if (!mesh.extras || !mesh.labels) return;
          mesh.extras.forEach((extra, i) => {
            this.adjust(extra, mesh, i, attributes, "right");
          });

          // Update labels
          mesh.labels.forEach((label, i) => {
              this.adjust(label, mesh, i, attributes, "bottom");
          });
        }

        /*
        Adjust the text mesh to be near text instead of center
        */
        adjust = (tMesh, mesh, i, attributes, style) => {
          const args = { tMesh, mesh, i, attributes };
          const { type } = attributes;
          switch (type) {
            case "container":
              css3d.modifyPosition("inside", args);
              break;
            default:
              css3d.modifyPosition(style, args);
              break;
          }
        };
      }

      const textRenderer = new TextRenderer();
      return textRenderer;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.scene.animator", [])
  .service("Animator", [
    function () {
      class Animator {
        constructor(fps, seconds) {
          this.fps = fps;
          this.seconds = seconds;
          this.frames = this.fps * this.seconds;
          this.rotation = Math.PI / 3;
          this.isTopDown = false;
          this.currentRotation = 0;
        }

        // Rotate along X axis by a fraction everytime this method is called.
        polarRotate = (angle, controls) => {
          controls.maxPolarAngle = angle;
          controls.minPolarAngle = angle;
        };

        // Rotate along Z axis by a fraction everytime this method is called.
        azimuthalRotate = (rotation, controls) => {
          this.currentRotation += (rotation / this.frames)
          this.currentRotation = parseFloat(this.currentRotation.toFixed(5));
          controls.minAzimuthAngle = this.currentRotation;
          controls.maxAzimuthAngle = this.currentRotation;
        };

        // Release the max/min settings for free rotation on right click
        releaseAzimuthalLock = (controls) => {
          controls.minAzimuthAngle = -Infinity;
          controls.maxAzimuthAngle = Infinity;
        };

        // Rotate the scene for different perspectives
        // Simply set max/min angle on orbit controls
        rotateScene = (controls) => {

          var counter = 0;
          var rotation = Math.PI / 4;
          this.currentRotation = controls.getAzimuthalAngle();
          const loop = () => {
            counter += 1;
            if (counter <= this.frames) {
              this.azimuthalRotate(rotation, controls);
              requestAnimationFrame(loop);
            } else {
              this.releaseAzimuthalLock(controls);
            }
          };
          loop();
        };

        // Toggle top down views.
        // Simply set max/min angle on orbit controls
        toggleTopDown = (controls) => {
          var counter = 0;
          if (!this.isTopDown) {
            const loop = () => {
              counter += 1;
              const angle =
                (this.rotation * (this.frames - counter)) / this.frames;
              this.polarRotate(angle, controls);
              if (counter < this.frames) {
                requestAnimationFrame(loop);
              }
            };
            loop();
          } else {
            const loop = () => {
              counter += 1;
              const angle = (this.rotation * counter) / this.frames;
              this.polarRotate(angle, controls);
              if (counter < this.frames) {
                requestAnimationFrame(loop);
              }
            };
            loop();
          }
          this.isTopDown = !this.isTopDown;
        };
      }

      const animator = new Animator(120, 0.2);
      return animator;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.utils.attribute_helper", [
    "designer.workspace.canvases.jointjs.3dview.infoservice",
  ])
  .service("AttributeHelper", [
    "InfoService",
    function (infoService) {
      class AttributeHelper {
        getZPoint = function (shape) {
          switch (shape) {
            case "aws.subnet":
            case "gcp.subnetwork":
            case "azure.subnet":
              return 5;
            case "aws.availability-zone":
            case "gcp.zone":
            case "azure.virtual-network":
              return 3;
            case "aws.vpc":
            case "gcp.network":
            case "azure.resource-group":
              return 1;
            default:
              return 0;
          }
        };

        getColor = function (shape) {

          // Get colors from global scene config
          const {
            CUBE_COLOR,
            SUBNET_COLOR,
            AZ_COLOR,
            VPC_COLOR,
          } = SCENE_CONFIG.ENVIRONMENT;

          switch (shape) {
            case "aws.subnet":
            case "gcp.subnetwork":
            case "azure.subnet":
              return SUBNET_COLOR;
            case "aws.availability-zone":
            case "gcp.zone":
            case "azure.virtual-network":
              return AZ_COLOR;
            case "aws.vpc":
            case "gcp.network":
            case "azure.resource-group":
              return VPC_COLOR;
            default:
              return CUBE_COLOR;
          }
        };
        getBreadth = function (type) {
          switch (type) {
            case "resource":
              return 40;
            case "container":
              return 2;
            default:
              return 40;
          }
        };
        processAttributes = function (model) {
          // Get 3D font config from global scene config
          const { FONT } = SCENE_CONFIG;

          const { shape, type, position, size } = model.attributes;
          const pos3d = { z: this.getZPoint(shape) };
          const size3d = { breadth: this.getBreadth(type) };
          Object.assign(pos3d, position);
          Object.assign(size3d, size);
          model.set("pos3d", pos3d);
          model.set("size3d", size3d);
          model.set("color", this.getColor(shape));
          model.set("fontSize", FONT.SIZE);
          model.set("fontColor", FONT.COLOR);
          model.resource = model.get("resource");
          model.extendedInfo = infoService.getExtendedInformation(model);
          model.labelInfo = infoService.getLabel(model);
        };
      }
      const helper = new AttributeHelper();
      return helper;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.css3d", [])
  .service("CSS3D", [
    function () {
      class CSS3DModifier {
        modifyPosition(style, args) {
          const { tMesh, mesh, i, attributes } = args;
          const { position } = tMesh;
          const bbox = this.getBBoxWorldPosition(mesh);
          const { min, max } = bbox;

          const textWidth = this.getWidth(tMesh);
          const boxWidth = Math.abs(max.x - min.x);

          const { fontSize } = attributes;
          let { x, y, z } = position;
          const padding = fontSize / 3;
          const depthOffset = 3;
          switch (style) {
            case "inside":
              x = min.x - padding + (boxWidth - textWidth);
              y = min.y + i * (fontSize + padding) + padding;
              z = max.z + depthOffset;
              break;
            case "bottom":
              x = min.x;
              y = min.y - fontSize - (i + 1) * (fontSize + padding);
              z = min.z + depthOffset;
              break;
            case "right":
              x = max.x + padding;
              y = max.y - fontSize - i * (fontSize + padding);
              z = min.z + depthOffset;
              break;
          }
          position.set(x, y, z);
        }

        /*
        Get bounding box values in the world position
        */
        getBBoxWorldPosition(mesh) {
          const size = new THREE.Vector3();
          const bbox = new THREE.Box3();
          const { position } = mesh;
          mesh.geometry.computeBoundingBox();
          const { boundingBox } = mesh.geometry;
          boundingBox.getSize(size);

          // Get world co-ordinates
          bbox.max.x = position.x + size.x / 2;
          bbox.max.y = position.y + size.y / 2;
          bbox.max.z = position.z + size.z / 2;

          bbox.min.x = position.x - size.x / 2;
          bbox.min.y = position.y - size.y / 2;
          bbox.min.z = position.z - size.z / 2;

          return bbox;
        }

        getWidth(tMesh) {
          var bbox = new THREE.Box3().setFromObject(tMesh);
          var center = new THREE.Vector3();
          bbox.getCenter(center);

          const { min, max } = bbox;
          const textWidth = Math.abs(max.x - min.x);

          return textWidth;
        }
      }

      const css3d = new CSS3DModifier();
      return css3d;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.event3d", [])
  .service("EventHandler3D", [
    "$rootScope",
    function ($rootScope) {
      class EventHandler3D {
        constructor() {
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.activeMeshes = [];
          this.previouslyActiveMeshes = []; // For firing hover off events
        }

        moveHandler = (sm, paper3d, event) => {
          const relativeX = event.clientX - sm.el.offset().left;
          const relativeY = event.clientY - sm.el.offset().top;
          this.mouse.x = (relativeX / sm.width) * 2 - 1;
          this.mouse.y = -(relativeY / sm.height) * 2 + 1;
          this.raycaster.setFromCamera(this.mouse, sm.camera);
          var intersects = this.raycaster
            .intersectObjects(sm.group.children)
            .slice(0, 1);

          this.findPreviousMeshes(paper3d, sm, intersects);
          this.activeMeshes = intersects.map((intersect) => intersect.object);
          this.activeMeshes.forEach((mesh) => {
            if (mesh.state !== "hoveron") {
              mesh.dispatchEvent({ type: "hoveron", paper3d, sm });
              mesh.state = "hoveron";
            }
          });
        };

        findPreviousMeshes(paper3d, sm, newIntersects) {
          var newMeshes = newIntersects.map((intersect) => intersect.object);
          this.previousMeshes = _.difference(this.activeMeshes, newMeshes);
          this.previousMeshes.forEach((mesh) => {
            if (mesh.state === "hoveron") {
              mesh.dispatchEvent({ type: "hoveroff", paper3d, sm });
              mesh.state = "hoveroff";
            }
          });
        }

        clickHandler = (sm, paper3d, event) => {
          const relativeX = event.clientX - sm.el.offset().left;
          const relativeY = event.clientY - sm.el.offset().top;
          this.mouse.x = (relativeX / sm.width) * 2 - 1;
          this.mouse.y = -(relativeY / sm.height) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, sm.camera);
          var intersects = this.raycaster
            .intersectObjects(sm.group.children)
            .slice(0, 1);

          intersects.forEach((intersect) => {
            intersect.object.dispatchEvent({ type: "click", paper3d });
          });

          if (intersects.length === 0) {
            paper3d.hideAllLinks();
            paper3d.unhighlightClicks();
          }
        };

        /**
         * Add event listeners on each box
         */
        addEventListeners(box) {

          // Hover handler
          box.addEventListener("hoveron", (event) => {
            const mesh = event.target;
            const { shape } = mesh.model.attributes;
            if (!shape) {
              var view = event.paper3d.findViewByModel(mesh.model);
              view.highlight(event.sm.outlinePass);
            }
            $("#paper3d").css("cursor", "pointer");
          });

          // Hover out handler
          box.addEventListener("hoveroff", (event) => {
            const mesh = event.target;
            const { shape } = mesh.model.attributes;
            if (!shape) {
              var view = event.paper3d.findViewByModel(mesh.model);
              if (view) {
                view.unhighlight(event.sm.outlinePass);
              }
            }
            $("#paper3d").css("cursor", "default");
          });

          // Click handler
          box.addEventListener("click", (event) => {
            const { resource } = event.target.model;
            $rootScope.$broadcast("resource:selected", resource);
            $rootScope.$broadcast("resource:selected:3d", event.target);
            event.paper3d.showLinks(event.target.model);
          });
        }
      }
      const eventHandler3D = new EventHandler3D();
      return eventHandler3D;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.infoservice", [
    "designer.workspace.canvases.jointjs.3dview.scene",
  ])
  .service("InfoService", [
    function () {
      class InfoService {
        getExtendedInformation(model) {
          var textArray = [];
          const { resource, attributes, showExtendedInfo } = model;
          const { type } = attributes;

          if (resource && showExtendedInfo) {
            var { info1, info2, info3 } = resource.getExtendedInformation();
            // Trim them to 15 chars as they look ugly any longer
            var trimLength = 15;
            if (info1 && info1.substring)
              textArray.push(info1.substring(0, trimLength));
            if (info2 && info2.substring)
              textArray.push(info2.substring(0, trimLength));
            if (info3 && info3.substring)
              textArray.push(info3.substring(0, trimLength));
          }

          switch (type) {
            case "container":
            case "link":
              return [];
            case "resource":
              return textArray;
          }
        }

        /*
        Have to improve the structuring/design here
        */
        getLabel(model) {
          const { attributes } = model;
          const { type } = attributes;

          switch (type) {
            case "container":
              return this.getContainerLabel(model);
            case "resource":
              return this.getResourceLabel(model);
            case "link":
              return [];
          }
        }

        // Container label logic
        getContainerLabel(model) {
          const { resource, attributes } = model;
          const { shape } = attributes;
          const { provider_id, cidr_block, name } = resource;
          const labels = [];

          labels.push(name);
          if (shape === "aws.vpc") {
            labels.push(cidr_block);
          }
          if (shape === "aws.subnet") {
            labels.push(`${provider_id} - ${cidr_block}`)
          }
          return labels;
        }

        // Resource label logic
        getResourceLabel(model) {
          const { resource } = model;

          var name = "";

          if (resource && resource.name) {
            name = resource.name;
          } else {
            name = model.name;
          }

          if (!name) return [];

          return name.match(/.{1,10}/g);
        }
      }
      const infoService = new InfoService();
      return infoService;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.scene.intiializer", [
    "designer.workspace.canvases.jointjs.3dview.event3d",
  ])
  .service("SceneInitializer", [
    "EventHandler3D",
    function (eventHandler3D) {
      class SceneInitializer {
        initialize(paper3d) {
          this.paper3d = paper3d;
          this.setupScene();
          this.setupCamera();
          this.setupRenderer();
          this.addShadows();
          this.setupEventHandling();
          this.addPlane();
          this.setupControls();
          this.addLight();
          this.addDirectionalLight();
          this.addStats();
          this.startRenderLoop();
        }

        /*
        Setup scene
        */
        setupScene = () => {
          this.scene = new THREE.Scene();
          this.cssScene = new THREE.Scene();
          this.group = new THREE.Group();
          this.scene.add(this.group);
          this.scene.background = new THREE.Color(
            SCENE_CONFIG.SCENE.BACKGROUND_COLOR
          );

          this.el = $(".designer-workspace");
          this.width = this.el.width();
          this.height = this.el.height();
          this.aspect = this.width / this.height;
        };

        /*
        Setup camera
        */
        setupCamera = () => {
          this.camera = new THREE.PerspectiveCamera(45, this.aspect, 1, 20000);
          this.camera.position.set(0, 0, 0);
          this.camera.up.set(0, 0, 1);
        };

        /*
        Setup webGL renderer
        */
        setupRenderer = () => {
          this.renderer = new THREE.WebGLRenderer({
            antialias: false,
            canvas: $("#pape3dcanvas")[0],
          });
          this.renderer.setSize(this.width, this.height);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.domElement = $(this.renderer.domElement);
          this.currentRenderer = this.renderer;

          $(window).resize(() => {
            this.resizeHandler();
          });
        };

        /*
        Setup post processing. Mainly outline pass.
        */
        setupPostProcessing = () => {

          // Add effect composer
          this.composer = new THREE.EffectComposer(this.renderer);

          // Add render pass, fxaa pass and outline pass
          this.renderPass = new THREE.RenderPass(this.scene, this.camera);
          this.composer.addPass(this.renderPass);

          this.outlinePass = new THREE.OutlinePass(
            new THREE.Vector2(this.width, this.height),
            this.scene,
            this.camera
          );

          // Global scene configs
          const {
            edgeStrength,
            edgeGlow,
            edgeThickness,
            visibleEdgeColor,
          } = SCENE_CONFIG.HIGHLIGHTING;

          this.outlinePass.edgeStrength = edgeStrength;
          this.outlinePass.edgeGlow = edgeGlow;
          this.outlinePass.edgeThickness = edgeThickness;
          this.outlinePass.visibleEdgeColor.set(visibleEdgeColor);
          this.composer.addPass(this.outlinePass);

          this.currentRenderer = this.composer;
          const { sceneManager } = this.paper3d;
          sceneManager.setupOutlinePass();
          // End
        };

        /*
        Add stats for debugging and monitoring purpose
        */
        addStats = () => {
          this.stats = new Stats();
          this.stats.showPanel(0);
          $("#paper3d").append(this.stats.domElement);
          // Remove inline styles
          $(this.stats.domElement).removeAttr("style");
          $(this.stats.domElement).attr("id", "stats");
          $(this.stats.dom).toggle();

          $(this.el).keyup((e) => {
            if (e.shiftKey && e.keyCode === 69) {
              this.toggleStatsVisibility();
            }
          })
        };

        /*
        Toggle stats visibility
        */
        toggleStatsVisibility = () => {
          $(this.stats.dom).toggle();
        }

        /*
        Loop every frame
        */
        startRenderLoop = () => {
          const renderLoop = () => {
            setTimeout(() => {
              requestAnimationFrame(renderLoop);
            }, 1000 / 120);
            this.stats.begin();
            this.controls.update();
            this.setVisibility();
            this.currentRenderer.render(this.scene, this.camera);
            this.stats.end();
          };
          renderLoop();
          this.sceneCreated = true;
        };

        /*
        Add properties to the renderer object that will get the shadows working
        */
        addShadows = () => {
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          this.renderer.outputEncoding = THREE.sRGBEncoding;
          this.renderer.shadowMapSoft = true;
        };


        /*
        Set explicit visibility in render loop
        This is probably a 'stop gap' fix for disappearing meshes due to highlighting logic
        */
       setVisibility = () => {
         this.group.children.forEach((child) => {
           if (child.type === 'mesh') {
             child.visible = true;
           }
         })
       }

        /*
        Set the renderer properties once the scene resizes
        */
        resizeHandler = () => {
          this.width = this.el.width();
          this.height = this.el.height();
          this.renderer.setSize(this.width, this.height);
          this.camera.aspect = this.width / this.height;
          this.camera.updateProjectionMatrix();
        };

        /*
        Add the plane geometry to the scene.
        */

        addPlane = () => {
          var geometry = new THREE.PlaneBufferGeometry(1, 1);
          var material = new THREE.MeshBasicMaterial({
            color: SCENE_CONFIG.SCENE.PLANE_COLOR
          });
          var plane = new THREE.Mesh(geometry, material);
          plane.position.z = -1;
          plane.receiveShadow = true;
          this.plane = plane;
          this.scene.add(plane);
        };

        /*
        Add a grid to debug positions from to time to time.
        */
        addGrid = function () {
          // Get grid colors from scene config
          const {
            GRID,
            GRID_CENTER_LINE_COLOR,
            GRID_LINE_COLOR,
            GRID_UNIT_SIZE
          } = SCENE_CONFIG.SCENE;

          const { x, y } = this.plane.scale;
          const scaleMax = x > y ? x : y;

          var size = scaleMax;
          var divisions = scaleMax / GRID_UNIT_SIZE; // One grid size length
          var gridHelper = new THREE.GridHelper(
            size,
            divisions,
            GRID_CENTER_LINE_COLOR,
            GRID_LINE_COLOR
          );
          gridHelper.position.z = 0;
          gridHelper.rotateX(Math.PI / 2);
          this.gridHelper = gridHelper;
          this.gridHelper.visible = GRID;
          this.scene.add(gridHelper);
        };

        /*
        Add the ambient and directional lighting to the scene
        */
        addLight = () => {
          // Get lighting configs from global scene configs
          const { AMBIENT } = SCENE_CONFIG.LIGHTING;
          const { INTENSITY } = AMBIENT;

          var ambientLight = new THREE.AmbientLight(0x404040);
          ambientLight.intensity = INTENSITY;

          this.scene.add(ambientLight);
          this.ambientLight = ambientLight;
        };

        /*
        Add the ambient and directional lighting to the scene
        */
        addDirectionalLight = () => {
          // Get lighting configs from global scene configs
          const { DIRECTIONAL } = SCENE_CONFIG.LIGHTING;
          const { INTENSITY, SHADOWS, COLOR, POSITION, VISIBLE } = DIRECTIONAL;
          const { x, y, z } = POSITION;

          var dirLight = new THREE.DirectionalLight(COLOR, INTENSITY);
          dirLight.castShadow = SHADOWS;
          dirLight.visible = VISIBLE;
          dirLight.position.set(x, y, z);
          this.scene.add(dirLight);

          this.dirLight = dirLight;
        };

        setupDirectionalLightShadows = () => {
          let wh = 512 * 2;
          this.dirLight.shadow.mapSize.width = wh; // default
          this.dirLight.shadow.mapSize.height = wh; // default
          this.dirLight.shadow.camera.near = 100; // default
          this.dirLight.shadow.camera.far = 2500;

          let cameraFrustrumEdgeSize = 2500;

          this.dirLight.shadow.camera.left = -cameraFrustrumEdgeSize;
          this.dirLight.shadow.camera.right = cameraFrustrumEdgeSize;
          this.dirLight.shadow.camera.top = cameraFrustrumEdgeSize;
          this.dirLight.shadow.camera.bottom = -cameraFrustrumEdgeSize;
        };

        toggleDirectionalLightShadows = () => {
          this.dirLight.castShadow = !this.dirLight.castShadow;
        };

        /*
        Setup controls
        */
        setupControls = () => {
          // Pull controls from scene config

          const { CONTROLS } = SCENE_CONFIG;

          const { camera, renderer } = this;
          this.controls = new THREE.OrbitControls(camera, renderer.domElement);
          this.controls.keyPanSpeed = CONTROLS.keyPanSpeed;
          this.controls.enableDamping = CONTROLS.enableDamping;
          this.controls.dampingFactor = CONTROLS.dampingFactor;
          this.controls.minPolarAngle = CONTROLS.minPolarAngle;
          this.controls.maxPolarAngle = CONTROLS.maxPolarAngle;
          this.controls.maxAzimuthAngle = CONTROLS.maxAzimuthAngle;
          this.controls.minAzimuthAngle = CONTROLS.minAzimuthAngle;
          this.controls.maxDistance = CONTROLS.maxDistance;
          this.controls.minDistance = CONTROLS.minDistance;

          // Change mous bindings => left click to pan and right click to rotate
          this.controls.mouseButtons.LEFT = 2;
          this.controls.mouseButtons.RIGHT = 0;
        };

        /*
        Setup event handling!
        */
        setupEventHandling = () => {
          const onMouseMove = (event) => {
            eventHandler3D.moveHandler(this, this.paper3d, event);
          };
          const onMouseClick = (event) => {
            eventHandler3D.clickHandler(this, this.paper3d, event);
          };
          $(this.domElement).click(onMouseClick);
          $(this.domElement).mousemove(onMouseMove);
        };

      }

      const initializer = new SceneInitializer();
      return initializer;
    },
  ]);

angular
  .module("designer.workspace.canvases.jointjs.3dview.modelmap", [])
  .service("ModelMap", [
    function () {
      let assetLocation;

      // Check if the icons_url is set
      // If not available serve 3D models locally
      if (window.icons_url) {
        assetLocation = `${window.icons_url}/3dmodels/`
      } else {
        assetLocation = '/assets/icons/3dmodels/'
      }
      return {
        assetLocation,
        texture: `${assetLocation}colors.png`,
        map: {
          "Resources::AWS::EC2::CustomerGateway": "customer_gateway.obj",
          "Resources::AWS::EC2::Instance": "ec2.obj",
          "Resources::AWS::EC2::InternetGateway": "internet_gatway.obj",
          "Resources::AWS::EC2::NATGateway": "nat_gateway.obj",
          "Resources::AWS::EC2::VPNGateway": "vpn_gateway.obj",
          "Resources::AWS::ElasticLoadBalancing::LoadBalancer": "elb.obj",
          "Resources::AWS::RDS::DBInstance": "rds_primary.obj",
          "Resources::AWS::S3::Bucket": "s3.obj",
          "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer":
            "elb.obj",
          "Resources::AWS::EFS::FileSystem": "efs.obj",
        },
      };
    },
  ]);

angular.module('designer.model.resources.gcp.memorystore.instance', ['designer.model.resource'])
.factory('GCP_MemoryStoreInstance', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'MEMORYSTORE';
      resource.name = resource.display_name || resource.name.split("/").slice(-1)[0];
      resource.status_list = {
        "state_unspecified": "warn",
        "creating": "warn",
        "ready": "good",
        "updating": "warn",
        "deleting": "warn",
        "repairing": "warn",
        "maintenance": "warn",
        "importing": "warn",
        "failing_over": "bad"
      };

      // TODO: we want to show redis config at some point too, but need to see how it's laid out and what info we get
      resource.info = function() {
        var info = {};

        info.network = this.getNetwork();

        return info;
      };

      resource.getExtendedInformation = function() {
        return {
          info1: this.tier,
          info2: this.redis_version,
          info3: this.host
        }
      };

      resource.getNetwork = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.sql.instance', ['designer.model.resource'])
.factory('GCP_SQLInstance', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SQL INSTANCE';
      resource.status_list = {
        "runnable": "good",
        "failed": "bad",
        "pending_create": "warn"
      };

      resource.info = function() {
        var info = {};

        info.network = this.getNetwork();

        return info;
      };

      resource.getExtendedInformation = function() {
        var ips = {};

        _.each(this.ip_addresses, function(ip) {
          ips[ip["type"]] = ip["ip_address"];
        }.bind(this));

        return {
          info1: this.settings["tier"],
          info2: ips["PRIMARY"],
          info3: ips["PRIVATE"]
        }
      };

      resource.getNetwork = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.address', ['designer.model.resource'])
  .factory('GCP_ComputeAddress', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ADDRESS';
        resource.status_list = {
          "provisioning": "warn",
          "staging": "warn",
          "running": "good",
          "stopping": "warn",
          "repairing": "warn",
          "suspending": "warn",
          "terminated": "stopped",
          "suspended": "stopped",
          "reserved": "good"
        };

        resource.info = function() {
          var info = {};

          info.network          = this.getNetwork();
          info.subnetwork       = this.getSubnetwork();
          info.instances        = this.getInstances();
          info.forwarding_rules = this.getForwardingRules();
          info.routers          = this.getRouters();
          info.nat_gateway      = this.getNATGateway();

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getNATGateway = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NATGateway")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.getForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule");
        };

        resource.getRouters = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Router");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.autoscaler', ['designer.model.resource'])
  .factory('GCP_ComputeAutoscaler', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'AUTOSCALER';
        resource.status_list = {
          "deleting": "warn",
          "pending": "warn",
          "active": "good",
          "error": "bad"
        };

        resource.info = function() {
          var info = {};

          var instance_group_manager    = this.getInstanceGroupManager();

          if(instance_group_manager)    info.instance_group_manager = instance_group_manager;

          return info;
        };

        resource.getInstanceGroupManager = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroupManager")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.backendbucket', ['designer.model.resource'])
  .factory('GCP_ComputeBackendBucket', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'BACKEND BUCKET';

        resource.info = function() {
          var info = {};

          info.bucket = this.getBucket();

          return info;
        };

        resource.getBucket = function() {
          return environment.connectedTo(this, "Resources::GCP::Storage::Bucket")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.backendservice', ['designer.model.resource'])
  .factory('GCP_ComputeBackendService', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'BACKEND SERVICE';

        resource.info = function() {
          var info = {};
          info.group_map = {};

          var instance_groups         = this.getInstanceGroups().concat(this.getRegionInstanceGroups());
          var network_endpoint_groups = this.getNetworkEndpointGroups().concat(this.getRegionNetworkEndpointGroups()).concat(this.getGlobalNetworkEndpointGroups());

          info.health_checks = this.getHealthChecks().concat(this.getRegionHealthChecks());
          info.security_policy = this.getSecurityPolicy();
          info.forwarding_rules = this.getForwardingRules().concat(this.getGlobalForwardingRules());
          info.url_map = this.getURLMap();

          _.each(instance_groups.concat(network_endpoint_groups), function(n) {
            info.group_map[n.self_link] = n;
          });

          return info;
        };

        resource.getForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule");
        };

        resource.getGlobalForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule");
        };

        resource.getInstanceGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroup");
        };

        resource.getRegionInstanceGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroup");
        };

        resource.getNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NetworkEndpointGroup");
        };

        resource.getRegionNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionNetworkEndpointGroup");
        };

        resource.getGlobalNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalNetworkEndpointGroup");
        };

        resource.getHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::HealthCheck");
        };

        resource.getRegionHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionHealthCheck");
        };

        resource.getSecurityPolicy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SecurityPolicy")[0];
        };

        resource.getURLMap = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::URLMap")[0];
        };

        resource.getConnectables = function() {
          var connectables = [];

          _.each(this.getRegionInstanceGroups().concat(this.getInstanceGroups()), function(j) {
            connectables = connectables.concat(j.getInstances());
          });

          var negs = this.getNetworkEndpointGroups().concat(this.getRegionNetworkEndpointGroups()).concat(this.getGlobalNetworkEndpointGroups());
          _.each(negs, function(neg) {
            connectables = connectables.concat(neg.getInstances());
          });

          return _.uniq(_.flatten(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.disk', ['designer.model.resource'])
  .factory('GCP_ComputeDisk', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DISK';
        resource.status_list = {
          "reserving": "warn",
          "reserved": "good",
          "in_use": "good"
        };
        
        resource.info = function() {
          var info = {};

          info.disk_type = this.getDiskType();
          info.instances = this.getInstances();
          if(this.source_snapshot) info.source_snapshot = this.source_snapshot.split("/").slice(-1)[0];
          if(this.source_image) info.source_image = this.source_image.split("/").slice(-1)[0];

          info.replica_zones = _.map(this.replica_zones, function(zone){
            return zone.split("/").slice(-1)[0];
          });

          return info;
        };

        resource.getDiskType = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::DiskType")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.disktype', ['designer.model.resource'])
  .factory('GCP_ComputeDiskType', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DISK TYPE';
        resource.status_list = {
          "active": "good",
          "deprecated": "stopped",
          "obsolete": "stopped",
          "deleted": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.disks = this.getDisks();

          return info;
        };

        resource.getDisks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Disk");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.externalvpngateway', ['designer.model.resource'])
  .factory('GCP_ComputeExternalVpnGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EXTERNAL VPN GATEWAY';

        resource.info = function() {
          var info = {};

          info.vpn_tunnels = this.getVPNTunnels();

          return info;
        };

        resource.getVPNTunnels = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNTunnel");
        };

        resource.getConnectables = function() {
          var connectables = [];

          var tunnels = this.getVPNTunnels();
          _.each(tunnels, function(tunnel) {
            connectables.push(tunnel.getTargetVPNGateway());
            connectables.push(tunnel.getVPNGateway());
            // connectables.push(tunnel.getRouter()); // TODO: do we want router to handle it's own connectables display?
          });

          return _.uniq(_.compact(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.firewall', ['designer.model.resource'])
  .factory('GCP_ComputeFirewall', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'FIREWALL';

        resource.info = function() {
          var info = {};
          var instances_map = {};
          var connections = [];
          var remote_connections = [];

          var instances   = this.getInstances();
          info.network    = this.getNetwork();

          _.each(instances, function(instance) {
            instances_map[instance.id] = instance;
          }.bind(this));

          _.each(this.connections, function(connection) { 
            var current_resource = connection.resource_id === this.id;
            var resource_id = (current_resource) ? connection.remote_resource_id : connection.resource_id;
            var connected_to = instances_map[resource_id];
            
            if(connected_to) {
              if (current_resource) {
                connections.push(connected_to);
              } else {
                remote_connections.push(connected_to);
              }
            }
          }.bind(this));

          info.connections = _.sortBy(connections, function(connection) { return connection.name; });
          info.remote_connections = _.sortBy(remote_connections, function(connection) { return connection.name; });

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };
        
        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.highlightableConnections = function() {
          return this.getInstances();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.forwardingrule', ['designer.model.resource'])
  .factory('GCP_ComputeForwardingRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'FORWARDING RULE';

        resource.info = function() {
          var info = {};

          var subnetwork      = this.getSubnetwork();
          var network         = this.getNetwork();
          var backend_service = this.getBackendService();
          var ip_address      = this.getAddress();
          var target          = this.getTarget();


          if(network)         info.network = network;
          if(subnetwork)      info.subnetwork = subnetwork;
          if(backend_service) info.backend_service = backend_service;
          if(ip_address)      info.ip_address = ip_address;
          if(target)          info.target = target;

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getBackendService = function() {
          var types = [
            "Resources::GCP::Compute::BackendService",
            "Resources::GCP::Compute::RegionBackendService"];
          return environment.findConnectedTo(this, types)[0];
        };

        resource.getAddress = function() {
          var types = [
            "Resources::GCP::Compute::Address",
            "Resources::GCP::Compute::GlobalAddress"];
          return environment.findConnectedTo(this, types)[0];
        };

        resource.getTarget = function() {
          var types = [
            "Resources::GCP::Compute::TargetHTTPProxy", 
            "Resources::GCP::Compute::TargetHTTPSProxy",
            "Resources::GCP::Compute::TargetInstance",
            "Resources::GCP::Compute::TargetPool",
            "Resources::GCP::Compute::TargetSSLProxy",
            "Resources::GCP::Compute::TargetTCPProxy",
            "Resources::GCP::Compute::TargetVPNGateway",
            "Resources::GCP::Compute::RegionTargetHTTPProxy",
            "Resources::GCP::Compute::RegionTargetHTTPSProxy"
          ];
          return environment.findConnectedTo(this, types)[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.globaladdress', ['designer.model.resource'])
  .factory('GCP_ComputeGlobalAddress', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'GLOBAL ADDRESS';
        resource.status_list = {
          "reserving": "warn",
          "reserved": "good",
          "in-use": "good"
        };
        
        resource.info = function() {
          var info = {};

          info.network          = this.getNetwork();
          info.subnetwork       = this.getSubnetwork();
          info.instances        = this.getInstances();
          info.forwarding_rules = this.getGlobalForwardingRules();
          info.routers          = this.getRouters();
          info.nat_gateway      = this.getNATGateway();

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getNATGateway = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NATGateway")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.getGlobalForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule");
        };

        resource.getRouters = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Router");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.globalforwardingrule', ['designer.model.resource'])
  .factory('GCP_ComputeGlobalForwardingRule', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'GLOBAL FORWARDING RULE';
        
        resource.info = function() {
          var info = {};

          var subnetwork = this.getSubnetwork();
          var network    = this.getNetwork();
          var backend_service = this.getBackendService();
          var ip_address      = this.getAddress();
          var target          = this.getTarget();

          if(network)         info.network = network;
          if(subnetwork)      info.subnetwork = subnetwork;
          if(backend_service) info.backend_service = backend_service;
          if(ip_address)      info.ip_address = ip_address;
          if(target)          info.target = target;

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getBackendService = function() {
          var types = [
            "Resources::GCP::Compute::BackendService",
            "Resources::GCP::Compute::RegionBackendService"];
          return environment.findConnectedTo(this, types)[0];
        };

        resource.getAddress = function() {
          var types = [
            "Resources::GCP::Compute::Address",
            "Resources::GCP::Compute::GlobalAddress"];
          return environment.findConnectedTo(this, types)[0];
        };

        resource.getTarget = function() {
          var types = [
            "Resources::GCP::Compute::TargetHTTPProxy", 
            "Resources::GCP::Compute::TargetHTTPSProxy",
            "Resources::GCP::Compute::TargetInstance",
            "Resources::GCP::Compute::TargetPool",
            "Resources::GCP::Compute::TargetSSLProxy",
            "Resources::GCP::Compute::TargetTCPProxy",
            "Resources::GCP::Compute::TargetVPNGateway"
          ];
          return environment.findConnectedTo(this, types)[0];
        };


        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.globalnetworkendpointgroup', ['designer.model.resource'])
.factory('GCP_ComputeGlobalNetworkEndpointGroup', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'GLOBAL NETWORK ENDPOINT GROUP';

      resource.info = function() {
        var info = {};
        info.instance_map = {};
        info.forwarding_rule_map = {};
        info.backend_service_map = {};
        info.health_check_map = {};

        info.network         = this.getNetwork();
        info.subnetwork      = this.getSubnetwork();
        var instances        = this.getInstances();
        var forwarding_rule = this.getForwardingRules();
        var backend_service = this.getBackendServices();
        var health_check    = this.getHealthChecks();

        _.each(instances, function(n) {
          info.instance_map[n.name] = n;
        });

        _.each(forwarding_rule, function(n) {
          info.forwarding_rule_map[n.self_link] = n;
        });

        _.each(backend_service, function(n) {
          info.backend_service_map[n.self_link] = n;
        });

        _.each(health_check, function(n) {
          info.health_check_map[n.self_link] = n;
        });

        return info;
      };

      resource.getNetwork = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
      };

      resource.getSubnetwork = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
      };

      resource.getInstances = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
      };

      resource.getForwardingRules = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule");
      };

      resource.getBackendServices = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::BackendService");
      };

      resource.getHealthChecks = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::HealthCheck");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.healthcheck', ['designer.model.resource'])
  .factory('GCP_ComputeHealthCheck', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'HEALTH CHECK';

        resource.info = function() {
          var info = {};

          info.network = this.getNetwork();
          info.backend_services = this.getBackendServices().concat(this.getRegionBackendServices());
          info.instance_group_managers = this.getInstanceGroupManagers().concat(this.getRegionInstanceGroupManagers());
          info.network_endpoint_groups = this.getNetworkEndpointGroups();
          info.target_pools = this.getTargetPools();

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getBackendServices = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendService");
        };

        resource.getRegionBackendServices = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionBackendService");
        };

        resource.getInstanceGroupManagers = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroupManager");
        };

        resource.getRegionInstanceGroupManagers = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroupManager");
        };

        resource.getNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NetworkEndpointGroup");
        };

        resource.getTargetPools = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetPool");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.healthcheckservice', ['designer.model.resource'])
.factory('GCP_ComputeHealthCheckService', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'HEALTH CHECK SERVICE';

      resource.info = function() {
        var info = {};

        return info;
      };

      // resource.getTargetHTTPSProxy = function() {
      //   return environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy")[0];
      // };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.httphealthcheck', ['designer.model.resource'])
  .factory('GCP_ComputeHttpHealthCheck', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'HTTP HEALTH CHECK';

        resource.info = function() {
          var info = {};

          info.target_pool = this.getTargetPool();

          return info;
        };

        resource.getTargetPool = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetPool")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.httpshealthcheck', ['designer.model.resource'])
  .factory('GCP_ComputeHttpsHealthCheck', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'HTTPS HEALTH CHECK';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.instance', ['designer.model.resource'])
  .factory('GCP_ComputeInstance', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'INSTANCE';
        resource.status_list = {
          "provisioning": "warn",
          "staging": "warn",
          "running": "good",
          "stopping": "warn",
          "suspending": "warn",
          "repairing": "warn",
          "terminated": "stopped"
        };

        // If the resource is stopped then display it faded out
        resource.display_faded = (resource.status.toLowerCase() === 'terminated');

        resource.info = function() {
          var info = {};
          info.network_map = {};
          info.subnetwork_map = {};
          info.disk_map = {};
          info.firewalls = _.uniq(this.getFirewalls());
          info.addresses = this.getAddresses().concat(this.getGlobalAddresses());
          info.instance_group = this.getInstanceGroup() || this.getRegionInstanceGroup();
          info.node_group = this.getNodeGroup();

          var networks    = this.getNetworks();
          var subnetworks = this.getSubnetworks();
          info.disks       = this.getDisks();

          _.each(networks, function(n) {
            info.network_map[n.self_link] = n;
          });

          _.each(subnetworks, function(n) {
            info.subnetwork_map[n.self_link] = n;
          });

          _.each(info.disks, function(n) {
            info.disk_map[n.self_link] = n;
          });

          info.machine_type = this.machine_type.split("/").slice(-1)[0];

          return info;
        };

        resource.getExtendedInformation = function() {
          var ips = _.map(resource.network_interfaces, function(r) { return r.network_ip; });

          return {
            info1: this.machine_type.split("/").slice(-1)[0],
            info2: ips[0],
            info3: ips[1]
          }
        };

        resource.getAddresses = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Address");
        };

        resource.getGlobalAddresses = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalAddress");
        };

        resource.getNetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network");
        };

        resource.getSubnetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork");
        };

        resource.getDisks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Disk");
        };

        resource.getFirewalls = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Firewall");
        };

        resource.getInstanceGroup = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroup")[0];
        };

        resource.getRegionInstanceGroup = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroup")[0];
        };

        resource.getNodeGroup = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NodeGroup")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.instancegroup', ['designer.model.resource'])
  .factory('GCP_ComputeInstanceGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'INSTANCE GROUP';

        resource.info = function() {
          var info = {};

          info.network   = this.getNetwork();
          info.subnetwork = this.getSubnetwork();
          info.manager = this.getInstanceGroupManager();
          info.instances   = this.getInstances();

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getInstanceGroupManager = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroupManager")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };
        
        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.instancegroupmanager', ['designer.model.resource'])
  .factory('GCP_ComputeInstanceGroupManager', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'INSTANCE GROUP MANAGER';
        resource.status = resource.status["is_stable"] ? "stable" : "unstable"
        resource.status_list = {
          "stable": "good",
          "unstable": "bad"
        };

        resource.info = function() {
          var info = {};
          info.health_check_map = {};

          info.instance_group = this.getInstanceGroup();
          info.target_pools   = this.getTargetPools();
          info.autoscaler     = this.getAutoscaler();
          var health_checks   = this.getHealthChecks().concat(this.getRegionHealthChecks());

          _.each(health_checks, function(n) {
            info.health_check_map[n.self_link] = n;
          });

          info.distribution_policy_zones = [];
          if(this.distribution_policy && this.distribution_policy["zones"].length) {
            _.each(this.distribution_policy["zones"], function(z) {
              var parts = z["zone"].split("/");
              info.distribution_policy_zones.push(parts[parts.length - 1]);
            });
          }
          
          return info;
        };

        resource.getInstanceGroup = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroup")[0];
        };

        resource.getAutoscaler = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Autoscaler")[0];
        };

        resource.getTargetPools = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetPool");
        };

        resource.getHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::HealthCheck");
        };

        resource.getRegionHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionHealthCheck");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.interconnect', ['designer.model.resource'])
  .factory('GCP_ComputeInterconnect', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'INTERCONNECT';
        resource.status_list = {
          "active": "good",
          "cancelled": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.interconnect_attachments = this.getInterconnectAttachments();
          info.location = (this.location||"").split("/").slice(-1)[0];

          return info;
        };

        resource.getInterconnectAttachments = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InterconnectAttachment");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.interconnectattachment', ['designer.model.resource'])
  .factory('GCP_ComputeInterconnectAttachment', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'INTERCONNECT ATTACHMENT';
        resource.status_list = {
          "active": "good",
          "unprovisioned": "stopped",
          "pending_partner": "warn",
          "partner_request_received": "warn",
          "pending_customer": "warn",
          "defunct": "stopped"
        };

        resource.info = function() {
          var info = {};

          info.router = this.getRouter();
          info.interconnect = this.getInterconnect();

          return info;
        };

        resource.getRouter = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Router")[0];
        };

        resource.getInterconnect = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Interconnect")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.natgateway', ['designer.model.resource'])
.factory('GCP_ComputeNATGateway', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'NAT GATEWAY';

      resource.zone = "";

      resource.info = function() {
        var info = {};

        info.subnetworks = this.getSubnetworks();
        info.addresses = this.getAddresses();
        info.router = this.getRouter();

        info.subnetwork_map = {};
        _.each(info.subnetworks, function(s) {
          info.subnetwork_map[s.self_link] = s;
        });

        info.address_map = {};
        _.each(info.addresses, function(a) {
          info.address_map[a.self_link] = a;
        });

        return info;
      };

      resource.getSubnetworks = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork");
      };

      resource.getRouter = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Router")[0];
      };

      resource.getAddresses = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Address");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.network', ['designer.model.resource'])
  .factory('GCP_ComputeNetwork', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NETWORK';

        resource.info = function() {
          var info = {};
          info.network_map = {};

          var networks    = this.getNetworks();
          var firewalls = this.getFirewalls();
          var routes    = this.getRoutes();

          info.subnetworks = this.getSubnetworks();
          info.mirrors = this.getPacketMirroring();
          info.firewalls = _.sortBy(firewalls, function(resource) { return resource.name; });
          info.routes    = _.sortBy(routes, function(resource) { return resource.name; });

          _.each(networks, function(n) {
            info.network_map[n.self_link] = n;
          });

          return info;
        };

        resource.getFirewalls = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Firewall");
        };

        resource.getRoutes = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Route");
        };

        resource.getNetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network");
        };

        resource.getSubnetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork");
        };

        resource.getBuckets = function() {
          return environment.connectedTo(this, "Resources::GCP::Storage::Bucket");
        };

        resource.getManagedZones = function() {
          return environment.connectedTo(this, "Resources::GCP::DNS::ManagedZone");
        };

        resource.getRouters = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Router");
        };

        resource.getVPNGateways = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNGateway");
        };

        resource.getPacketMirroring = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::PacketMirroring");
        };

        resource.getExternalVPNGateways = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ExternalVPNGateway");
        };

        resource.getTargetVPNGateways = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetVPNGateway");
        };

        resource.getInterconnects = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Interconnect");
        };

        resource.getSQLInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::SQL::Instance");
        };

        resource.getMemoryStoreInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::MemoryStore::Instance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.networkendpointgroup', ['designer.model.resource'])
  .factory('GCP_ComputeNetworkEndpointGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NETWORK ENDPOINT GROUP';

        resource.info = function() {
          var info = {};
          info.instance_map = {};
          info.forwarding_rule_map = {};
          info.backend_service_map = {};
          info.health_check_map = {};

          info.network         = this.getNetwork();
          info.subnetwork      = this.getSubnetwork();
          var instances        = this.getInstances();
          var forwarding_rule = this.getForwardingRules();
          var backend_service = this.getBackendServices();
          var health_check    = this.getHealthChecks();

          _.each(instances, function(n) {
            info.instance_map[n.name] = n;
          });

          _.each(forwarding_rule, function(n) {
            info.forwarding_rule_map[n.self_link] = n;
          });

          _.each(backend_service, function(n) {
            info.backend_service_map[n.self_link] = n;
          });

          _.each(health_check, function(n) {
            info.health_check_map[n.self_link] = n;
          });

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.getForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule");
        };

        resource.getBackendServices = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendService");
        };

        resource.getHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::HealthCheck");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.nodegroup', ['designer.model.resource'])
  .factory('GCP_ComputeNodeGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'NODE GROUP';
        resource.status_list = {
          "pending": "warn",
          "running": "good",
          "done": "stopped"
        };

        resource.info = function() {
          var info = {};
          info.instance_map = {};

          var instances      = this.getInstances();
          info.node_template = this.node_template.split("/").slice(-1)[0];

          _.each(instances, function(n) {
            info.instance_map[n.self_link] = n;
          });

          return info;
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.notificationendpoint', ['designer.model.resource'])
.factory('GCP_ComputeNotificationEndpoint', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'NOTIFICATION ENDPOINT';

      resource.info = function() {
        var info = {};

        return info;
      };

      // resource.getTargetHTTPSProxy = function() {
      //   return environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy")[0];
      // };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.packetmirroring', ['designer.model.resource'])
.factory('GCP_ComputePacketMirroring', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'PACKET MIRRORING';

      // TODO: collector and mirrored resources can be in separate networks. Even ... SHARED VPCS! Dun dun duuuunnnn
      resource.info = function() {
        var info = {};

        info.network = this.getNetwork();
        info.collector = this.getForwardingRule();
        info.mirrored = {};

        let subnets = this.getSubnetworks();
        let instances = this.getInstances();

        if(subnets.length)
          info.mirrored["Subnets"] = subnets;

        if(instances.length) {
          const direct_instance_ids = _.map(this.mirrored_resources["instances"] || [],  (i) => i["url"]);
          let direct_instances = [];
          let tag_instances = [];

          _.each(instances, function(i) {
            if(direct_instance_ids.includes(i.self_link)) {
              direct_instances.push(i);
            }
            else {
              tag_instances.push(i);
            }
          });

          if(direct_instances.length) info.mirrored["Instances"] = direct_instances;
          if(tag_instances.length) info.mirrored["Tags"] = tag_instances;
        }

        return info;
      };

      resource.getNetwork = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
      };

      resource.getSubnetworks = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork");
      };

      resource.getInstances = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
      };

      resource.getForwardingRule = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
          environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.regionautoscaler', ['designer.model.resource'])
  .factory('GCP_ComputeRegionAutoscaler', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION AUTOSCALER';
        resource.status_list = {
          "pending": "warn",
          "deleting": "warn",
          "active": "good",
          "error": "bad"
        };

        resource.info = function() {
          var info = {};

          info.instance_group_manager = this.getInstanceGroupManager();

          return info;
        };

        resource.getInstanceGroupManager = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroupManager")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regionbackendservice', ['designer.model.resource'])
  .factory('GCP_ComputeRegionBackendService', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION BACKEND SERVICE';

        resource.info = function() {
          var info = {};
          info.group_map = {};

          var instance_groups         = this.getRegionInstanceGroups().concat(this.getInstanceGroups());
          var network_endpoint_groups = this.getNetworkEndpointGroups().concat(this.getRegionNetworkEndpointGroups()).concat(this.getGlobalNetworkEndpointGroups());

          info.health_checks    = this.getHealthChecks().concat(this.getRegionHealthChecks());
          info.ssl_policy       = this.getSSLPolicy();
          info.forwarding_rules = this.getForwardingRules().concat(this.getGlobalForwardingRules());
          info.url_map          = this.getURLMap();

          _.each(instance_groups.concat(network_endpoint_groups), function(n) {
            info.group_map[n.self_link] = n;
          });

          return info;
        };

        resource.getForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule");
        };

        resource.getGlobalForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule");
        };

        resource.getRegionInstanceGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroup");
        };

        resource.getInstanceGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroup");
        };

        resource.getNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NetworkEndpointGroup");
        };

        resource.getRegionNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionNetworkEndpointGroup");
        };

        resource.getGlobalNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalNetworkEndpointGroup");
        };

        resource.getHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::HealthCheck");
        };

        resource.getRegionHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionHealthCheck");
        };

         resource.getSSLPolicy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SSLPolicy")[0];
        };

        resource.getURLMap = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionURLMap")[0];
        };

        resource.getConnectables = function() {
          var connectables = [];

          _.each(this.getRegionInstanceGroups().concat(this.getInstanceGroups()), function(j) {
            connectables = connectables.concat(j.getInstances());
          });

          var negs = this.getNetworkEndpointGroups().concat(this.getRegionNetworkEndpointGroups()).concat(this.getGlobalNetworkEndpointGroups());
          _.each(negs, function(neg) {
            connectables = connectables.concat(neg.getInstances());
          });

          return _.uniq(_.flatten(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regiondisk', ['designer.model.resource'])
  .factory('GCP_ComputeRegionDisk', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION DISK';
        resource.status_list = {
          "ready": "good",
          "creating": "warn",
          "restoring": "warn",
          "failed": "bad",
          "deleting": "warn"
        };

        resource.info = function() {
          var info = {};

          info.disk_type = this.getDiskType();
          info.instances = this.getInstances();
          if(this.source_snapshot) info.source_snapshot = this.source_snapshot.split("/").slice(-1)[0];
          if(this.source_image) info.source_image = this.source_image.split("/").slice(-1)[0];

          info.replica_zones = _.map(this.replica_zones, function(zone){
            return zone.split("/").slice(-1)[0];
          });

          return info;
        };

        resource.getDiskType = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::DiskType")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regiondisktype', ['designer.model.resource'])
  .factory('GCP_ComputeRegionDiskType', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION DISK TYPE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regionhealthcheck', ['designer.model.resource'])
  .factory('GCP_ComputeRegionHealthCheck', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION HEALTH CHECK';

        resource.info = function() {
          var info = {};

          info.network = this.getNetwork();
          info.backend_services = this.getBackendServices().concat(this.getRegionBackendServices());
          info.instance_group_managers = this.getInstanceGroupManagers().concat(this.getRegionInstanceGroupManagers());
          info.network_endpoint_groups = this.getNetworkEndpointGroups();
          info.target_pools = this.getTargetPools();

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getBackendServices = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendService");
        };

        resource.getRegionBackendServices = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionBackendService");
        };

        resource.getInstanceGroupManagers = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroupManager");
        };

        resource.getRegionInstanceGroupManagers = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroupManager");
        };

        resource.getNetworkEndpointGroups = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NetworkEndpointGroup");
        };

        resource.getTargetPools = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetPool");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regioninstancegroup', ['designer.model.resource'])
  .factory('GCP_ComputeRegionInstanceGroup', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION INSTANCE GROUP';

        resource.info = function() {
          var info = {};

          info.network   = this.getNetwork();
          info.subnetwork = this.getSubnetwork();
          info.manager = this.getInstanceGroupManager();
          info.instances   = this.getInstances();
       
          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getSubnetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork")[0];
        };

        resource.getInstanceGroupManager = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroupManager")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regioninstancegroupmanager', ['designer.model.resource'])
  .factory('GCP_ComputeRegionInstanceGroupManager', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION INSTANCE GROUP MANAGER';
        resource.status = resource.status["is_stable"] ? "stable" : "unstable"
        resource.status_list = {
          "stable": "good",
          "unstable": "bad"
        };

        resource.info = function() {
          var info = {};
          info.health_check_map = {};

          info.instance_group = this.getInstanceGroup();
          info.target_pools   = this.getTargetPools();
          info.autoscaler     = this.getAutoscaler();
          var health_checks   = this.getHealthChecks().concat(this.getRegionHealthChecks());

          _.each(health_checks, function(n) {
            info.health_check_map[n.self_link] = n;
          });

          info.distribution_policy_zones = [];
          if(this.distribution_policy && this.distribution_policy["zones"].length) {
            _.each(this.distribution_policy["zones"], function(z) {
              var parts = z["zone"].split("/");
              info.distribution_policy_zones.push(parts[parts.length - 1]);
            });
          }
          
          return info;
        };

        resource.getInstanceGroup = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroup")[0];
        };

        resource.getAutoscaler = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionAutoscaler")[0];
        };

        resource.getTargetPools = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetPool");
        };

        resource.getHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::HealthCheck");
        };

        resource.getRegionHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionHealthCheck");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regionnetworkendpointgroup', ['designer.model.resource'])
.factory('GCP_ComputeRegionNetworkEndpointGroup', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'REGION NETWORK ENDPOINT GROUP';

      resource.info = function() {
        var info = {};

        info.backend_service = this.getBackendService();

        return info;
      };

      resource.getBackendService = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::BackendService")[0];
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.regionsslcertificate', ['designer.model.resource'])
  .factory('GCP_ComputeRegionSslCertificate', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION SSL CERTIFICATE';

        resource.info = function() {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regiontargethttpproxy', ['designer.model.resource'])
  .factory('GCP_ComputeRegionTargetHttpProxy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION TARGET HTTP PROXY';

        resource.info = function() {
          var info = {};

          info.url_map         = this.getRegionURLMap();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getRegionURLMap = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionURLMap")[0];
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regiontargethttpsproxy', ['designer.model.resource'])
  .factory('GCP_ComputeRegionTargetHttpsProxy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION TARGET HTTPS PROXY';

        resource.info = function() {
          var info = {};

          info.url_map = this.getURLMap();
          info.ssl_certificate = this.getSSLCertificate();
          info.ssl_policy = this.getSSLPolicy();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getURLMap = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::URLMap")[0];
        };

        resource.getSSLCertificate = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionSSLCertificate")[0];
        };

        resource.getSSLPolicy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SSLPolicy")[0];
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.regionurlmap', ['designer.model.resource'])
  .factory('GCP_ComputeRegionUrlMap', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'REGION URL MAP';

        resource.info = function() {
          var info = {};
          info.service_map = {};

          info.backend_bucket = this.getBackendBucket();
          info.backend_service = this.getBackendService();
          info.frontends = this.getFrontendConnections();

          if(info.backend_bucket) info.service_map[info.backend_bucket.self_link] = info.backend_bucket;
          if(info.backend_service) info.service_map[info.backend_service.self_link] = info.backend_service;

          return info;
        };

        resource.getBackendBucket = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendBucket")[0];
        };

        resource.getBackendService = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionBackendService")[0];
        };

        resource.getFrontendConnections = function() {
          var proxies = environment.connectedTo(this, "Resources::GCP::Compute::RegionTargetHTTPProxy").concat(
            environment.connectedTo(this, "Resources::GCP::Compute::RegionTargetHTTPSProxy")
          );

          _.each(proxies, function(proxy) {
            proxy.protocol = (proxy.type === "Resources::GCP::Compute::RegionTargetHTTPProxy") ? "HTTP" : "HTTPS";
            proxy.forwarding_rule = proxy.getForwardingRule();
          });

          return proxies;
        };

        resource.getConnectables = function() {
          var connectables = [];
          var backend_bucket = this.getBackendBucket();
          var backend_service = this.getBackendService();

          if (backend_bucket) {
            connectables.push(backend_bucket.getBucket());
          }

          if (backend_service) {
            _.each(backend_service.getRegionInstanceGroups(), function(j) {
              connectables = connectables.concat(j.getInstances());
            })
          }

          return _.uniq(_.flatten(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.route', ['designer.model.resource'])
  .factory('GCP_ComputeRoute', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTE';

        resource.info = function() {
          var info = {};
          info.network_map = {};
          info.instance_map = {};

          info.networks   = this.getNetworks();
          info.instances  = this.getInstances();
          info.subnets    = this.getSubnets();
          info.vpn_tunnel = this.getVPNTunnel();

          _.each(info.networks, function(n) {
            info.network_map[n.self_link] = n;
          });

          _.each(info.instances, function(n) {
            info.instance_map[n.self_link] = n;
          });

          if(this.next_hop_gateway) info.next_hop_gateway = this.next_hop_gateway.split("/").slice(-1)[0];
          if(this.next_hop_peering) info.next_hop_peering = this.next_hop_peering.split("/").slice(-1)[0];
          if(this.next_hop_ip) info.next_hop_ip      = this.next_hop_ip.split("/").slice(-1)[0];

          return info;
        };

        resource.getNetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network");
        };

        resource.getSubnets = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork");
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.getVPNTunnel = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNTunnel")[0];
        };

        resource.highlightableConnections = function() {
          return this.getInstances().concat(this.getSubnets());
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.router', ['designer.model.resource'])
  .factory('GCP_ComputeRouter', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'ROUTER';

        resource.info = function() {
          var info = {};
          info.network = this.getNetwork();
          info.nat_gateways = this.getNATGateways();
          info.addresses = this.getAddresses().concat(this.getGlobalAddresses());
          info.subnetwork_map = {};
          info.vpn_tunnel_map = {};
          info.interconnect_attachment_map = {};

          var subnetworks = this.getSubnetworks();
          var vpn_tunnels = this.getVPNTunnels();
          var interconnect_attachments = this.getInterconnectAttachments();

          _.each(subnetworks, function(n) {
            info.subnetwork_map[n.self_link] = n;
          });

          _.each(vpn_tunnels, function(n) {
            info.vpn_tunnel_map[n.self_link] = n;
          });

          _.each(interconnect_attachments, function(n) {
            info.interconnect_attachment_map[n.self_link] = n;
          });

          return info;
        };

        resource.getAddresses = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Address");
        };

        resource.getGlobalAddresses = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::GlobalAddress");
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getSubnetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Subnetwork");
        };

        resource.getNATGateways = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NATGateway");
        };

        resource.getVPNTunnels = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNTunnel");
        };

        resource.getInterconnectAttachments = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::InterconnectAttachment");
        };

        resource.getConnectables = function() {
          let connectables = [];

          connectables = connectables.concat(this.getNATGateways());
          _.each(this.getInterconnectAttachments(), function(a) {
            const interconnect = a.getInterconnect();
            if(interconnect)
              connectables.push(interconnect);
          });

          return connectables;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.securitypolicy', ['designer.model.resource'])
.factory('GCP_ComputeSecurityPolicy', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SECURITY POLICY';

      resource.info = function() {
        var info = {};

        info.backends = this.getBackendServices();

        return info;
      };

      resource.getBackendServices = function() {
        return environment.connectedTo(this, "Resources::GCP::Compute::BackendService");
      };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.serviceattachment', ['designer.model.resource'])
.factory('GCP_ComputeServiceAttachment', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'SERVICE ATTACHMENT';

      resource.info = function() {
        var info = {};

        return info;
      };

      // resource.getTargetHTTPSProxy = function() {
      //   return environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy")[0];
      // };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.sslcertificate', ['designer.model.resource'])
  .factory('GCP_ComputeSslCertificate', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SSL CERTIFICATE';

        resource.info = function() {
          var info = {};

          info.target_https_proxy = this.getTargetHTTPSProxy();
          info.target_ssl_proxy = this.getTargetSSLProxy();

          return info;
        };

        resource.getTargetHTTPSProxy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy")[0];
        };

        resource.getTargetSSLProxy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetSSLProxy")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.sslpolicy', ['designer.model.resource'])
  .factory('GCP_ComputeSslPolicy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SSL POLICY';

        resource.info = function() {
          var info = {};

          info.target_https_proxies = this.getRegionTargetHTTPSProxies().concat(this.getTargetHTTPSProxies());
          info.target_ssl_proxies = this.getTargetSSLProxies();

          return info;
        };

        resource.getRegionTargetHTTPSProxies = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::RegionTargetHTTPSProxy");
        };

        resource.getTargetHTTPSProxies = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy");
        };

        resource.getTargetSSLProxies = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetSSLProxy");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.subnetwork', ['designer.model.resource'])
  .factory('GCP_ComputeSubnetwork', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'SUBNETWORK';

        resource.info = function() {
          var info = {};

          info.network = this.getNetwork();

          return info;
        };

        resource.getNetwork = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.getNATGateways = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::NATGateway");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targetgrpcproxy', ['designer.model.resource'])
.factory('GCP_ComputeTargetGrpcProxy', ["Resource", function(Resource) {
  return {
    load: function(resource, environment) {
      resource = Resource.load(resource, environment);
      resource.type_name = 'TARGET GRPC PROXY';

      resource.info = function() {
        var info = {};

        return info;
      };

      // resource.getTargetHTTPSProxy = function() {
      //   return environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy")[0];
      // };

      return resource;
    }
  }
}]);

angular.module('designer.model.resources.gcp.compute.targethttpproxy', ['designer.model.resource'])
  .factory('GCP_ComputeTargetHttpProxy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET HTTP PROXY';

        resource.info = function() {
          var info = {};

          info.url_map = this.getURLMap();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getURLMap = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::URLMap")[0];
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targethttpsproxy', ['designer.model.resource'])
  .factory('GCP_ComputeTargetHttpsProxy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET HTTPS PROXY';

        resource.info = function() {
          var info = {};

          info.url_map = this.getURLMap();
          info.ssl_certificate = this.getSSLCertificate();
          info.ssl_policy = this.getSSLPolicy();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getURLMap = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::URLMap")[0];
        };

        resource.getSSLCertificate = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SSLCertificate")[0];
        };

        resource.getSSLPolicy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SSLPolicy")[0];
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targetinstance', ['designer.model.resource'])
  .factory('GCP_ComputeTargetInstance', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET INSTANCE';

        resource.info = function() {
          var info = {};

          info.instance = this.getInstance();
          info.forwarding_rules = this.getForwardingRules();

          return info;
        };

        resource.getInstance = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance")[0];
        };

        resource.getForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule").concat(
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule"));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targetpool', ['designer.model.resource'])
  .factory('GCP_ComputeTargetPool', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET POOL';

        resource.info = function() {
          var info = {};

          info.target_pool = this.getTargetPool();
          info.instances = this.getInstances();
          info.health_checks = this.getHealthChecks();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getTargetPool = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetPool")[0];
        };

        resource.getInstances = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Instance");
        };

        resource.getHealthChecks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::HTTPHealthCheck");
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        resource.getInstanceGroups = function() {
          const managers = environment.connectedTo(this, "Resources::GCP::Compute::InstanceGroupManager").concat(
            environment.connectedTo(this, "Resources::GCP::Compute::RegionInstanceGroupManager")
          );

          return _.map(managers, (m) => m.getInstanceGroup());
        };

        resource.getConnectables = function() {
          return this.getInstances();
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targetsslproxy', ['designer.model.resource'])
  .factory('GCP_ComputeTargetSslProxy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};

          info.backend_service = this.getBackendService();
          info.ssl_certificate = this.getSSLCertificate();
          info.ssl_policy = this.getSSLPolicy();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getBackendService = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendService")[0];
        };

        resource.getSSLCertificate = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SSLCertificate")[0];
        };

        resource.getSSLPolicy = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::SSLPolicy")[0];
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targettcpproxy', ['designer.model.resource'])
  .factory('GCP_ComputeTargetTcpProxy', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET TCP PROXY';

        resource.info = function() {
          var info = {};

          info.backend_service = this.getBackendService();
          info.forwarding_rule = this.getForwardingRule();

          return info;
        };

        resource.getBackendService = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendService")[0];
        };

        resource.getForwardingRule = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule")[0] ||
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.targetvpngateway', ['designer.model.resource'])
  .factory('GCP_ComputeTargetVpnGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'TARGET VPN GATEWAY';
        resource.status_list = {
          "creating": "warn",
          "ready": "good",
          "deleting": "warn",
          "failed": "bad"
        };
        
        resource.info = function() {
          var info = {};

          info.forwarding_rules = this.getForwardingRules();
          info.vpn_tunnels = this.getVPNTunnels();

          return info;
        };

        resource.getVPNTunnels = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNTunnel");
        };

        resource.getForwardingRules = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ForwardingRule").concat(
            environment.connectedTo(this, "Resources::GCP::Compute::GlobalForwardingRule"));
        };

        resource.getConnectables = function() {
          var connectables = [];

          var tunnels = this.getVPNTunnels();
          _.each(tunnels, function(tunnel) {
            connectables.push(tunnel.getVPNGateway());
            connectables.push(tunnel.getExternalVPNGateway());
          });

          return _.uniq(_.compact(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.urlmap', ['designer.model.resource'])
  .factory('GCP_ComputeUrlMap', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'URL MAP';

        resource.info = function() {
          var info = {};
          info.service_map = {};

          info.backend_bucket = this.getBackendBucket();
          info.backend_service = this.getBackendService();
          info.frontends = this.getFrontendConnections();

          if(info.backend_bucket) info.service_map[info.backend_bucket.self_link] = info.backend_bucket;
          if(info.backend_service) info.service_map[info.backend_service.self_link] = info.backend_service;

          return info;
        };

        resource.getBackendBucket = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendBucket")[0];
        };

        resource.getBackendService = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendService")[0];
        };

        resource.getFrontendConnections = function() {
          var proxies = environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPProxy").concat(
            environment.connectedTo(this, "Resources::GCP::Compute::TargetHTTPSProxy")
          );

          _.each(proxies, function(proxy) {
            proxy.protocol = (proxy.type === "Resources::GCP::Compute::TargetHTTPProxy") ? "HTTP" : "HTTPS";
            proxy.forwarding_rule = proxy.getForwardingRule();
          });

          return proxies;
        };

        resource.getConnectables = function() {
          var connectables = [];
          var backend_bucket = this.getBackendBucket();
          var backend_service = this.getBackendService();

          if (backend_bucket) {
            connectables.push(backend_bucket.getBucket());
          }

          if (backend_service) {
            _.each(backend_service.getInstanceGroups(), function(j) {
              connectables = connectables.concat(j.getInstances());
            })
          }

          return _.uniq(_.flatten(connectables));
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.vpngateway', ['designer.model.resource'])
  .factory('GCP_ComputeVpnGateway', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPN GATEWAY';
        
        resource.info = function() {
          var info = {};

          info.vpn_tunnel = this.getVPNTunnel();

          return info;
        };

        resource.getVPNTunnel = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNTunnel")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.compute.vpntunnel', ['designer.model.resource'])
  .factory('GCP_ComputeVpnTunnel', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'VPN TUNNEL';
        resource.status_list = {
          "provisioning": "warn",
          "waiting_for_full_config": "warn",
          "first_handshake": "warn",
          "established": "good",
          "network_error": "bad",
          "authorization_error": "bad",
          "negotiation_failure": "bad",
          "deprovisioning": "warn",
          "failed": "bad",
          "no_incoming_packets": "warn",
          "rejected": "bad",
          "allocating_resources": "warn",
          "stopped": "stopped",
          "peer_identity_mismatch": "bad",
          "ts_narrowing_not_allowed": "warn"
        };

        resource.info = function() {
          var info = {};

          info.target_vpn_gateway = this.getTargetVPNGateway();
          info.vpn_gateway = this.getVPNGateway(); // TODO: technically there can be two - one is tied to peerGcpGateway, but we don't have any examples
          info.peer_external_gateway = this.getExternalVPNGateway();
          info.router = this.getRouter();

          return info;
        };

        resource.getTargetVPNGateway = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::TargetVPNGateway")[0];
        };

        resource.getVPNGateway = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::VPNGateway")[0];
        };

        resource.getExternalVPNGateway = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::ExternalVPNGateway")[0];
        };

        resource.getRouter = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Router")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.storage.bucket', ['designer.model.resource'])
  .factory('GCP_StorageBucket', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'BUCKET';

        resource.info = function() {
          var info = {};

          info.backend_bucket = this.getBackendBucket();

          return info;
        };

        resource.getBackendBucket = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::BackendBucket");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.security.arrow.azure', ['designer.model.resource'])
  .factory('AureSecurityArrow', ["Resource", function(Resource) {
    return {
      load: function(resource) {
        resource.type_name = 'SECURITY';
        resource.name = "Arrow";
        resource.type = "Resources::Security::Arrow::Azure";

        resource = Resource.load(resource);

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.security.arrow.horizontal', ['designer.model.resource'])
  .factory('HorizontalSecurityArrow', ["Resource", function(Resource) {
    return {
      load: function(resource) {
        resource.type_name = 'SECURITY';
        resource.name = "Arrow";
        resource.type = "Resources::Security::Arrow::Horizontal";

        resource = Resource.load(resource);

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.gcp.dns.managedzone', ['designer.model.resource'])
  .factory('GCP_DNSManagedZone', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'DNS MANAGED ZONE';

        resource.info = function() {
          var info = {};

          info.networks = this.getNetworks();

          return info;
        };

        resource.getNetworks = function() {
          return environment.connectedTo(this, "Resources::GCP::Compute::Network");
        };

        return resource;
      }
    }
  }]);

joint.routers.havaBasic = function() {

  var sourceBBox, targetBBox;

  // p1 = source, p2 = dest
  function direction(p1, p2) {
    if(p1.x > p2.x) {
      return "left";
    }

    return "right"
  }

  function bestDirection(p1, p2, preferredDirection) {

    var directions;

    // This branching determines possible directions that one can take to travel
    // from `p1` to `p2`.
    if (p1.x < p2.x) {

      if (p1.y > p2.y) { directions = ['up', 'right']; }
      else if (p1.y < p2.y) { directions = ['down', 'right']; }
      else { directions = ['right']; }

    } else if (p1.x > p2.x) {

      if (p1.y > p2.y) { directions = ['up', 'left']; }
      else if (p1.y < p2.y) { directions = ['down', 'left']; }
      else { directions = ['left']; }

    } else {

      if (p1.y > p2.y) { directions = ['up']; }
      else { directions = ['down']; }
    }

    if (_.includes(directions, preferredDirection)) {
      return preferredDirection;
    }

    var direction = _.first(directions);

    // Should the direction be the exact opposite of the preferred direction,
    // try another one if such direction exists.
    switch (preferredDirection) {
      case 'down': if (direction === 'up') return _.last(directions); break;
      case 'up': if (direction === 'down') return _.last(directions); break;
      case 'left': if (direction === 'right') return _.last(directions); break;
      case 'right': if (direction === 'left') return _.last(directions); break;
    }
    return direction;
  };

  // Find a vertex in between the vertices `p1` and `p2` so that the route between those vertices
  // is orthogonal. Prefer going the direction determined by `preferredDirection`.
  function findMiddleVertex(p1, p2, preferredDirection) {

    var direction = bestDirection(p1, p2, preferredDirection);
    if (direction === 'down' || direction === 'up') {
      return { x: p1.x, y: p2.y, d: direction };
    }
    return { x: p2.x, y: p1.y, d: direction };
  }

  // TODO: so this does the logic - can we add some logic to get it to kind of skip around other resources?
  function findRoute(vertices) {

    vertices = (vertices || []).slice();
    var orthogonalVertices = [];

    var sourceCenter = sourceBBox.center();
    var targetCenter = targetBBox.center();

    if (!vertices.length) {

      if (Math.abs(sourceCenter.x - targetCenter.x) < (sourceBBox.width / 2) ||
        Math.abs(sourceCenter.y - targetCenter.y) < (sourceBBox.height / 2)
      ) {

        vertices = [{
          x: Math.min(sourceCenter.x, targetCenter.x) +
          Math.abs(sourceCenter.x - targetCenter.x) / 2,
          y: Math.min(sourceCenter.y, targetCenter.y) +
          Math.abs(sourceCenter.y - targetCenter.y) / 2
        }];
      }
    }

    vertices.unshift(sourceCenter);
    vertices.push(targetCenter);

    var orthogonalVertex;
    var lastOrthogonalVertex;
    var vertex;
    var nextVertex;

    // For all the pairs of link model vertices...
    for (var i = 0; i < vertices.length - 1; i++) {

      vertex = vertices[i];
      nextVertex = vertices[i + 1];
      lastOrthogonalVertex = _.last(orthogonalVertices);

      if (i > 0) {
        // Push all the link vertices to the orthogonal route.
        orthogonalVertex = vertex;
        // Determine a direction between the last vertex and the new one.
        // Therefore, each vertex contains the `d` property describing the direction that one
        // would have to take to travel to that vertex.
        orthogonalVertex.d = lastOrthogonalVertex
          ? direction(lastOrthogonalVertex, vertex)
          : 'top';

        orthogonalVertices.push(orthogonalVertex);
        lastOrthogonalVertex = orthogonalVertex;
      }

      // Make sure that we don't create a vertex that would go the opposite direction then
      // that of the previous one.
      // Othwerwise, a 'spike' segment would be created which is not desirable.
      // Find a dummy vertex to keep the link orthogonal. Preferably, take the same direction
      // as the previous one.
      var d = lastOrthogonalVertex && lastOrthogonalVertex.d;
      orthogonalVertex = findMiddleVertex(vertex, nextVertex, d);

      // Do not add a new vertex that is the same as one of the vertices already added.
      if (!g.point(orthogonalVertex).equals(g.point(vertex)) &&
        !g.point(orthogonalVertex).equals(g.point(nextVertex))) {

        orthogonalVertices.push(orthogonalVertex);
      }
    }
    return orthogonalVertices;
  };

  return function(vertices) {

    sourceBBox = this.sourceBBox;
    targetBBox = this.targetBBox;

    // TODO: so this returns a list of vertices for the current resource ... shite
    return findRoute(vertices);
  };

}();

// TODO: can we extend manhatten and just work with the basics there?
joint.routers.hava = (function() {
    'use strict';

    var config = {
        step: 10,
        perpendicular: true,
        mapGridSize: 100,
        excludeEnds: [], // 'source', 'target'
        excludeTypes: ['basic.Text'],
        maximumLoops: 500,
        startDirections: ['left','right'],
        endDirections: ['left','right'],
        directionMap: {
            right: { x: 1, y: 0 },
            bottom: { x: 0, y: 1 },
            left: { x: -1, y: 0 },
            top: { x: 0, y: -1 }
        },
        maxAllowedDirectionChange: 1,

        paddingBox: function() {
            var step = this.step;

            return {
                x: -step,
                y: -step,
                width: 2*step,
                height: 2*step
            }
        },

        directions: function() {
            var step = this.step;

            return [
                { offsetX: step  , offsetY: 0     , cost: step },
                { offsetX: 0     , offsetY: step  , cost: step },
                { offsetX: -step , offsetY: 0     , cost: step },
                { offsetX: 0     , offsetY: -step , cost: step }
            ];
        },

        penalties: function() {
            return [0, this.step / 2, this.step];
        },

        estimateCost: function(from, to) {
            return from.manhattanDistance(to);
        },

        // a simple route used in situations, when main routing method fails
        // (exceed loops, inaccessible).
        fallbackRoute: function(from, to, opts) {
            // Find an orthogonal route ignoring obstacles.
            var prevDirIndexes = opts.prevDirIndexes || {};
            var point = (prevDirIndexes[from] || 0) % 2
                    ? g.point(from.x, to.y)
                    : g.point(to.x, from.y);

            return [point, to];
        },

        // if a function is provided, it's used to route the link while dragging an end
        // i.e. function(from, to, opts) { return []; }
        draggingRoute: null
    };

    // reconstructs a route by concating points with their parents
    function reconstructRoute(parents, point) {
        var route = [];
        var prevDiff = { x: 0, y: 0 };
        var current = point;
        var parent;

        while ((parent = parents[current])) {
            var diff = parent.difference(current);

            if (!diff.equals(prevDiff)) {
                route.unshift(current);
                prevDiff = diff;
            }

            current = parent;
        }

        route.unshift(current);

        return route;
    };

    // find points around the rectangle taking given directions in the account
    function getRectPoints(bbox, directionList, opts) {
        var step = opts.step;
        var center = bbox.center();
        var startPoints = _.map(opts.directionMap, function(direction) {

            var x = direction.x * bbox.width / 2;
            var y = direction.y * bbox.height / 2;

            var point = g.point(center).offset(x,y).snapToGrid(step);

            if (bbox.containsPoint(point)) {

                point.offset(direction.x * step, direction.y * step);
            }

            return point;

        });

        return startPoints;
    };

    // returns a direction index from start point to end point
    function getDirection(start, end, dirLen) {
        var dirAngle = 360 / dirLen;
        var q = Math.floor(start.theta(end) / dirAngle);

        return dirLen - q;
    }

    // finds the route between to points/rectangles implementing A* alghoritm
    // TODO: here is where we find out route, do shit here, yeeeah!
    function findRoute(start, end, map, opt) {
        var startDirections = opt.reversed ? opt.endDirections : opt.startDirections;
        var endDirections = opt.reversed ? opt.startDirections : opt.endDirections;

        // set of points we start pathfinding from
        var startSet = start instanceof g.rect
                ? getRectPoints(start, startDirections, opt)
                : [start];

        // set of points we want the pathfinding to finish at
        var endSet = end instanceof g.rect
                ? getRectPoints(end, endDirections, opt)
                : [end];

        var startCenter = startSet.length > 1 ? start.center() : startSet[0];
        var endCenter = endSet.length > 1 ? end.center() : endSet[0];

        // take into account  only accessible end points
        var endPoints = _.filter(endSet, function(point) {

            var mapKey = g.point(point).snapToGrid(opt.mapGridSize).toString();

            var accesible = _.every(map[mapKey], function(obstacle) {
                return !obstacle.containsPoint(point);
            });

            return accesible;
        });

        if (endPoints.length) {
            var step = opt.step;
            var penalties = opt.penalties;

            // choose the end point with the shortest estimated path cost
            // TODO: shit fuck
            // endPoints = _.map(endPoints, function(p) { return this.snapToGrid(p) }.bind(this));
            var endPoint = _.min(endPoints, function(point) {

                return opt.estimateCost(startCenter, point);

            });

            var parents = {};
            var costFromStart = {};
            var totalCost = {};

            // directions
            var dirs = opt.directions;
            var dirLen = dirs.length;
            var dirHalfLen = dirLen / 2;
            var dirIndexes = opt.previousDirIndexes || {};

            // The set of point already evaluated.
            var closeHash = {}; // keeps only information whether a point was evaluated'

            // The set of tentative points to be evaluated, initially containing the start points
            var openHash = {}; // keeps only information whether a point is to be evaluated'
            var openSet = _.each(startSet, function(point) {
                // TODO: fucking snap to grid! I guess it needs to be called on a point shit fuck shit
                // var key = this.snapToGrid(p).toString();
                var key = point.toString();

                costFromStart[key] = 0; // Cost from start along best known path.
                totalCost[key] = opt.estimateCost(point, endPoint);
                dirIndexes[key] = dirIndexes[key] || getDirection(startCenter, point, dirLen);
                openHash[key] = true;

                return totalCost[point.toString()];
            });

            var loopCounter = opt.maximumLoops;
            var maxAllowedDirectionChange = opt.maxAllowedDirectionChange;

            // main route finding loop
            while (openSet.length && loopCounter--) {

                var currentKey = openSet[0];
                var currentPoint = g.point(currentKey);

                if (endPoint.equals(currentPoint)) {

                    opt.previousDirIndexes = _.pick(dirIndexes, currentKey);
                    return reconstructRoute(parents, currentPoint);
                }

                // remove current from the open list
                openSet.splice(0, 1);
                openHash[neighborKey] = null;

                // add current to the close list
                closeHash[neighborKey] = true;

                var currentDirIndex = dirIndexes[currentKey];
                var currentDist = costFromStart[currentKey];

                for (var dirIndex = 0; dirIndex < dirLen; dirIndex++) {

                    var dirChange = Math.abs(dirIndex - currentDirIndex);

                    if (dirChange > dirHalfLen) {

                        dirChange = dirLen - dirChange;
                    }

                    // if the direction changed rapidly don't use this point
                    if (dirChange > maxAllowedDirectionChange) {

                        continue;
                    }

                    var dir = dirs[dirIndex];

                    var neighborPoint = g.point(currentPoint).offset(dir.offsetX, dir.offsetY);
                    var neighborKey = neighborPoint.toString();

                    if (closeHash[neighborKey]) {

                        continue;
                    }

                    // is point accesible - no obstacle in the way

                    var mapKey = g.point(neighborPoint).snapToGrid(opt.mapGridSize).toString();

                    var isAccesible = _.every(map[mapKey], function(obstacle) {
                        return !obstacle.containsPoint(neighborPoint);
                    });

                    if (!isAccesible) {

                        continue;
                    }

                    var inOpenSet = _.has(openHash, neighborKey);

                    var costToNeighbor = currentDist + dir.cost;

                    if (!inOpenSet || costToNeighbor < costFromStart[neighborKey]) {

                        parents[neighborKey] = currentPoint;
                        dirIndexes[neighborKey] = dirIndex;
                        costFromStart[neighborKey] = costToNeighbor;

                        totalCost[neighborKey] = costToNeighbor +
                            opt.estimateCost(neighborPoint, endPoint) +
                            penalties[dirChange];

                        if (!inOpenSet) {

                            var openIndex = _.sortedIndex(openSet, neighborKey, function(openKey) {

                                return totalCost[openKey];
                            });

                            openSet.splice(openIndex, 0, neighborKey);
                            openHash[neighborKey] = true;
                        }
                    };
                };
            }
        }

        // no route found ('to' point wasn't either accessible or finding route took
        // way to much calculations)
        return opt.fallbackRoute(startCenter, endCenter, opt);
    };

    // initiation of the route finding
    function router(oldVertices, opt) {

        // resolve some of the options
        opt.directions = _.result(opt, 'directions');
        opt.penalties = _.result(opt, 'penalties');
        opt.paddingBox = _.result(opt, 'paddingBox');

        // enable/disable linkView perpendicular option
        this.options.perpendicular = !!opt.perpendicular;

        // As route changes its shape rapidly when we start finding route from different point
        // it's necessary to start from the element that was not interacted with
        // (the position was changed) at very last.
        var reverseRouting = opt.reversed = (this.lastEndChange === 'source');

        var sourceBBox = reverseRouting ? g.rect(this.targetBBox) : g.rect(this.sourceBBox);
        var targetBBox = reverseRouting ? g.rect(this.sourceBBox) : g.rect(this.targetBBox);

        // expand boxes by specific padding
        sourceBBox.moveAndExpand(opt.paddingBox);
        targetBBox.moveAndExpand(opt.paddingBox);

        // building an elements map

        var link = this.model;
        var graph = this.paper.model;

        // source or target element could be excluded from set of obstacles
        var excludedEnds = _.map(opt.excludeEnds, function(end) {
          return graph.getCell(link.get(end)["id"]);
        });

        var mapGridSize = opt.mapGridSize;

        // builds a map of all elements for quicker obstacle queries (i.e. is a point contained
        // in any obstacle?) (a simplified grid search)
        // The paper is divided to smaller cells, where each of them holds an information which
        // elements belong to it. When we query whether a point is in an obstacle we don't need
        // to go through all obstacles, we check only those in a particular cell.
        // var map = _.chain(graph.getElements())
        //     // remove source and target element if required
        //     .difference(excludedEnds)
        //     // remove all elements whose type is listed in excludedTypes array
        //     .reject(function(element) {
        //         return _.includes(opt.excludeTypes, element.get('type'));
        //     })
        //     // change elements (models) to their bounding boxes
        //     .invoke('getBBox')
        //     // expand their boxes by specific padding
        //     .invoke('moveAndExpand', opt.paddingBox)
        //     // build the map
        //     .foldl(function(res, bbox) {
        //
        //         var origin = bbox.origin().snapToGrid(mapGridSize);
        //         var corner = bbox.corner().snapToGrid(mapGridSize);
        //
        //         for (var x = origin.x; x <= corner.x; x += mapGridSize) {
        //             for (var y = origin.y; y <= corner.y; y += mapGridSize) {
        //
        //                 var gridKey = x + '@' + y;
        //
        //                 res[gridKey] = res[gridKey] || [];
        //                 res[gridKey].push(bbox);
        //             }
        //         }
        //
        //         return res;
        //
        //     }, {}).value();
        var map = []; // fuck it, let's just get this working

        // pathfinding

        var newVertices = [];

        var points = _.map(oldVertices, g.point);

        var tailPoint = sourceBBox.center();

        // find a route by concating all partial routes (routes need to go through the vertices)
        // startElement -> vertex[1] -> ... -> vertex[n] -> endElement
        for (var i = 0, len = points.length; i <= len; i++) {

            var partialRoute = null;

            var from = to || sourceBBox;
            var to = points[i];

            if (!to) {

                to = targetBBox;

                // 'to' is not a vertex. If the target is a point (i.e. it's not an element), we
                // might use dragging route instead of main routing method if that is enabled.
                var endingAtPoint = !this.model.get('source').id || !this.model.get('target').id;

                if (endingAtPoint && _.isFunction(opt.draggingRoute)) {
                    // Make sure we passing points only (not rects).
                    var dragFrom = from instanceof g.rect ? from.center() : from;
                    partialRoute = opt.draggingRoute(dragFrom, to.origin(), opt);
                }
            }

            // if partial route has not been calculated yet use the main routing method to find one
            partialRoute = partialRoute || findRoute(from, to, map, opt);

            var leadPoint = _.first(partialRoute);

            if (leadPoint && leadPoint.equals(tailPoint)) {

                // remove the first point if the previous partial route had the same point as last
                partialRoute.shift();
            }

            tailPoint = _.last(partialRoute) || tailPoint;

            newVertices = newVertices.concat(partialRoute);
        };

        // we might have to reverse the result if we swapped source and target at the beginning
        return reverseRouting ? newVertices.reverse() : newVertices;
    };

    // public function
    return function(vertices, opt, linkView) {

        return router.call(linkView, vertices, _.extend({}, config, opt));
    };

})();

angular.module('designer.workspace.canvases.jointjs.views.container', [])
  .service('ContainerView', [function() {
    return joint.dia.ElementView.extend({
      highlighted: false,
      containerBorderColor: "#FAFAFA",
      faded: false,
      selected: false,

      events: {
        'mouseout': 'unhighlight',
        'dragleave': 'unhighlight'
      },

      initialize: function() {
        joint.dia.ElementView.prototype.initialize.apply(this, arguments);

        this.containerFillColor = this.model.attr(".mainRect/fill");
        this.containerBorderColor = "#B8B8B8";
        this.highlighted = false;
        this.selected = false;

        this.listenTo(this.model, 'change:position', this.geometrychange);
        this.listenTo(this.model, 'change:size', this.geometrychange);

        // Update the resource so we have geometry even if they don't move / resize it :P
        this.geometrychange();
      },

      renderStringMarkup: function() {
        var vel = this.vel;
        vel.append(this.model.prebuilt_markup.clone());
        // Cache transformation groups
        this.rotatableNode = vel.findOne('.rotatable');
        this.scalableNode = vel.findOne('.scalable');

        var selectors = this.selectors = {};
        selectors[this.selector] = this.el;
      },

      geometrychange: function() {
        var s = this.model.get('resource');
        if(s) {
          s.geometry = _.extend(this.model.get('position'), this.model.get('size'));
        }
      },

      // TODO: do we use instant anymore? If not we can remove opts
      select: function(instant) {
        var resource = this.model.get("resource");
        var opts = instant ? { delay: 0, duration: 0 }  :
          { delay: 0, duration: 150 };

        opts.valueFunction = joint.util.interpolate.hexColor;
        this.containerBorderColor = this.model.attr(".mainRect/stroke");
        this.model.transition('attrs/.mainRect/stroke-width', 3, { delay: 0, duration: 150 });

        this.selected = true;
      },

      deselect: function() {
        var opts = {
          delay: 0,
          duration: 150,
          timingFunction: joint.util.timing.linear
        };

        var resource = this.model.get("resource");
        opts.valueFunction = joint.util.interpolate.hexColor;
        this.model.transition('attrs/.mainRect/stroke-width', 1, { delay: 0, duration: 150 });

        this.selected = false;
      },

      highlight: function(invalid) {
        if(this.highlighted) return;

        var colour = invalid ?  "#F04124" : "#ABD1AB";
        this.containerFillColor = this.model.attr(".mainRect/fill");

        this.model.attr(".mainRect/fill", colour);
        this.model.attr(".mainRect/fill-opacity", 0.3);

        this.highlighted = true;
      },

      unhighlight: function() {
        if(!this.highlighted) return;

        this.model.attr(".mainRect/fill", this.containerFillColor);
        this.model.attr(".mainRect/fill-opacity", 1);

        this.highlighted = false;
      },

      fade: function() {
        var opts = {
          delay: 0,
          duration: 150,
          timingFunction: joint.util.timing.linear
        };

        this.model.transition('attrs/g/opacity', 0.4, opts);

        this.faded = true;
      },

      unfade: function() {
        var opts = {
          delay: 0,
          duration: 150,
          timingFunction: joint.util.timing.linear
        };

        this.model.transition('attrs/g/opacity', 1, opts);

        this.faded = false;
      },

      updateTheme: function() {
        this.model.updateTheme();
      },

      pointermove: function(evt, x, y) {
        // If the paper is locked then do nothing
        if(this.paper.locked) return;

        joint.dia.ElementView.prototype.pointermove.apply(this, arguments);
      }
    });
  }]);

angular.module('designer.workspace.canvases.jointjs.views.link', [])
.service('LinkView', [function() {
  return joint.dia.LinkView.extend({
    initialize: function() {
      joint.dia.LinkView.prototype.initialize.apply(this, arguments);

      this.options.interactive = false;

      // Hide em all by default
      this.$el.hide();
    },

    renderStringMarkup: function() {
      var children = this.model.prebuilt_markup.clone();
      // custom markup may contain only one children
      if (!Array.isArray(children)) children = [children];
      // Cache all children elements for quicker access.
      var cache = this._V; // vectorized markup;
      for (var i = 0, n = children.length; i < n; i++) {
        var child = children[i];
        var className = child.attr('class');
        if (className) {
          cache[$.camelCase(className)] = child;
        }
      }
      // partial rendering
      this.renderTools();
      this.renderVertexMarkers();
      this.renderArrowheadMarkers();
      this.vel.append(children);
    },

    select: function() {
      this.model.transition('attrs/.selected/stroke-width', 15, {
        delay: 0,
        duration: 150,
        timingFunction: function(t) { return t*t; },
        valueFunction: function(a, b) { return function(t) { return a + (b - a) * t }}
      });
    },

    deselect: function() {
      this.model.transition('attrs/.selected/stroke-width', 3, {
        delay: 0,
        duration: 150,
        timingFunction: function(t) { return t*t; },
        valueFunction: function(a, b) { return function(t) { return a + (b - a) * t }}
      });
    },

    update: function() {
      joint.dia.LinkView.prototype.update.apply(this, arguments);

      // Make sure we update the path of our selection node
      this._V.selected && this._V.selected.attr('d', this._V.connection.attr('d'));
    },

    getResource: function(section) {
      return this.paper.model.getCell(this.model.attributes[section].id).get("resource");
    }
  });
}]);

angular.module('designer.workspace.canvases.jointjs.views.resource', [])
  .service('ResourceView', ["$location", function($location) {
    return joint.dia.ElementView.extend({
      highlighted: false,
      faded: false,

      events: {
        'mouseout': 'unhighlight',
        'dragleave': 'unhighlight',
        'dragover':  'dragover'
      },

      initialize: function() {
        joint.dia.ElementView.prototype.initialize.apply(this, arguments);

        this.containerBorderColor = "#B8B8B8";
        this.listenTo(this.model, 'change:position', this.geometrychange);
        this.listenTo(this.model, 'change:size', this.geometrychange);

        // Update the resource so we have geometry even if they don't move / resize it :P
        this.geometrychange();
      },

      renderStringMarkup: function() {
        var vel = this.vel;
        vel.append(this.model.prebuilt_markup.clone());
        // Cache transformation groups
        this.rotatableNode = vel.findOne('.rotatable');
        this.scalableNode = vel.findOne('.scalable');

        var selectors = this.selectors = {};
        selectors[this.selector] = this.el;
      },

      geometrychange: function() {
        var s = this.model.get('resource');
        if(s) {
          s.geometry = _.extend(this.model.get('position'), this.model.get('size'));
        }

        this.model.geometrychange();
      },

      select: function(instant) {
        var resource = this.model.get("resource");
        var opts = instant ? { delay: 0, duration: 0 }  :
                             { delay: 0, duration: 150, timingFunction: joint.util.timing.linear };

        this.model.attr("use/filter", "url(" + $location.absUrl() + "#selectedResourceFilter)");

        this.model.transition('attrs/use/x', -5, opts);
        this.model.transition('attrs/use/y', -5, opts);
        this.model.transition('attrs/use/width', 80, opts);
        this.model.transition('attrs/use/height', 80, opts);
      },

      deselect: function() {
        var opts = {
          delay: 0,
          duration: 150,
          timingFunction: joint.util.timing.linear
        };

        this.model.attr("use/filter", "");

        this.model.transition('attrs/use/x', 0, opts);
        this.model.transition('attrs/use/y', 0, opts);
        this.model.transition('attrs/use/width', 70, opts);
        this.model.transition('attrs/use/height', 70, opts);
      },

      highlight: function(invalid) {
        if(this.highlighted) return;

        var colour = invalid ?  "#F04124" : "#077a07";

        this.model.attr("use/filter", "url(" + $location.absUrl() + "#highlightedResourceFilter)");

        this.highlighted = true;
      },

      unhighlight: function() {
        if(!this.highlighted) return;

        this.model.attr("use/filter", "");

        this.highlighted = false;
      },

      fade: function() {
        var opts = {
          delay: 0,
          duration: 150,
          timingFunction: joint.util.timing.linear
        };

        this.model.transition('attrs/g/opacity', 0.4, opts);

        this.faded = true;
      },

      unfade: function() {
        var opts = {
          delay: 0,
          duration: 150,
          timingFunction: joint.util.timing.linear
        };

        this.model.transition('attrs/g/opacity', 1, opts);

        this.faded = false;
      },

      updateTheme: function() {
        this.model.updateTheme(this);
      },

      pointermove: function(evt, x, y) {
        // If the paper is locked then do nothing
        if(this.paper.locked) return;

        joint.dia.ElementView.prototype.pointermove.apply(this, arguments);
      }
    });
  }]);

angular.module('designer.workspace.canvases.jointjs.views.text', [])
.service('TextView', [function() {
  return joint.dia.ElementView.extend({

    updateTheme: function() {
      this.model.updateTheme();
    },

    pointermove: function(evt, x, y) {
      // If the paper is locked then do nothing
      if(this.paper.locked) return;

      joint.dia.ElementView.prototype.pointermove.apply(this, arguments);
    }
  });
}]);

angular.module('designer.workspace.canvases.html.handler.event', [])
  .factory('HtmlEventHandler', [function() {
    function EventHandler() {
      this.listeners = {};
    }

    EventHandler.prototype.on = function(event_name, callme) {
      if(!this.listeners[event_name]) this.listeners[event_name] = [];

      this.listeners[event_name].push(callme);
    };

    EventHandler.prototype.trigger = function() {
      var args = _.map(arguments, function(a) { return a });
      var event_name = args.shift();

      if(this.listeners[event_name]) {
        _.each(this.listeners[event_name], function(callme) {
          callme.apply(null, args);
        });
      }
    };

    EventHandler.prototype.off = function() {
      if(arguments.length == 1) {
        delete this.listeners[arguments[0]];
      }
      else {
        this.listeners = {};
      }
    };

    return EventHandler;
  }]);

angular.module('designer.workspace.canvases.html.handler.selection', [])
  .factory('HtmlSelectionHandler', [function() {
    function SelectionHandler(diagram) {
      this.selected_elements = [];
      this.diagram = diagram;
    }

    SelectionHandler.prototype.deselectElements = function() {
      if(this.selected_elements.length) {
        _.each(this.selected_elements, function(el) {
          el.deselect();
        }.bind(this));

        this.selected_elements = [];
      }
    };

    SelectionHandler.prototype.selectElement = function(el, instant) {
      var selected = this.selected_elements;
      this.deselectElements();

      if(_.includes(selected, el)) return;

      // If the resource has multiple positions make sure we select them all
      // var resource = el.resource;
      // var views = _.map(this.diagram.model.getCellsByResourceId(resource.id), function(cell) { return this.diagram.findViewByModel(cell) }.bind(this));

      // TODO: do we need to handle multiple selects?
      this.selected_elements.push(el);
      el.select(instant);

      // // Select em all
      // _.each(views, function(v) {
      //   this.selected_elements.push(v);
      //   v.select(instant);
      // }.bind(this));
    };

    SelectionHandler.prototype.cancelSelection = function(evt, x, y) {
      this.deselectElements();
    };

    // In case the design refreshes and we lose focus on the selected element
    // SelectionHandler.prototype.refreshSelected = function() {
    //   if(this.selected_elements.length == 0) return;
    //
    //   var resource_id = this.selected_elements[0].model.resource_id;
    //   var cells = this.diagram.model.getCellsByResourceId(resource_id);
    //   var cellView = this.diagram.findViewByModel(cells[0]);
    //
    //   this.selectCell(cellView, true);
    // };

    return SelectionHandler;
  }]);

angular.module('designer.workspace.canvases.html.handler.zoom', [])
  .factory('HtmlZoomHandler', [function() {
    function ZoomHandler(diagram) {
      this.diagram     = diagram;
      this.zoomLevel   = 1;
      this.minZoom     = 0.1;
      this.maxZoom     = 2;
    }

    ZoomHandler.prototype.zoom = function(newZoomLevel) {
      newZoomLevel = newZoomLevel || 1;

      // Don't go over / under
      if(newZoomLevel < this.minZoom)  newZoomLevel = this.minZoom;
      if(newZoomLevel > this.maxZoom) newZoomLevel = this.maxZoom;

      // TODO: test across browsers
      var params = {
        'transform': 'scale('+newZoomLevel+')',
        'transform-origin': '50% 50% 0'
      };
      this.diagram.el.css(params);
      this.zoomLevel = newZoomLevel;
    };

    ZoomHandler.prototype.autoZoom = function(view) {
      var viewWidth      = view.width;
      var viewHeight     = view.height;
      var viewportHeight = this.diagram.scroller.el[0].clientHeight - 50;
      var viewportWidth  = this.diagram.scroller.el[0].clientWidth - 50;
      var heightDiff     = viewHeight - viewportHeight;
      var widthDiff      = viewWidth - viewportWidth;

      var zoomLevel = (heightDiff > widthDiff) ? (viewportHeight / viewHeight) : (viewportWidth / viewWidth);

      this.zoom(Math.round(zoomLevel * 10) / 10);
    };

    ZoomHandler.prototype.zoomOut = function () {
      this.zoom((this.zoomLevel || 1) - .3);
    };

    ZoomHandler.prototype.zoomIn = function () {
      this.zoom((this.zoomLevel || 1) + .3);
    };

    return ZoomHandler;
  }]);

angular.module('designer.workspace.views.html.element', [])
  .factory("Element", [function() {
    return {
      load: function(options, resource) {
        var element = {};

        element.options = options || {};
        element.resource = resource;
        element.template = "<div></div>";
        element.el = null;

        // Geometry
        element.geometry = {
          x: options["x"],
          y: options["y"],
          w: options["w"],
          h: options["h"]
        };

        element.render = function() {
          this.el = $(this.template);
          this.el.css("position", "absolute");
          this.el.css("top", this.geometry.y + "px");
          this.el.css("left", this.geometry.x + "px");
          this.el.css("width", this.geometry.w + "px");
          this.el.css("height", this.geometry.h + "px");
          this.el.data("view", this);
        };

        return element;
      }
    }
  }]);

angular.module('designer.workspace.canvases.jointjs.shapes.container', ['designer.workspace.canvases.jointjs.views.container'])
.service('ContainerElement', ["ContainerView", function(ContainerView) {
  var prebuilt_markup = V('<g>' +
    '<g class="scalable">' +
    '<rect class="mainRect" />' +
    '</g>' +
    '<text class="description1"/>' +
    '<text class="title"/>' +
    '</g>');

  return joint.shapes.basic.Rect.extend({
    view: ContainerView,
    prebuilt_markup: prebuilt_markup,
    markup: " ",
    selectBorderColor: "#8A8A8A",
    container: true,
    defaults: joint.util.defaultsDeep({
      type: 'container',
      size: { width: 300, height: 300 },
      attrs: {
        'g': {
          'ref-width': '100%',
          'ref-height': '100%',
          opacity: 1
        },
        '.title': { 'font-size': 14, x: -20, y: -10, "text-anchor": "end", fill: 'red', text: '', ref: '.mainRect', 'ref-x': 0.9999999, 'ref-y': 0.9999999 },
        '.description1': { 'font-size': 11, x: -20, y: -25, "text-anchor": "end", fill: 'blue', text: '', ref: '.mainRect', 'ref-x': 0.9999999, 'ref-y': 0.9999999 }
        //'.description2': { 'font-size': 11, x: 10, y: -10, fill: 'blue', text: '', ref: '.mainRect', 'ref-x': 0.00001, 'ref-y': 0.9999999 }
      }
    }, joint.shapes.basic.Generic.prototype.defaults),

    initialize: function() {
      joint.shapes.basic.Generic.prototype.initialize.apply(this, arguments);
    },

    // Override the original method as it seems to save links and then borks when trying to translate them
    getEmbeddedCells: function() {
      if (this.collection) {
        return _.compact(_.map(this.get('embeds') || [], function(cellId) {
          var cell = this.collection.get(cellId);
          if(_.includes(["resource", "container"], cell.get("type"))) {
            return cell;
          }
        }.bind(this)));
      }
      return [];
    },

    updateTheme: function() {
      var resource = this.get("resource");
      if(resource) {
        resource.setImageUrl();
      }
    },

    updateContainerText: function(paper) {
      console.log("Override me!");
    }
  });
}]);

angular.module('designer.workspace.canvases.jointjs.shapes.resource', [
  'designer.model.resource.images',
  'designer.model.resource.images',
  'designer.workspace.canvases.jointjs.views.resource',
  "designer.state",
  "designer.state"
])
  .service('ResourceElement', ["ResourceView", "DesignerState", "DesignerConfig", "ResourceImages", function(ResourceView, DesignerState, DesignerConfig, ResourceImages) {
    var prebuilt_markup = V('<g>' +
      '<circle class="connectionPoint" />' +
      '<use></use>' +
      '<text class="iconInfo"/>' +
      '<circle class="badge" />' +
      '<text class="badgeText"/>' +
      '<text class="title"/>' +
      '<foreignObject class="nameContainer">' +
        '<div xmlns="http://www.w3.org/1999/xhtml">' +
        '<p class="name" style="line-height:1; text-align: center; overflow: hidden; word-break: break-all;"></p>' +
        '</div>' +
      '</foreignObject>' +
      '</g>');

    return joint.shapes.basic.Image.extend({
      view: ResourceView,
      prebuilt_markup: prebuilt_markup,
      markup: " ",
      defaults: joint.util.defaultsDeep({
        type: 'resource',
        size: { width: 70, height: 70 },
        z: 40,
        attrs: {
          'g': {
            'ref-width': '100%',
            'ref-height': '100%',
            opacity: 1
          },
          'use': { 'width': 70, 'height': 70, 'x':0, 'y':0 },
          '.connectionPoint': { cx: 35, cy: 35, magnet: true, r: 30, fill: "#FFFFFF", opacity: 0 },
          '.badge': { r: 10, 'fill': '#DDDDDD', cx: 60, cy: 60, opacity: 0, "stroke-width": 1, stroke: "#FFFFFF" },
          '.badgeText': { 'font-size': 12, x: 60, y: 65, ref: 'use', text: '', fill: '#000000', 'text-anchor': 'middle' },
          '.nameContainer': { 'font-size': 10, x: -16, y: 76, width: 102, height: 48, color: '#111111' }
        }
      }, joint.shapes.basic.Generic.prototype.defaults),

      images_key: "vendor",

      initialize: function() {
        joint.shapes.basic.Image.prototype.initialize.apply(this, arguments);
      },

      showIconInformation: function(view) {
        var resource = this.get("resource");

        if (typeof resource.getIconInformation === 'function') {
          var info = resource.getIconInformation() || {}; 
          var txt = info.txt; 
          var words = txt.split(/\s+/);

          var line1 = V('<tspan class="info-on-icon">' + words[0] + '</tspan>');
          line1.attr(info);
          
          V(view.el).find(".iconInfo")[0].append(line1);

          if (words.length > 1) { 
            var line2 = V('<tspan class="info-on-icon" >' + words[1] + '</tspan>');
            var attrs = info;
            attrs.dx = info.dx2;
            attrs.dy = info.dy2;

            line2.attr(attrs);
            V(view.el).find(".iconInfo")[0].append(line2);
          } 
        }
      },

      hideIconInformation: function(view) {
        $(view.el).find('.iconInfo').text("");
      },

      showName: function(view) {
        var name = this.get("resource").name || "";

        // If name is over a certain length then make sure it doesn't break over too many lines
        if(name.length > 25) {
          name = name.replace(/-/g, String.fromCharCode(8209));
        }

        $(view.el).find('.name').text(name);
      },

      hideName: function(view) {
        $(view.el).find('.name').text("");
      },

      updateTheme: function(view) {
        var resource = this.get("resource");
        resource.setImageUrl();
        ResourceImages.icons_sets[resource.provider_type][DesignerState.get("selectedIconSet")]["icon_overlay"] ?  this.showIconInformation(view) :  this.hideIconInformation(view);
       
        this.attr("use/href", resource.image);
      },

      updateContainerText: function(paper) {
        // Skip rendering them on thumbnails, as they just slow things down
        if(!DesignerConfig.get("loadBadges"))
          return;

        var resource = this.get("resource");

        if(!resource.has_badge) return;

        // Need to get the position, then see if it's in a subnet
        // FIXME (AN): we do this for asg, which needs a subnet. It's a bit too specific :P Also veeeery slow as it calls bbox
        var parents = paper.model.findModelsFromPoint(this.get("position"));
        var subnet = _.find(parents, function(p) {
          var r = p.get("resource");
          return r && r.type === "Resources::AWS::EC2::Subnet";
        });

        // Display the badge if we have any content
        var t = resource.badgeContent(subnet);
        if(t) {
          //console.debug(t, this.id, this.resource_id);
          this.attr(".badgeText/text", t);
          this.attr(".badge/opacity", 1);
        }
      },

      geometrychange: function() {
        var width = DesignerState.get("layout")["Views::Infrastructure"].resource_width;
        var height = DesignerState.get("layout")["Views::Infrastructure"].resource_height;
        this.attr(".nameContainer/x", (0 - width));
        this.attr(".nameContainer/height", (16 + height));
        this.attr(".nameContainer/width", (60 + (width * 2)));
      }
    });
  }]);

angular.module('designer.workspace.canvases.jointjs.shapes.text', ['designer.workspace.canvases.jointjs.views.text'])
.service('TextElement', ["TextView", function(TextView) {
  return joint.shapes.standard.Rectangle.extend({
    view: TextView,
    defaults: joint.util.defaultsDeep({
      attrs: {
        body: {
          fill: "#000000",
          stroke: '#000000',
          strokeWidth: 0,
          opacity: 0
        },
        label: {
          text: ' ',
          textAnchor: 'left',
          fontSize: 40,
          refX: '0%',
          refY: '0%',
          fill: '#333333',
          fontWeight: "bold"
        }
      }
    }, joint.shapes.standard.Rectangle.prototype.defaults),

    updateTheme: function() {},

    updateContainerText: function(paper) {}
  });
}]);

//     attrs: {
//         rect: {
//             fill: '#ffffff',
//             stroke: '#000000',
//             width: 80,
//             height: 100
//         },
//         text: {
//             fill: '#000000',
//             'font-size': 14,
//             'font-family': 'Arial, helvetica, sans-serif'
//         },
//         '.content': {
//             text: '',
//             'ref-x': .5,
//             'ref-y': .5,
//             'y-alignment': 'middle',
//             'x-alignment': 'middle'
//         }
//     },

angular.module('designer.workspace.layout.container.ecs.cluster', [
  "designer.workspace.layout.container.ecs.service"
])
.factory('ContainerLayoutECSCluster', ["ContainerLayoutECSService", function(ContainerLayoutECSService) {
  return {
    load: function(cluster, environment) {
      cluster.getData = function() {
        var services  = _.orderBy(this.getServices(), ["name"]);

        return {
          id: this.id,
          cells: _.map(services, function(s) { return ContainerLayoutECSService.load(s, environment).getData() }),
          type: "cluster",
          container: true,
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          style: { "padding-top": "20px", "padding-bottom": "35px" }
        }
      };

      return cluster;
    }
  }
}]);

angular.module('designer.workspace.layout.container.ecs.service', [])
.factory('ContainerLayoutECSService', [function() {
  return {
    load: function(service, environment) {
      service.getData = function() {
        var tasks  = _.orderBy(this.getTasks(), ["status", "name"])

        return {
          id: this.id,
          tasks: tasks,
          max_tasks: Math.max((this.desired_count || 0), tasks.length),
          load_balancers: this.getLoadBalancers(),
          volumes: [],
          type: "ecs_service",
          container: true,
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          style: { "padding-top": "30px" }
        }
      };

      service.getLoadBalancers = function() {
        return environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancing::LoadBalancer").concat(
          environment.connectedTo(this, "Resources::AWS::ElasticLoadBalancingV2::TargetGroup")
        );
      }

      return service;
    }
  }
}]);

angular.module('designer.workspace.layout.container.position.grid', [])
.service('ContainerLayoutGridPosition', [function() {
  const CONTAINER_PADDING = {top: 50, right: 20, bottom: 50, left: 20};

  // TODO: we should be able to define margin and padding for each element
  const CONTAINER_SPACING = 20;

  function translate_cell(cell, x, y, w, h) {
    if (cell.fit_to_width) {
      cell.w = w;
      cell.fit_to_width = false;
      // TODO: this is to handle load balancers in ECS. We need to handle this in the layout itself in future
      cell.style = { width: "100%", margin: 0, height: "50px" };
    }

    if (cell["cells"]) {
      _.each(cell.cells, (subcell) => translate_cell(subcell, x, y, w, h));
    }
  }

  return {
    position: function(container, config) {
      let cells = container.cells;
      let total_cells = cells.length;
      let container_spacing = config["container_spacing"] || CONTAINER_SPACING;

      // Determine columns and rows and knock up a grid
      let columns = Math.max(Math.ceil(total_cells / 5), 1);

      if (config["max_columns"] && config["max_columns"] < columns) {
        columns = config.max_columns
      }

      let rows = Math.max(Math.ceil(total_cells / columns), 1);

      // If they've set max_rows we need to rejig the logic
      if (config["max_rows"] && config["max_rows"] < rows) {
        rows = config.max_rows;
        columns = Math.ceil(total_cells / rows);
      }

      // Helpers for angular layout
      container.rows = _.map(new Array(rows), (x, i) => i );
      container.columns = _.map(new Array(columns), (x, i) => i );

      let cell_index = -1;
      let grid = [...Array(rows)].map(() => (
        [...Array(columns)].map(() => (
          (++cell_index) >= total_cells ? null : cells[cell_index]
        ))
      ));

      // Determine maximum height of rows
      let row_heights = [...Array(rows)].map(() => 0);
      let column_widths = [...Array(columns)].map(() => 0);
      _.each(grid, (row, row_index) => (
        _.each(row, (cell, column_index) => {
          if (!cell) return;

          row_heights[row_index] = Math.max(row_heights[row_index], cell.h);
          column_widths[column_index] = Math.max(column_widths[column_index], cell.w);
        })
      ));

      // Add container position
      container.w = CONTAINER_PADDING.left + (_.reduce(column_widths, (sum, val) => sum + val, 0)) + (container_spacing * (column_widths.length - 1)) + CONTAINER_PADDING.right;
      container.h = CONTAINER_PADDING.top + (_.reduce(row_heights, (sum, val) => sum + val, 0)) + (container_spacing * (row_heights.length - 1)) + CONTAINER_PADDING.bottom;

      // Set minimum dimensions
      // TODO: this is to account for empty containers atm, need to expand columns to fit I'm guessing?
      if (config["min_width"] && container.w < config["min_width"]) {
        container.w = config.min_width
      }

      if (config["min_height"] && container.h < config["min_height"]) {
        container.h = config.min_height
      }

      // Position everything else
      let current_row_offset = CONTAINER_PADDING.top;

      _.each(grid, (row, row_index) => {
        let current_column_offset = CONTAINER_PADDING.left;

        _.each(row, (cell, column_index) => {
          if (cell) {
            translate_cell(
              cell,
              current_column_offset,
              current_row_offset,
              column_widths[column_index],
              row_heights[row_index]
            )
          }

          current_column_offset += column_widths[column_index];

          if (!(column_index === column_widths.size - 1)) {
            current_column_offset += container_spacing;
          }
        });

        current_row_offset += row_heights[row_index];

        if (!(row_index === row_heights.size - 1)) {
          current_row_offset += container_spacing;
        }
      });

      return container;
    }
  }
}]);

angular.module('designer.workspace.layout.container.position.hex', [])
.service('ContainerLayoutHexPosition', [function() {
  const CELL_HEIGHT = 100;
  const CELL_WIDTH = 86.6;

  function hex_radius(cell_count) {
    let radius = 1;
    let max = 1;

    while (max < cell_count) {
      radius++;
      max = radius * (radius - 1) * 3 + 1
    }

    return radius;
  }

  function cluster_cells(start_x, start_y, count) {
    let x = start_x;
    let y = start_y;
    let angle = Math.PI / 3;
    let dist = Math.sin(angle) * 100;
    let side = 0;
    let list = [];
    list.push({x, y});
    count--;

    while (count > 0) {
      let t = 0;

      while (t < Math.floor((side + 4) / 6) + (side % 6 === 0 ? 1 : 0) && count > 0) {
        y = y - dist * Math.cos(side * angle);
        x = x - dist * Math.sin(side * angle);
        list.push({x, y});
        count--;
        t++;
      }

      side++
    }

    return list;
  }

  return {
    position: function(container, max_cells, config={}) {
      let radius = hex_radius(max_cells);
      let center_x = (radius * CELL_WIDTH) - (CELL_WIDTH / 2);
      let center_y = (radius * CELL_HEIGHT) - (CELL_HEIGHT / 2);
      let cell_positions = cluster_cells(center_x, center_y, max_cells);

      // Add the cells
      let cells = [];

      _.each(cell_positions, (p) => {
        let cell = container.cells.shift();

        cells.push({
          x: p.x,
          y: p.y,
          w: CELL_WIDTH,
          h: CELL_HEIGHT,
          id: cell ? cell.id : "empty"
        })
      });

      container.x = 0;
      container.y = 0;
      container.h = center_y * 2 + CELL_HEIGHT;
      container.w = center_x * 2 + CELL_WIDTH;
      container.cells = cells;

      // Check config
      // TODO: center the hexes?
      if (config["min_width"] && container.w < config["min_width"]) {
        container.w = config.min_width
      }

      if (config["min_height"] && container.h < config["min_height"]) {
        container.h = config.min_height
      }

      return container;
    }
  }
}]);

angular.module('designer.workspace.layout.container.kubernetes.cluster', [
  "designer.workspace.layout.container.kubernetes.namespace",
  "designer.state"
])
.factory('ContainerLayoutKubernetesCluster', ["ContainerLayoutKubernetesNamespace", "DesignerState", function(ContainerLayoutKubernetesNamespace, DesignerState) {
  return {
    load: function(cluster, environment) {
      cluster.getData = function() {
        var namespaces  = _.orderBy(this.getNamespaces(), ["name"]);

        if (DesignerState.get("hideNamespaces")) {
          namespaces = _.reject(namespaces, (ns) => ns.name.startsWith("kube-"));
        }

        return {
          id: this.id,
          cells: _.map(namespaces, function(n) { return ContainerLayoutKubernetesNamespace.load(n, environment).getData() }),
          type: "cluster",
          container: true,
          x: 0,
          y: 0,
          w: 0,
          h: 0
        }
      };

      return cluster;
    }
  }
}]);

angular.module('designer.workspace.layout.container.kubernetes.namespace', [
  "designer.workspace.layout.container.kubernetes.service",
  "designer.workspace.layout.container.kubernetes.workload"
])
.factory('ContainerLayoutKubernetesNamespace', [
  "ContainerLayoutKubernetesWorkload", "ContainerLayoutKubernetesService", function(ContainerLayoutKubernetesWorkload, ContainerLayoutKubernetesService) {
  return {
    load: function(namespace, environment) {
      namespace.getData = function() {
        var workloads  = _.orderBy(this.getWorkloads(), ["name"]);
        var services  = _.orderBy(this.getServices(), ["name"]);

        var cells = _.map(services, (s) => ContainerLayoutKubernetesService.load(s, environment).getData()).concat(
          _.map(workloads, (s) => ContainerLayoutKubernetesWorkload.load(s, environment).getData())
        )

        return {
          id: this.id,
          cells: _.map(workloads, (s) => ContainerLayoutKubernetesWorkload.load(s, environment).getData()),
          top: _.map(services, (s) => ContainerLayoutKubernetesService.load(s, environment).getData()),
          type: "namespace",
          container: true,
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          style: { "padding-top": "25px", "margin-bottom": "25px" }
        }
      };

      namespace.getWorkloads = function() {
        var containers = [];
        var sets = this.getDaemonSets().concat(this.getReplicaSets()).concat(this.getStatefulSets());

        _.each(sets, function(set) {
          var deployments = environment.connectedTo(set, "Resources::Kubernetes::Cluster::Deployment");
          if (deployments.length === 0) {
            containers.push(set);
          }
          else {
            containers.push(...deployments);
          }
        });

        return _.uniq(containers);
      };

      return namespace;
    }
  }
}]);

angular.module('designer.workspace.layout.container.kubernetes.service', [])
.factory('ContainerLayoutKubernetesService', [function() {
  return {
    load: function(service, environment) {
      service.getData = function() {
        return {
          id: this.id,
          cells: [],
          type: "service",
          container: false,
          x: 0,
          y: 0,
          w: 0,
          h: 50
        }
      };

      return service;
    }
  }
}]);

angular.module('designer.workspace.layout.container.kubernetes.workload', [])
.factory('ContainerLayoutKubernetesWorkload', [function() {
  return {
    load: function(workload, environment) {
      workload.getData = function() {
        var pods = this.getPods();

        return {
          id: this.id,
          tasks: pods,
          max_tasks: Math.max((this.desired_count || 0), pods.length),
          load_balancers: [],
          volumes: this.getVolumes(),
          type: "workload",
          container: true,
          x: 0,
          y: 0,
          w: 0,
          h: 0
        }
      };

      workload.getPods = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::Pod");
      };

      workload.getVolumes = function() {
        return environment.connectedTo(this, "Resources::Kubernetes::Cluster::PersistentVolume");
      };

      return workload;
    }
  }
}]);

angular.module('designer.workspace.layout.infrastructure.aws.global', [
  "designer.workspace.layout.infrastructure.aws.vpc"
])
.factory('InfrastructureLayoutAWSGlobal', ["InfrastructureLayoutAWSVPC", function(InfrastructureLayoutAWSVPC) {
  return {
    load: function(environment) {
      var layout = {};

      layout.getData = function() {
        var center = this.getVPCs();
        var networkResourceIDs = [];

        // TODO: this is yuck, but whatevs - we need to know what's already displayed so we don't add it here
        _.each(center, function(vpc) {
          _.each(vpc.center, function(row) {
            if (row.type === "load_balancer") {
              networkResourceIDs = networkResourceIDs.concat(row.resources);
            }
            else {
              _.each(row.columns, function(col) {
                networkResourceIDs = networkResourceIDs.concat(col.resources);
              });
            }
          });

          networkResourceIDs = networkResourceIDs.concat(vpc.left).concat(vpc.right).concat(vpc.top.left).concat(vpc.top.right);
        });

        return {
          id: null,
          top: _.reject(this.getTopRow(), function (r) {
            return _.includes(networkResourceIDs, r)
          }),
          bottom: _.reject(this.getBottomRow(), function (r) {
            return _.includes(networkResourceIDs, r)
          }),
          center: center,
          parent: true
        };
      };

      layout.getVPCs = function() {
        var vpcs = _.filter(environment.facet.resources, function(r) { return r.type === 'Resources::AWS::EC2::VPC' });
        return _.map(vpcs, function(vpc) { return InfrastructureLayoutAWSVPC.load(vpc, environment).getData() });
      };

      layout.getTopRow = function() {
        var values = [];
        var types = [
          "Resources::AWS::S3::Bucket",
          "Resources::AWS::SQS::Queue",
          "Resources::AWS::APIGateway::RestAPI",
          "Resources::AWS::CloudFront::Distribution",
          "Resources::AWS::CloudFront::StreamingDistribution",
          "Resources::AWS::DynamoDB::Table",
          "Resources::AWS::ElasticBeanstalk::Environment",
          "Resources::AWS::Lambda::Function",
          "Resources::AWS::DirectoryService::Directory",
          "Resources::AWS::EFS::FileSystem",
          "Resources::AWS::RDS::DBInstance",
          "Resources::AWS::WorkSpaces::WorkSpace",
          "Resources::AWS::DirectConnect::DirectConnectGateway",
          "Resources::AWS::Route53::HostedZone",
          "Resources::AWS::EC2::CustomerGateway",
          "Resources::AWS::EC2::TransitGateway",
          "Resources::AWS::WAF::WebACL",
          "Resources::AWS::WAFV2::WebACL"
        ];

        _.each(types, function(type) { values = values.concat(environment.getResourcesByType(type)) });

        return _.map(values, function(r) { return r.id });
      };

      layout.getBottomRow = function() {
        var values = [];
        var types = [
          "Resources::AWS::Generic::GlobalResource",
        ];

        _.each(types, function(type) { values = values.concat(environment.getResourcesByType(type)) });
        return _.uniq(_.map(values, function(r) { return r.id }));
      };

      return layout;
    }
  }
}]);

angular.module('designer.workspace.layout.infrastructure.aws.subnet', [])
.factory('InfrastructureLayoutAWSSubnet', [function() {
  return {
    load: function(subnet, environment) {

      subnet.getData = function() {
        var resources = [];
        var subnet_groups = [];
        var instances = this.getInstances();
        var autoscale_groups = [];

        resources = resources.concat(this.getNATGateways());

        _.each(instances, function(instance) {
          // Only add it if it's not part of an ASG
          var asgs = environment.connectedTo(instance, "Resources::AWS::AutoScaling::AutoScalingGroup");

          if (asgs.length) {
            autoscale_groups = autoscale_groups.concat(asgs);
          }
          else {
            resources.push(instance);
          }
        })

        resources = resources.concat(_.uniq(autoscale_groups));
        resources = resources.concat(this.getRDSClusters());
        resources = resources.concat(this.getRDSInstances());
        resources = resources.concat(this.getRedshiftNodes());
        resources = resources.concat(this.getElasticacheNodes());
        resources = resources.concat(this.getEFSFileSystems());
        resources = resources.concat(this.getWorkSpaces());
        resources = resources.concat(this.getDirectories());
        resources = resources.concat(this.getLambdas());

        subnet_groups = subnet_groups.concat(this.getDBSubnetGroups());
        subnet_groups = subnet_groups.concat(this.getClusterSubnetGroups());
        subnet_groups = subnet_groups.concat(this.getCacheSubnetGroups());

        return {
          id: this.id,
          az: this.availability_zone,
          name: this.name,
          cidr_block: this.cidr,
          resources: _.map(resources, function(r) { return r.id }),
          subnet_groups: _.map(subnet_groups, function(r) { return r.id })
        }
      };

      subnet.getInstances = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::Instance");
      };

      subnet.getDBSubnetGroups = function() {
        return environment.connectedTo(this, "Resources::AWS::RDS::DBSubnetGroup");
      };

      subnet.getClusterSubnetGroups = function() {
        return environment.connectedTo(this, "Resources::AWS::Redshift::ClusterSubnetGroup");
      };

      subnet.getCacheSubnetGroups = function() {
        return environment.connectedTo(this, "Resources::AWS::ElastiCache::CacheSubnetGroup");
      };

      subnet.getRDSClusters = function() {
        return _.filter(environment.connectedTo(this, "Resources::AWS::RDS::DBCluster"), function(o) {
          return o.db_cluster_members.length === 0 && _.includes(o.availability_zones, this.availability_zone);
        }.bind(this));
      };

      subnet.getRDSInstances = function() {
        return environment.connectedTo(this, "Resources::AWS::RDS::DBInstance");
      };

      subnet.getRedshiftNodes = function() {
        return environment.connectedTo(this, "Resources::AWS::Redshift::ClusterNode");
      };

      subnet.getElasticacheNodes = function() {
        return environment.connectedTo(this, "Resources::AWS::ElastiCache::CacheNode");
      };

      subnet.getInstances = function() {
        var instances = environment.connectedTo(this, "Resources::AWS::EC2::Instance");
        var nics = environment.connectedTo(this, "Resources::AWS::EC2::NetworkInterface");

        _.each(nics,  function(nic) {
          instances = instances.concat(environment.connectedTo(nic, "Resources::AWS::EC2::Instance"))
        });

        return _.uniq(instances);
      };

      subnet.getNATGateways = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::NATGateway");
      };

      subnet.getRouteTables = function() {
        return environment.connectedTo(this, "Resources::AWS::EC2::RouteTable");
      };

      subnet.getEFSFileSystems = function() {
        return environment.connectedTo(this, "Resources::AWS::EFS::FileSystem");
      };

      subnet.getWorkSpaces = function() {
        return environment.connectedTo(this, "Resources::AWS::WorkSpaces::WorkSpace");
      };

      subnet.getDirectories = function() {
        return environment.connectedTo(this, "Resources::AWS::DirectoryService::Directory");
      };

      subnet.getLambdas = function() {
        return environment.connectedTo(this, "Resources::AWS::Lambda::Function");
      };

      // Generic Resources
      subnet.getGenericSubnetResources = function() {
        return environment.connectedTo(this, "Resources::AWS::Generic::SubnetResource");
      }

      subnet.isPublic = function() {
        var route_tables = this.getRouteTables();
        var pub = false;

        _.each(route_tables, function(route_table) {
          var connections = _.filter(route_table.connections, function(c) { return c.remote_resource_type === "Resources::AWS::EC2::InternetGateway" });

          _.each(connections, function(c) {
            if (c["data"]["destination_cidr_block"] === "0.0.0.0/0")
              pub = true;
          });
        });

        return pub;
      };

      return subnet;
    }
  }
}]);

angular.module('designer.workspace.layout.infrastructure.aws.vpc', [
  'designer.workspace.layout.infrastructure.aws.subnet'
])
.factory('InfrastructureLayoutAWSVPC', ["InfrastructureLayoutAWSSubnet", function(InfrastructureLayoutAWSSubnet) {
  return {
    load: function(vpc, environment) {

      vpc.getData = function() {
        var subnets = _.map(environment.connectedTo(this, "Resources::AWS::EC2::Subnet"), function(s) { return InfrastructureLayoutAWSSubnet.load(s, environment) });
        var azs = _.uniq(_.map(subnets, function(s) { return s.availability_zone })).sort();

        var sortable_cidr = function(cidr) {
          var parts = cidr.replace("/", ".").split(".");

          return _.map(parts, function(p) { return p.padStart(3, "0") }).join("");
        }

        var public_rows = _.sortBy(_.filter(subnets, function(s) { return s.isPublic() }), [function(s) { return sortable_cidr(s.cidr_block) }]);
        var private_rows = _.sortBy(_.reject(subnets, function(s) { return s.isPublic() }), [function(s) { return sortable_cidr(s.cidr_block) }]);

        var chunks = [
          { type: "subnet", resources: public_rows },
          { type: "subnet", resources: private_rows }
        ];

        _.each(chunks, function(chunk) {
          chunk["azs"] = _.map(azs, function(az) { return { az: az } });
          _.each(chunk["azs"], function(az) {
            az["resources"] = _.filter(chunk.resources, function(r) { return r.availability_zone === az.az });
          });

          // Turn rows into columns
          chunk["transpose"] = _.zip.apply(_, _.map(chunk["azs"], function(az) { return az["resources"] }))
          delete chunk["resources"];
          delete chunk["azs"];
        }, this);

        var rows = [];
        _.each(chunks, function(chunk) {
          _.each(chunk["transpose"], function(row) {
            // Remove nulls
            row = _.compact(row);

            var cols = [];
            _.each(azs, function(az) {
              var col = _.find(row, function(r) { return r.availability_zone === az });

              // Next column if this is empty
              if (!col) {
                cols.push({ az: az, resources: [], subnet_groups: [] });
              }
              else {
                // Get resources
                var column_subnet = _.find(subnets, function(s) { return s.id === col.id });
                cols.push(column_subnet.getData());
              }
            }, this);

            rows.push({ type: "subnet", columns: cols });

          }, this);
        }, this);

        // Add in some ELB rows eh dawgs whatever
        var elbsubnet_map = {};
        _.each(this.getLoadBalancers(), function(elb) {
          var elb_subnets = environment.connectedTo(elb, "Resources::AWS::EC2::Subnet");
          _.each(elb_subnets, function(s) {
            if(!elbsubnet_map[s.id])
              elbsubnet_map[s.id] = [];
            elbsubnet_map[s.id].push(elb.id);
          })
        }, this);

        var final_rows = [];
        var drawn_lbs = [];
        _.each(rows, function(row) {
          var lb_row = { type: "load_balancer", resources: [] };

          _.each(row.columns, function(subnet_info) {
            var lbs = _.reject((elbsubnet_map[subnet_info["id"]] || []), function(lb) { return _.includes(drawn_lbs, lb) });
            lb_row.resources = lb_row.resources.concat(lbs);
            drawn_lbs = drawn_lbs.concat(lbs);
          });

          if(lb_row.resources.length > 0)
            final_rows.push(lb_row);
          final_rows.push(row);
        });

        return {
          id: this.id,
          center: final_rows,
          top: this.loadTop(),
          right: this.loadRight(),
          left: this.loadLeft(),
          bottom: []
        };
      };

      vpc.getLoadBalancers = function() {
        var lb_types = [
          "Resources::AWS::ElasticLoadBalancing::LoadBalancer",
          "Resources::AWS::ElasticLoadBalancingV2::ApplicationLoadBalancer",
          "Resources::AWS::ElasticLoadBalancingV2::NetworkLoadBalancer"
        ];
        var load_balancers = [];
        var all_lbs = _.filter(environment.facet.resources, function(r) { return _.includes(lb_types, r.type) });
        _.each(all_lbs, function(lb) {
          var vpc_connection = environment.connectedTo(lb, "Resources::AWS::EC2::VPC");
          if(vpc_connection.length) {
            // Add it if it's connected to this VPC
            if(vpc_connection[0].id === this.id)
              load_balancers.push(lb)
          }
          else {
            // No VPC connection, check if it has a subnet connection
            var subnets = environment.connectedTo(lb, "Resources::AWS::EC2::Subnet");
            var connected = false;

            while(!connected && subnets.length) {
              var subnet = subnets.shift;
              vpc_connection = environment.connectedTo(subnet, "Resources::AWS::EC2::VPC");
              if(vpc_connection.length) {
                // Add it if it's connected to this VPC
                if(vpc_connection[0].id === this.id) {
                  load_balancers.push(lb);
                  connected = true;
                }
              }
            }
          }
        }.bind(this), true);

        return _.sortBy(load_balancers, ['type','name']);
      };

      // Generic Resources
      vpc.getGenericVPCResources = function() {
        return environment.connectedTo(this, "Resources::AWS::Generic::VPCResource");
      }

      vpc.loadTop = function() {
        var left = [];
        var right = [];

        right = right.concat(this.getInternetGateways());
        right = right.concat(this.getEgressOnlyInternetGateways());
        right = right.concat(this.getVPNGateways());
        right = right.concat(this.getCustomerGateways());
        right = right.concat(this.getWAFWebACLs());
        right = right.concat(this.getTransitGateways());
        left = left.concat(this.getGenericVPCResources());

        left = left.concat(this.getHostedZones());
        left = left.concat(this.getCloudFrontDistributions());

        return {
          left: _.map(left, function(r) { return r.id }),
          right: _.map(right, function(r) { return r.id })
        }
      };

      vpc.loadRight = function() {
        var resources = [];

        resources = resources.concat(this.getVPCEndpoints());
        resources = resources.concat(this.getDirectConnectGateways());
        resources = resources.concat(this.getVPCPeeringConnections());

        return _.map(resources, function(r) { return r.id });
      };

      vpc.loadLeft = function() {
        var resources = [];

        resources = resources.concat(this.getS3Buckets());
        resources = resources.concat(this.getAPIGateways());
        resources = resources.concat(this.getWorkSpaces());
        resources = resources.concat(this.getElasticBeanstalkEnvironments());

        // Get buckets connected to the VPC endpoint
        _.each(this.getVPCEndpoints(), function(vpce) {
          resources = resources.concat(environment.connectedTo(vpce, "Resources::AWS::S3::Bucket"));
        })

        return _.uniq(_.map(resources, function(r) { return r.id }));
      };

      return vpc;
    }
  }
}]);

angular
  .module("designer.workspace.canvases.jointjs.link.resource", [])
  .service("ResourceLink", [
    function () {
      var prebuilt_markup = V('<path class="connection" />');

      return joint.dia.Link.extend({
        markup: " ",
        prebuilt_markup: prebuilt_markup,
        defaults: joint.util.defaultsDeep(
          {
            z: 30,
            attrs: {
              ".connection": { stroke: "#AAAAAA", "stroke-width": 2 },
            },
          },
          joint.dia.Link.prototype.defaults
        ),
      });
    },
  ]);

angular.module('designer.workspace.canvases.jointjs.link.securitygroup', [])
  .service('SecurityGroupLink', [function() {
    return joint.dia.Link.extend({
      markup: [
        '<path class="selected"/>',
        '<path class="connection" />',
        '<path class="marker-source" />',
        '<path class="marker-target" />',
        '<path class="connection-wrap"/>',
        '<g class="labels"/>',
        '<g class="marker-vertices"/>',
        '<g class="marker-arrowheads"/>',
        '<g class="link-tools"/>'
      ].join(''),

      defaults: joint.util.defaultsDeep({
        z: 30,
        // router: {
        //   name: 'manhattan',
        //   args: { excludeTypes: ['container'], step: 10, maximumLoops: 1000 }
        // },
        //connector: { name: 'rounded' },
        attrs: {
          '.link-tools': { display: 'none' },
          '.connection': { stroke: '#FF00FF', 'stroke-width': 3 },
          '.selected': { stroke: '#ABD1AB', 'stroke-width': 3, fill: 'none' }
        }
      }, joint.dia.Link.prototype.defaults)
    });
  }]);

angular.module('designer.workspace.canvases.jointjs.handler.selection', [])
  .factory('SelectionHandler', [function() {
    function SelectionHandler(paper) {
      this.selected_cells = [];
      this.paper = paper;
    }

    SelectionHandler.prototype.deselectCells = function() {
      if(this.selected_cells.length) {
        _.each(this.selected_cells, function(cell) {
          cell.deselect();
          this.paper.hideLinks(cell.model);
        }.bind(this));

        this.selected_cells = [];
      }
    };

    SelectionHandler.prototype.selectCell = function(cellView, instant) {
      var selected = this.selected_cells;
      this.deselectCells();

      if(_.includes(selected, cellView)) return;

      // If the resource has multiple positions make sure we select them all
      var resource = cellView.model.get("resource");
      var views = resource ? _.map(this.paper.model.getCellsByResourceId(resource.id), function(cell) { return this.paper.findViewByModel(cell) }.bind(this)) : [];

      // Select em all
      _.each(views, function(v) {
        this.selected_cells.push(v);
        v.select(instant);
        this.paper.showLinks(v.model);
      }.bind(this));
    };

    SelectionHandler.prototype.cancelSelection = function(evt, x, y) {
      this.deselectCells();
    };

    // In case the design refreshes and we lose focus on the selected element
    SelectionHandler.prototype.refreshSelected = function() {
      if(this.selected_cells.length == 0) return;

      var resource_id = this.selected_cells[0].model.resource_id;
      var cells = this.paper.model.getCellsByResourceId(resource_id);
      var cellView = this.paper.findViewByModel(cells[0]);

      this.selectCell(cellView, true);
    };

    return SelectionHandler;
  }]);

angular.module('designer.workspace.canvases.jointjs.handler.zoom', [])
.factory('ZoomHandler', [function() {
  function ZoomHandler(paper) {
    this.paper       = paper;
    this.minZoom     = 0.02;
    this.maxZoom     = 3;
    this._scale      = this.paper.scale().sx;
  }

  ZoomHandler.prototype.auto_zoom = function(canvas) {
    this.resetScale();

    var view = canvas.environment.current_view;

    var workspace  = angular.element(".designer-workspace");
    var height     = workspace.height() - 20;
    var width      = workspace.width() - 20;
    var viewWidth  = view.width;
    var viewHeight = view.height;

    // If we're isometric then modify the values to fit the new format
    if (this.paper.isometric) {
      var viewport = this.paper.viewport;
      var bounding_rect = viewport.getBBox();
      viewWidth = bounding_rect.width;
      viewHeight = bounding_rect.height;
    }

    var wDiff = 1 / (viewWidth / width);
    var hDiff = 1 / (viewHeight / height);

    this.zoom(Math.min(wDiff, hDiff));
  };

  ZoomHandler.prototype.zoom = function(scale, ox, oy) {
    scale = scale || 1;

    // Don't go over / under
    if(scale < this.minZoom)  scale = this.minZoom;
    if(scale > this.maxZoom)  scale = this.maxZoom;

    ox = ox || (this.paper.el.scrollLeft + this.paper.el.clientWidth / 2);
    oy = oy || (this.paper.el.scrollTop + this.paper.el.clientHeight / 2);

    var o_scale = scale / this._scale;

    this.paper.setOrigin(o_scale, o_scale);
    this.paper.scale(scale, scale, ox, oy);
    this._scale = scale;
  };


  ZoomHandler.prototype.zoomOut = function () {
    this.zoom((this._scale || 1) - .1);
  };

  ZoomHandler.prototype.zoomIn = function () {
    this.zoom((this._scale || 1) + .1);
  };

  ZoomHandler.prototype.resetScale = function() {
    this._scale = 1;
    this.paper.scale(1,1);
  };

  return ZoomHandler;
}]);

angular.module('designer.workspace.views.infrastructure.aws.shapes.availability-zone', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('AZElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    return ContainerElement.extend({
      selectBorderColor: "#FF9900",
      defaults: joint.util.defaultsDeep({
        shape: "aws.availability-zone",
        size: { width: 200, height: 200 },
        z: 14,
        attrs: {
          '.title': { fill: '#FF9900', y: -10 },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#FFAD32', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, rx: 5, ry: 5, fill: "#F4F8FA" }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");
        this.attr(".title/text", (resource.name || ""));
      },

      updateTheme: function() {
        var style = ResourceImages.getStyle("aws", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.aws.shapes.subnet',
  ['designer.workspace.canvases.jointjs.shapes.container', 'designer.workspace.views.infrastructure.aws.views.subnet'])
  .service('SubnetElement', ["ContainerElement", "AwsSubnetView", "ResourceImages", function(ContainerElement, AwsSubnetView, ResourceImages) {
    var prebuilt_markup = V('<g>' +
      '<g class="scalable">' +
      '<rect class="mainRect" />' +
      '</g>' +
      '<text class="description1"/>' +
      '<text class="title"/>' +
      '<foreignObject class="subnetGroupDisplay">' +
      '<div class="subnetGroupContainer" xmlns="http://www.w3.org/1999/xhtml">' +
      '</div>' +
      '</foreignObject>' +
      '</g>');

    return ContainerElement.extend({
      view: AwsSubnetView,
      prebuilt_markup: prebuilt_markup,
      defaults: joint.util.defaultsDeep({
        shape: "aws.subnet",
        size: { width: 200, height: 200 },
        z: 20,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, rx: 5, ry: 5, fill: "#FFFFFF" },
          '.subnetGroupDisplay': { ref: '.mainRect', 'ref-x': 0, 'ref-y': 0.9999999, x: 1, y: -150, "ref-width": '96%', height: 100 }
        }
      }, ContainerElement.prototype.defaults),

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();
        var style = ResourceImages.getStyle("aws", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      },

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        var name = resource.name || "";
        var desc = resource.cidr_block || "";

        if(name !== resource.provider_id) {
          desc = resource.provider_id + " - " + desc;
        }

        this.attr(".title/text", name);
        this.attr(".description1/text", desc);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.aws.shapes.vpc', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('VpcElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    var prebuilt_markup = V('<g>' +
      '<g class="scalable">' +
      '<rect class="vpc mainRect"/>' +
      '</g>' +
      '<g class="control-bar">' +
      '<image width="24px" height="24px" xlink:href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxOHB4IiB2aWV3Qm94PSIwIDAgMTYgMTgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiPiAgICAgICAgPHRpdGxlPkltcG9ydGVkIExheWVyczwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSI4LUNvcHktQ29weSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc2tldGNoOnR5cGU9Ik1TUGFnZSI+ICAgICAgICA8ZyBpZD0iMS0tLW1haW4iIHNrZXRjaDp0eXBlPSJNU0FydGJvYXJkR3JvdXAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05MzguMDAwMDAwLCAtMjIxLjAwMDAwMCkiIHN0cm9rZT0iI0I4QjhCOCIgc3Ryb2tlLXdpZHRoPSIxLjUiPiAgICAgICAgICAgIDxnIGlkPSJJbXBvcnRlZC1MYXllcnMtMi0rLUltcG9ydGVkLUxheWVycyIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTM5LjAwMDAwMCwgMjIyLjAwMDAwMCkiPiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNS4yLDQuMzQ0MjE2MjIgQzUuMiwzLjYxOTY3NTY4IDYuMDE0NCwzLjAwNzEzNTE0IDcuMDI4NTcxNDMsMy4wMDcxMzUxNCBDOC4wNDI3NDI4NiwzLjAwNzEzNTE0IDguODU3MTQyODYsMy42MTk2NzU2OCA4Ljg1NzE0Mjg2LDQuMzQ0MjE2MjIgTDguODU3MTQyODYsNS41MTM1MTM1MSBMNS4yLDUuNTEzNTEzNTEgTDUuMiw0LjM0NDIxNjIyIEw1LjIsNC4zNDQyMTYyMiBaIE0xMi4zMzkyLDUuNTEzNTEzNTEgTDExLjY1NzE0MjksNS41MTM1MTM1MSBMMTEuNjU3MTQyOSwzLjk3ODgxMDgxIEMxMS42NTcxNDI5LDEuNzgxMTg5MTkgOS42ODM4ODU3MSwwIDcuMDI4NTcxNDMsMCBDNC4zNzMyNTcxNCwwIDIuNCwxLjc4MTE4OTE5IDIuNCwzLjk3ODgxMDgxIEwyLjQsNS41MTM1MTM1MSBMMS43MTc5NDI4Niw1LjUxMzUxMzUxIEMwLjc1NjM0Mjg1Nyw1LjUxMzUxMzUxIDAsNi4yNjQ0MzI0MyAwLDcuMTM0MjcwMjcgTDAsMTMuOTk0MTYyMiBDMCwxNC44NjMxMzUxIDAuNzU2MzQyODU3LDE1LjU2NzU2NzYgMS43MTc5NDI4NiwxNS41Njc1Njc2IEwxMi4zMzgyODU3LDE1LjU2NzU2NzYgQzEzLjMwMDgsMTUuNTY3NTY3NiAxNC4wNTcxNDI5LDE0Ljg2MzEzNTEgMTQuMDU3MTQyOSwxMy45OTQxNjIyIEwxNC4wNTcxNDI5LDcuMTM0MjcwMjcgQzE0LjA1NzE0MjksNi4yNjQ0MzI0MyAxMy4zMDA4LDUuNTEzNTEzNTEgMTIuMzM5Miw1LjUxMzUxMzUxIEwxMi4zMzkyLDUuNTEzNTEzNTEgWiIgaWQ9IkltcG9ydGVkLUxheWVycyIgc2tldGNoOnR5cGU9Ik1TU2hhcGVHcm91cCI+PC9wYXRoPiAgICAgICAgICAgIDwvZz4gICAgICAgIDwvZz4gICAgPC9nPjwvc3ZnPg==" class="lockstyle"/>' +
      '<image width="24px" height="24px" xlink:href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB3aWR0aD0iMjNweCIgaGVpZ2h0PSIxN3B4IiB2aWV3Qm94PSIwIDAgMjMgMTciIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiPiAgICAgICAgPHRpdGxlPkltcG9ydGVkIExheWVycyAyPC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPjwvZGVmcz4gICAgPGcgaWQ9IjgtQ29weS1Db3B5IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBza2V0Y2g6dHlwZT0iTVNQYWdlIj4gICAgICAgIDxnIGlkPSIxLS0tbWFpbiIgc2tldGNoOnR5cGU9Ik1TQXJ0Ym9hcmRHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTk2Mi4wMDAwMDAsIC0yMjIuMDAwMDAwKSIgc3Ryb2tlPSIjQjhCOEI4IiBzdHJva2Utd2lkdGg9IjIuNSI+ICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy0yLSstSW1wb3J0ZWQtTGF5ZXJzIiBza2V0Y2g6dHlwZT0iTVNMYXllckdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5MzkuMDAwMDAwLCAyMjIuMDAwMDAwKSI+ICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0zNy4wNTIyMjMxLDUuMjg5MDI2MTkgQzM3LjQ2MjIwNzUsNC45OTQ5OTUwMiAzNy45NTg0ODk3LDQuODIwNTc5NzQgMzguNDkzMzEyNyw0LjgyMDU3OTc0IEMzOS44NzcxNDk4LDQuODIwNTc5NzQgNDAuOTk1NjY5OSw1Ljk2NzUzNyA0MS4wNDE3NTEzLDcuNDA0OTg5OTkgQzQzLjAyNDM2NjcsNy41NzkxMTA2NiA0NC41NjgyMzE3LDkuNTk2NjcxMjQgNDQuNTY4MjMxNywxMS4yMDAyOTAxIEw0NC41NjgyMzE3LDExLjU0OTEyMDcgQzQ0LjU2ODIzMTcsMTMuMjcyOTQ0NyA0Mi43ODYxNCwxNS4wMjA2MzMgNDAuNTg2MjQ0MSwxNS4wMjA2MzMgTDI4Ljg2OTU3MSwxNS4wMjA2MzMgQzI2LjY3Mzg2NDIsMTUuMDIwNjMzIDI0Ljg5MTc3MjYsMTMuMjcyOTQ0NyAyNC44OTE3NzI2LDExLjU0OTEyMDcgTDI0Ljg5MTc3MjYsMTEuMjAwMjkwMSBDMjQuODkxNzcyNiw5Ljg3MTI1NzQ3IDI1Ljk0OTQwOTUsOC4wNDQ2MTA5MSAyNy40NDAyMTExLDcuNTkxNzc5MzQgQzI3LjQ0MDIxMTEsNy41NDQwNTA4MyAyNy40MzMyMjkxLDcuNDkyMTk3NjQgMjcuNDMzMjI5MSw3LjQ0MTIyODMxIEMyNy40MzMyMjkxLDQuNTMwNjczMjUgMjkuNjg1MzUwNiwyLjE3NTc3MjMgMzIuNDY0MTk1OSwyLjE3NTc3MjMgQzM0LjUwNzQxNTIsMi4xNzU3NzIzIDM2LjI2MzgxMywzLjQ1NDQyNDg5IDM3LjA1MjIyMzEsNS4yODkwMjYxOSBaIiBpZD0iSW1wb3J0ZWQtTGF5ZXJzLTIiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4gICAgICAgICAgICA8L2c+ICAgICAgICA8L2c+ICAgIDwvZz48L3N2Zz4=" class="routetable"/>' +
      '</g>' +
      '<g class="control-bar">' +
      '<circle class="sg-control" ' +
      'onmouseover="evt.target.parentElement.parentElement.getElementsByClassName(\'lockstyle\')[0].setAttribute(\'opacity\', \'0.5\')" ' +
      'onmouseout="evt.target.parentElement.parentElement.getElementsByClassName(\'lockstyle\')[0].setAttribute(\'opacity\', \'1\')" />' +
      '<circle class="rt-control" ' +
      'onmouseover="evt.target.parentElement.parentElement.getElementsByClassName(\'routetable\')[0].setAttribute(\'opacity\', \'0.5\')" ' +
      'onmouseout="evt.target.parentElement.parentElement.getElementsByClassName(\'routetable\')[0].setAttribute(\'opacity\', \'1\')" />' +
      '</g>' +
      '<text class="description1"/>' +
      '<text class="title"/>' +
      '</g>');

    return ContainerElement.extend({
      prebuilt_markup: prebuilt_markup,
      defaults: joint.util.defaultsDeep({
        shape: "aws.vpc",
        size: { width: 600, height: 600 },
        z: 10,
        attrs: {
          '.title': { fill: '#979797', ref: '.vpc', y: -10 },
          '.description1': { fill: '#979797', ref: '.vpc', 'font-size': 11, y: -25 },
          // If I set refs to 1 or 0 it ignores them - basically I'm setting the position to the top right of 'rect', and then using cx and cy to add padding
          '.control-bar': { width: 20, height: 20, x: -100, y: 10, ref: '.vpc', 'ref-x': 0.999999, 'ref-y': 0.00001, opacity: 2 },
          '.lockstyle': { fill: "#6A6A6A", stroke: "#222222", x: -40, y: 10 },
          '.routetable': { fill: "#6A6A6A", stroke: "#222222", x: -70, y: 10 },
          '.sg-control': { r: 12, control: "sg", cx: -28, cy: 22, cursor: "pointer", 'fill-opacity': 0 },
          '.rt-control': { r: 12, control: "rt", cx: -58, cy: 22, cursor: "pointer", 'fill-opacity': 0 },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        this.attr(".title/text", (resource.name || ""));
        this.attr(".description1/text", (resource.cidr_block || ""));
      },

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();

        var style = ResourceImages.getStyle("aws", this.attributes.shape); // VpcElement
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.aws.views.subnet', ['designer.workspace.canvases.jointjs.views.container'])
  .service('AwsSubnetView', ["ContainerView", "$rootScope", function(ContainerView, $rootScope) {
    return ContainerView.extend({
      subnet_row_height: 29,
      template: [
        '<div class="subnet-group-row">',
        '</div>'
      ].join(''),

      initialize: function() {
        ContainerView.prototype.initialize.apply(this, arguments);

        this.$box = $(_.template(this.template)());
        this.subnet_groups = {};

        // Prevent paper from handling pointerdown.
        this.$box.find('.html-element').on('mousedown click', function(evt) {
          evt.stopPropagation();
        });

        // Remove the box when the model gets removed from the graph.
        this.model.on('remove', this.removeBox, this);

        // Listen for our angular events
        $rootScope.$on("group:highlight", angular.bind(this, this.highlightSubnetGroup));
        $rootScope.$on("group:unhighlight", angular.bind(this, this.unhighlightSubnetGroups));
      },

      render: function() {
        ContainerView.prototype.render.apply(this, arguments);

        $(this.el).find(".subnetGroupContainer").append(this.$box);

        var resource = this.model.get("resource");

        var y_pos = 55;
        var height = 0;
        this.$box.empty();
        
        _.each(resource.getSubnetGroups(), function(group) {
          var el = this.buildSubnetGroupRow(group);

          this.$box.append(el);
          this.subnet_groups[group.id] = el;

          y_pos += this.subnet_row_height;
          height += this.subnet_row_height;
        }.bind(this));

        this.model.attr(".subnetGroupDisplay/y", -y_pos);
        this.model.attr(".subnetGroupDisplay/height", height);

        return this;
      },

      buildSubnetGroupRow: function(group) {
        var name = group.name;
        if(name.length > 45) {
          name = name.substr(0, 40) + ' ...';
        }

        var el = $('<span></span>');
        el.text(name);
        el.addClass(group.simple_name.replace(/\./g, "-"));
        el.on("click", function() { $rootScope.$broadcast("group:unhighlight"); $rootScope.$broadcast("resource:select", group); });
        el.on("mouseover", function() { $rootScope.$broadcast("group:highlight", group) });
        el.on("mouseout", function() { $rootScope.$broadcast("group:unhighlight") });

        // Show the image
        var svg = $('<svg><use xlink:href="' + group.image + '" /></svg>')
        el.append(svg);

        return el;
      },

      highlightSubnetGroup: function(evt, group) {
        _.each(this.subnet_groups, function(el, group_id) {
          if(group.id === group_id) {
            el.addClass("group-highlight");

            // Highlight the subnet too eh
            this.highlight();
          }
        }.bind(this));
      },

      unhighlightSubnetGroups: function(evt) {
        _.each(this.subnet_groups, function(el, group_id) {
          el.removeClass("group-highlight");
        }.bind(this));

        this.unhighlight();
      },

      updateTheme: function() {
        this.model.updateTheme();
        this.render();
      },

      removeBox: function(evt) {
        this.$box.remove();
      }
    });
  }]);

angular.module('designer.workspace.layout.infrastructure.azure.resource_group', [
  'designer.workspace.layout.infrastructure.azure.virtual_network'
])
.factory('InfrastructureLayoutAzureResourceGroup',
  ["InfrastructureLayoutAzureVirtualNetwork", function(InfrastructureLayoutAzureVirtualNetwork) {
  return {
    load: function(resource_group, environment) {

      resource_group.getData = function() {
        return {
          id: this.id,
          top: this.getTop(),
          center: this.getCenter(),
          left: this.getLeft(),
          right: this.getRight(),
          bottom: this.getBottom(),
          parent: true
        };
      };

      resource_group.getCenter = function() {
        var vnets = environment.connectedTo(this, "Resources::Azure::Network::VirtualNetwork");
        return _.map(vnets, function(vnet) { return InfrastructureLayoutAzureVirtualNetwork.load(vnet, environment).getData() });
      };

      resource_group.getTop = function() {
        var public_zones = environment.connectedTo(this, "Resources::Azure::DNS::Zone").filter((z) => z.zone_type === "Public");

        return _.map(public_zones, function(r) { return r.id });
      }

      resource_group.getLeft = function() {
        var resources = [];

        resources = resources.concat(environment.connectedTo(this, "Resources::Azure::SQL::Server"));
        resources = resources.concat(environment.connectedTo(this, "Resources::Azure::Redis::RedisCache"));
        resources = resources.concat(environment.connectedTo(this, "Resources::Azure::MariaDB::Server"));
        resources = resources.concat(environment.connectedTo(this, "Resources::Azure::Mysql::Server"));
        resources = resources.concat(environment.connectedTo(this, "Resources::Azure::Postgresql::Server"));

        return _.map(resources, function(r) { return r.id });
      };

      resource_group.getRight = function() {
        return _.map(this.getExpressRouteCircuits(), function(r) { return r.id });
      };

      resource_group.getGenericResources = function() {
        var genericUnits = environment.getResourcesByType("Resources::Azure::Generic::GlobalResource")
        genericUnits = genericUnits.filter((g) => g.resource_group_name === resource_group.name)
        return _.uniqBy(genericUnits, (gu) => gu.id);
      }
      
      resource_group.getBottom = function() {
        var resources = [];

        resources = resources.concat(this.getBatchAccounts());
        resources = resources.concat(this.getBatchPools());
        resources = resources.concat(this.getStorageAccounts());
        resources = resources.concat(this.getGenericResources());
        resources = resources.concat(this.getEventHubNamespaces());
        resources = resources.concat(this.getServicebusNamespaces());

        return _.map(resources, function(r) { return r.id })
      };

      return resource_group;
    }
  }
}]);

angular.module('designer.workspace.layout.infrastructure.azure.subnet', [])
.factory('InfrastructureLayoutAzureSubnet',
  [function() {
    return {
      load: function(subnet, environment) {

        subnet.getData = function() {
          var resources = [];
          resources = resources.concat(this.getVirtualMachines());
          resources = resources.concat(this.getBatchPools());
          resources = resources.concat(this.getPrivateEndpoints());

          return {
            id: this.id,
            name: this.name,
            resources: _.map(resources, function(r) { return r.id }),
            load_balancers: _.map(this.getLoadBalancers(), function(r) { return r.id }),
            custom_class: "subnet-azure"
          }
        };

        return subnet;
      }
    }
  }]);

angular.module('designer.workspace.layout.infrastructure.azure.virtual_network', [
  'designer.workspace.layout.infrastructure.azure.subnet'
])
.factory('InfrastructureLayoutAzureVirtualNetwork',
  ["InfrastructureLayoutAzureSubnet", function(InfrastructureLayoutAzureSubnet) {
    return {
      load: function(virtual_network, environment) {

        virtual_network.getData = function() {
          var sortable_cidr = function(cidr) {
            var parts = cidr.replace("/", ".").split(".");

            return _.map(parts, function(p) { return p.padStart(3, "0") }).join("");
          }

          // In some very rare cases subnets can have no address prefix, which isn't allowed and causes a looooot of issues with display
          var subnet_list = _.sortBy(_.reject(this.getSubnets(), function(s) { return !s.address_prefix }), [function(s) { return sortable_cidr(s.address_prefix) }]);
          var rows = [];
          var drawn_lbs = [];
          var subnet_size = subnet_list.length;

          _.each(_.range(0, subnet_size, 2), function(subnet_row) {
            var col = [];
            var lb_row = { type: "load_balancer", resources: [] };

            _.each([0,1], function(subnet_col) {
              var index = subnet_row + subnet_col;
              if(!subnet_list[index]) return;

              var subnet_data = InfrastructureLayoutAzureSubnet.load(subnet_list[index], environment).getData();
              col.push(subnet_data);

              var lbs = _.reject(subnet_data.load_balancers, function(lb) { return _.includes(drawn_lbs, lb) });
              lb_row.resources = lb_row.resources.concat(lbs);
              drawn_lbs = drawn_lbs.concat(lbs);
            });

            if(lb_row.resources.length)
              rows.push(lb_row);
            rows.push({ type: "subnet", columns: col });
          });

          return {
            id: this.id,
            center: rows,
            top: this.getTop(),
            right: this.getRight(),
            left: [],
            bottom: []
          };
        };

        virtual_network.getTop = function() {
          var left = [];
          var right = [];
          
          left = left.concat(this.getPrivateDNSZones());

          right = right.concat(this.getVirtualNetworkGateways());
          right = right.concat(this.getLocalNetworkGateways());
          right = right.concat(this.getFirewalls());

          return {
            left: _.map(left, function(r) { return r.id }),
            right: _.map(right, function(r) { return r.id })
          }
        };

        virtual_network.getPrivateDNSZones = function() {
          return environment.connectedTo(this, "Resources::Azure::DNS::Zone").filter((z) => z.zone_type !== "Public");
        };

        virtual_network.getRight = function() {
          var resources = [];

          resources = resources.concat(this.getVirtualNetworkPeeringConnections());

          return _.map(resources, function(r) { return r.id })
        };

        return virtual_network;
      }
    }
  }]);

angular.module('designer.workspace.layout.infrastructure.gcp.network', [
  'designer.workspace.layout.infrastructure.gcp.subnetwork'
])
.factory('InfrastructureLayoutGCPNetwork',
  ["InfrastructureLayoutGCPSubnetwork", function(InfrastructureLayoutGCPSubnetwork) {
    return {
      load: function(network, environment) {

        network.getData = function() {
          var sortable_cidr = function(cidr) {
            var parts = cidr.replace("/", ".").split(".");

            return _.map(parts, function(p) { return p.padStart(3, "0") }).join("");
          }
          var all_subnets = _.sortBy(_.map(this.getSubnetworks(), function(r) {
            return InfrastructureLayoutGCPSubnetwork.load(r, environment).getData();
          }), [function(s) { return sortable_cidr(s.cidr_block) }]);
          var bottom_row_resources = this.getBottomRowResources();

          // Ignoring regions for the moment - empty subnets can be regional so I think we'll need it though
          var zones = _.uniq(_.compact(_.flatten(_.map(all_subnets, function(subnet) { return subnet.zones })).concat(
            _.map(bottom_row_resources, function(r) { return r.zone })
          ))).sort();

          var rows = [];
          var count = 0;
          while(all_subnets.length) {
            if(++count>500) {
              throw "Too many loops in GCP layout";
            }

            var row = { type: "subnet", columns: [] };
            var parsed_zones = [];
            var added_to_zones = [];
            var current_subnet = null;

            _.each(zones, function(zone) {
              if(!current_subnet) {
                // If we don't have a subnet find one that isn't in any previously parsed zones and IS in this zone
                current_subnet = _.find(all_subnets, function(s) { return _.includes(s.zones, zone) &&  _.intersection(s.zones, parsed_zones).length === 0 });
                if(current_subnet)
                  added_to_zones.push(zone);
                row.columns.push(angular.copy(current_subnet));
              }
              else if(_.includes(current_subnet.zones, zone)) {
                // If the last column was nil we've skipped it, so add another column of this subnet
                if(!row.columns[row.columns.length - 1]) {
                  row.columns.push(angular.copy(current_subnet))
                }
                else {
                  row.columns[row.columns.length - 1].colspan++;
                }

                added_to_zones.push(zone);
              }
              else {
                // We have a current subnet but it skips this zone, so add an empty column
                row.columns.push(null);
              }

              // If we've added the subnet to all zones close it off
              if (current_subnet && (added_to_zones.length >= current_subnet.zones.length)) {
                added_to_zones = [];
                all_subnets = _.reject(all_subnets, function(s) { return s.id === current_subnet.id });
                current_subnet = null;
              }

              // Add zones to the subnet so they can be filtered after
              var last_column = row.columns[row.columns.length-1];
              if (last_column) {
                if(!last_column["instanced_zones"])
                  last_column["instanced_zones"] = [];
                last_column["instanced_zones"].push(zone)
              }

              parsed_zones.push(zone);
            });

            // Filter the resources into zone groups then clean up the data
            _.each(row.columns, function(column) {
              if(!column) return;

              if(column.instanced_zones.length > 1) {
                column.zone_columns = [];
                _.each(column.resources_map, function(z, region) {
                  _.each(z, function(resources, zone) {
                    if(_.includes(column.instanced_zones, zone))
                      column.zone_columns.push({
                        name: zone,
                        resources: resources
                      });
                  });
                });

                column.zone_columns = _.sortBy(column.zone_columns, ["name"]);
              }
              else {
                column.resources = [];
                _.each(column.resources_map, function(z, region) {
                  _.each(z, function(resources, zone) {
                    if(_.includes(column.instanced_zones, zone))
                      column.resources = resources;
                  });
                })
              }
            });

            rows.push(row);
          }

          // Add in some load balancer rows, this is the same logic as in AWS. Can you dig it?
          var lbsubnet_map = {};
          _.each(this.getLoadBalancers(), function(lb) {
            _.each(environment.connectedTo(lb, "Resources::GCP::Compute::Subnetwork"), function(s) {
              if(!lbsubnet_map[s.id])
                lbsubnet_map[s.id] = [];
              lbsubnet_map[s.id].push(lb.id);
            });
          });

          // Add a spacer row because the css bunches it all up ... ewwww
          // TODO: we shouldn't need this now we're using chrome, yeah?
          if (rows.length > 0) {
            rows.push({ type: "subnet", columns: _.fill(Array(zones.length), null) })
          }

          var final_rows = [];
          var drawn_lbs = [];
          _.each(rows, function(row) {
            var lb_row = { type: "load_balancer", resources: [] };

            _.each(row.columns, function(subnet_info) {
              if(!subnet_info) return;

              var lbs = _.reject((lbsubnet_map[subnet_info.id] || []), function(lb) { return _.includes(drawn_lbs, lb) });
              lb_row.resources = lb_row.resources.concat(lbs);
              drawn_lbs = drawn_lbs.concat(lbs);
            });

            if(lb_row.resources.length)
              final_rows.push(lb_row);
            final_rows.push(row);
          });

          // Add a row for the remaining resources, if we have any
          if(bottom_row_resources.length) {
            var row = { type: "additional", zone_columns: [] };

            _.each(zones, function(zone) {
              row.zone_columns.push({
                name: zone,
                resources: _.map(_.filter(bottom_row_resources, function(r) { return r.zone === zone }), function(r) { return r.id })});
            });

            row.zone_columns = _.sortBy(row.zone_columns, ["name"]);

            final_rows.push(row);
          }

          return {
            id: this.id,
            center: final_rows,
            top: this.getTop(),
            right: this.getRight(),
            left: this.getLeft()
          };
        };

        network.getTop = function() {
          var left = [];
          var right = [];

          left = left.concat(this.getManagedZones());

          right = right.concat(this.getRouters());
          right = right.concat(this.getVPNGateways());
          right = right.concat(this.getTargetVPNGateways());
          right = right.concat(this.getExternalVPNGateways());

          return {
            left: _.map(left, function(r) { return r.id }),
            right: _.map(right, function(r) { return r.id })
          }
        };

        network.getRight = function() {
          var resources = [];

          resources = resources.concat(this.getInterconnects());
          resources = resources.concat(this.getExternalVPNGateways());

          return _.map(resources, function(r) { return r.id });
        };

        network.getLeft = function() {
          var resources = [];

          resources = resources.concat(this.getBuckets());

          return _.map(resources, function(r) { return r.id });
        };

        network.getBottomRowResources = function() {
          var resources = [];

          resources = resources.concat(this.getSQLInstances());
          resources = resources.concat(this.getMemoryStoreInstances());
          resources = resources.concat(this.getInstancesOutsideSubnets());

          return resources;
        };

        network.getGenericResources = function() {
            var genericUnits = environment.getResourcesByType("Resources::GCP::Generic::GlobalResource");
            return _.uniqBy(genericUnits, (gu) => gu.id).map((g) => g.id);
        }

        network.getLoadBalancers = function() {
          var lbs = [];

          _.each(["Resources::GCP::Compute::URLMap", "Resources::GCP::Compute::RegionURLMap", "Resources::GCP::Compute::TargetPool"], function(type) {
            lbs = lbs.concat(environment.connectedTo(this, type));
          }.bind(this));

          // Only show backend services if they aren't linked to a URL map
          var backend_services = environment.connectedTo(this, "Resources::GCP::Compute::BackendService").concat(
            environment.connectedTo(this, "Resources::GCP::Compute::RegionBackendService")
          );
          
          _.each(backend_services, function(bes) {
            var maps = environment.connectedTo(bes, "Resources::GCP::Compute::URLMap").concat(
              environment.connectedTo(bes, "Resources::GCP::Compute::RegionURLMap")
            );

            if(!maps.length)
              lbs.push(bes);
          });

          return _.uniq(lbs);
        };

        network.getInstancesOutsideSubnets = function() {
          return _.filter(environment.connectedTo(this, "Resources::GCP::Compute::Instance"), function(instance) {
            return environment.connectedTo(instance, "Resources::GCP::Compute::Subnetwork").length === 0;
          });
        };

        return network;
      }
    }
  }]);

angular.module('designer.workspace.layout.infrastructure.gcp.subnetwork', [])
.factory('InfrastructureLayoutGCPSubnetwork',
  [function() {
    return {
      load: function(subnet, environment) {

        subnet.getData = function() {
          var resources = this.getInstances().concat(this.getNATGateways());

          // Remember zones and regions can be nil :O
          var zones = _.uniq(_.map(resources, function(r) { return r.zone || " " })).sort();
          var regions = _.uniq(_.map(resources, function(r) { return r.region || " " })).sort();

          if(zones.length === 0)
            zones = [" "];

          var resource_map = {};
          _.each(resources, function(resource) {
            var region = resource.region || " ";
            var zone = resource.zone || " ";

            if(!resource_map[region]) resource_map[region] = {};
            if(!resource_map[region][zone]) resource_map[region][zone] = [];

            resource_map[region][zone].push(resource.id);
          });

          return {
            id: this.id,
            name: this.name,
            resources_map: resource_map,
            regions: regions,
            zones: zones,
            cidr_block: this.ip_cidr_range,
            colspan: 1
          }
        };

        return subnet;
      }
    }
  }]);

angular.module('designer.workspace.layout.infrastructure.ibm.global', [
  "designer.workspace.layout.infrastructure.ibm.vpc"
])
.factory('InfrastructureLayoutIBMGlobal', ["InfrastructureLayoutIBMVPC", function(InfrastructureLayoutIBMVPC) {
  return {
    load: function(environment) {
      var layout = {};

      layout.getData = function() {
        var center = this.getVPCs();
        var networkResourceIDs = [];

        // TODO: this is yuck, but whatevs - we need to know what's already displayed so we don't add it here
        _.each(center, function(vpc) {
          _.each(vpc.center, function(row) {
            if (row.type === "load_balancer") {
              networkResourceIDs = networkResourceIDs.concat(row.resources);
            }
            else {
              _.each(row.columns, function(col) {
                networkResourceIDs = networkResourceIDs.concat(col.resources);
              });
            }
          });

          networkResourceIDs = networkResourceIDs.concat(vpc.left).concat(vpc.right).concat(vpc.top.left).concat(vpc.top.right);
        });

        return {
          id: null,
          top: _.reject(this.getTopRow(), function (r) {
            return _.includes(networkResourceIDs, r)
          }),
          center: center,
          parent: true
        };
      };

      layout.getVPCs = function() {
        var vpcs = _.filter(environment.facet.resources, function(r) { return r.type === 'Resources::IBM::EC2::VPC' });

        return _.map(vpcs, function(vpc) { return InfrastructureLayoutIBMVPC.load(vpc, environment).getData() });
      };

      layout.getTopRow = function() {
        var values = [];
        var types = [
          "Resources::IBM::S3::Bucket",
          "Resources::IBM::SQS::Queue",
          "Resources::IBM::APIGateway::RestAPI",
          "Resources::IBM::CloudFront::Distribution",
          "Resources::IBM::CloudFront::StreamingDistribution",
          "Resources::IBM::DynamoDB::Table",
          "Resources::IBM::ElasticBeanstalk::Environment",
          "Resources::IBM::Lambda::Function",
          "Resources::IBM::DirectoryService::Directory",
          "Resources::IBM::EFS::FileSystem",
          "Resources::IBM::RDS::DBInstance",
          "Resources::IBM::WorkSpaces::WorkSpace",
          "Resources::IBM::DirectConnect::DirectConnectGateway",
          "Resources::IBM::Route53::HostedZone",
          "Resources::IBM::EC2::CustomerGateway",
          "Resources::IBM::EC2::TransitGateway",
          "Resources::IBM::WAF::WebACL"
        ];

        _.each(types, function(type) { values = values.concat(environment.getResourcesByType(type)) });

        return _.map(values, function(r) { return r.id });
      };

      return layout;
    }
  }
}]);

angular.module('designer.workspace.layout.infrastructure.ibm.subnet', [])
.factory('InfrastructureLayoutIBMSubnet', [function() {
  return {
    load: function(subnet, environment) {

      subnet.getData = function() {
        var resources = [];
        var subnet_groups = [];
        var instances = this.getInstances();
        var autoscale_groups = [];

        resources = resources.concat(this.getNATGateways());

        _.each(instances, function(instance) {
          // Only add it if it's not part of an ASG
          var asgs = environment.connectedTo(instance, "Resources::IBM::AutoScaling::AutoScalingGroup");

          if (asgs.length) {
            autoscale_groups = autoscale_groups.concat(asgs);
          }
          else {
            resources.push(instance);
          }
        })

        resources = resources.concat(_.uniq(autoscale_groups));
        resources = resources.concat(this.getRDSInstances());
        resources = resources.concat(this.getRedshiftNodes());
        resources = resources.concat(this.getElasticacheNodes());
        resources = resources.concat(this.getEFSFileSystems());
        resources = resources.concat(this.getWorkSpaces());
        resources = resources.concat(this.getDirectories());
        resources = resources.concat(this.getLambdas());

        subnet_groups = subnet_groups.concat(this.getDBSubnetGroups());
        subnet_groups = subnet_groups.concat(this.getClusterSubnetGroups());
        subnet_groups = subnet_groups.concat(this.getCacheSubnetGroups());

        return {
          id: this.id,
          az: this.availability_zone,
          name: this.name,
          cidr_block: this.cidr,
          resources: _.map(resources, function(r) { return r.id }),
          subnet_groups: _.map(subnet_groups, function(r) { return r.id })
        }
      };

      subnet.getInstances = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::Instance");
      };

      subnet.getDBSubnetGroups = function() {
        return environment.connectedTo(this, "Resources::IBM::RDS::DBSubnetGroup");
      };

      subnet.getClusterSubnetGroups = function() {
        return environment.connectedTo(this, "Resources::IBM::Redshift::ClusterSubnetGroup");
      };

      subnet.getCacheSubnetGroups = function() {
        return environment.connectedTo(this, "Resources::IBM::ElastiCache::CacheSubnetGroup");
      };

      subnet.getRDSInstances = function() {
        return environment.connectedTo(this, "Resources::IBM::RDS::DBInstance");
      };

      subnet.getRedshiftNodes = function() {
        return environment.connectedTo(this, "Resources::IBM::Redshift::ClusterNode");
      };

      subnet.getElasticacheNodes = function() {
        return environment.connectedTo(this, "Resources::IBM::ElastiCache::CacheNode");
      };

      subnet.getInstances = function() {
        var instances = environment.connectedTo(this, "Resources::IBM::EC2::Instance");
        var nics = environment.connectedTo(this, "Resources::IBM::EC2::NetworkInterface");

        _.each(nics,  function(nic) {
          instances = instances.concat(environment.connectedTo(nic, "Resources::IBM::EC2::Instance"))
        });

        return _.uniq(instances);
      };

      subnet.getNATGateways = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::NATGateway");
      };

      subnet.getRouteTables = function() {
        return environment.connectedTo(this, "Resources::IBM::EC2::RouteTable");
      };

      subnet.getEFSFileSystems = function() {
        return environment.connectedTo(this, "Resources::IBM::EFS::FileSystem");
      };

      subnet.getWorkSpaces = function() {
        return environment.connectedTo(this, "Resources::IBM::WorkSpaces::WorkSpace");
      };

      subnet.getDirectories = function() {
        return environment.connectedTo(this, "Resources::IBM::DirectoryService::Directory");
      };

      subnet.getLambdas = function() {
        return environment.connectedTo(this, "Resources::IBM::Lambda::Function");
      };

      subnet.isPublic = function() {
        var route_tables = this.getRouteTables();
        var pub = false;

        _.each(route_tables, function(route_table) {
          var connections = _.filter(route_table.connections, function(c) { return c.remote_resource_type === "Resources::IBM::EC2::InternetGateway" });

          _.each(connections, function(c) {
            if (c["data"]["destination_cidr_block"] === "0.0.0.0/0")
              pub = true;
          });
        });

        return pub;
      };

      return subnet;
    }
  }
}]);

angular.module('designer.workspace.layout.infrastructure.ibm.vpc', [
  'designer.workspace.layout.infrastructure.ibm.subnet'
])
.factory('InfrastructureLayoutIBMVPC', ["InfrastructureLayoutIBMSubnet", function(InfrastructureLayoutIBMSubnet) {
  return {
    load: function(vpc, environment) {

      vpc.getData = function() {
        var subnets = _.map(environment.connectedTo(this, "Resources::IBM::EC2::Subnet"), function(s) { return InfrastructureLayoutIBMSubnet.load(s, environment) });
        var azs = _.uniq(_.map(subnets, function(s) { return s.availability_zone })).sort();

        var sortable_cidr = function(cidr) {
          var parts = cidr.replace("/", ".").split(".");

          return _.map(parts, function(p) { return p.padStart(3, "0") }).join("");
        }

        var public_rows = _.sortBy(_.filter(subnets, function(s) { return s.isPublic() }), [function(s) { return sortable_cidr(s.cidr_block) }]);
        var private_rows = _.sortBy(_.reject(subnets, function(s) { return s.isPublic() }), [function(s) { return sortable_cidr(s.cidr_block) }]);

        var chunks = [
          { type: "subnet", resources: public_rows },
          { type: "subnet", resources: private_rows }
        ];

        _.each(chunks, function(chunk) {
          chunk["azs"] = _.map(azs, function(az) { return { az: az } });
          _.each(chunk["azs"], function(az) {
            az["resources"] = _.filter(chunk.resources, function(r) { return r.availability_zone === az.az });
          });

          // Turn rows into columns
          chunk["transpose"] = _.zip.apply(_, _.map(chunk["azs"], function(az) { return az["resources"] }))
          delete chunk["resources"];
          delete chunk["azs"];
        }, this);

        var rows = [];
        _.each(chunks, function(chunk) {
          _.each(chunk["transpose"], function(row) {
            // Remove nulls
            row = _.compact(row);

            var cols = [];
            _.each(azs, function(az) {
              var col = _.find(row, function(r) { return r.availability_zone === az });

              // Next column if this is empty
              if (!col) {
                cols.push({ az: az, resources: [], subnet_groups: [] });
              }
              else {
                // Get resources
                var column_subnet = _.find(subnets, function(s) { return s.id === col.id });
                cols.push(column_subnet.getData());
              }
            }, this);

            rows.push({ type: "subnet", columns: cols });

          }, this);
        }, this);

        // Add in some ELB rows eh dawgs whatever
        var elbsubnet_map = {};
        _.each(this.getLoadBalancers(), function(elb) {
          var elb_subnets = environment.connectedTo(elb, "Resources::IBM::EC2::Subnet");
          _.each(elb_subnets, function(s) {
            if(!elbsubnet_map[s.id])
              elbsubnet_map[s.id] = [];
            elbsubnet_map[s.id].push(elb.id);
          })
        }, this);

        var final_rows = [];
        var drawn_lbs = [];
        _.each(rows, function(row) {
          var lb_row = { type: "load_balancer", resources: [] };

          _.each(row.columns, function(subnet_info) {
            var lbs = _.reject((elbsubnet_map[subnet_info["id"]] || []), function(lb) { return _.includes(drawn_lbs, lb) });
            lb_row.resources = lb_row.resources.concat(lbs);
            drawn_lbs = drawn_lbs.concat(lbs);
          });

          if(lb_row.resources.length > 0)
            final_rows.push(lb_row);
          final_rows.push(row);
        });

        return {
          id: this.id,
          center: final_rows,
          top: this.loadTop(),
          right: this.loadRight(),
          left: this.loadLeft(),
          bottom: []
        };
      };

      vpc.getLoadBalancers = function() {
        var lb_types = [
          "Resources::IBM::ElasticLoadBalancing::LoadBalancer",
          "Resources::IBM::ElasticLoadBalancingV2::ApplicationLoadBalancer",
          "Resources::IBM::ElasticLoadBalancingV2::NetworkLoadBalancer"
        ];
        var load_balancers = [];
        var all_lbs = _.filter(environment.facet.resources, function(r) { return _.includes(lb_types, r.type) });
        _.each(all_lbs, function(lb) {
          var vpc_connection = environment.connectedTo(lb, "Resources::IBM::EC2::VPC");
          if(vpc_connection.length) {
            // Add it if it's connected to this VPC
            if(vpc_connection[0].id === this.id)
              load_balancers.push(lb)
          }
          else {
            // No VPC connection, check if it has a subnet connection
            var subnets = environment.connectedTo(lb, "Resources::IBM::EC2::Subnet");
            var connected = false;

            while(!connected && subnets.length) {
              var subnet = subnets.shift;
              vpc_connection = environment.connectedTo(subnet, "Resources::IBM::EC2::VPC");
              if(vpc_connection.length) {
                // Add it if it's connected to this VPC
                if(vpc_connection[0].id === this.id) {
                  load_balancers.push(lb);
                  connected = true;
                }
              }
            }
          }
        }.bind(this), true);

        return _.sortBy(load_balancers, ['type','name']);
      };

      vpc.loadTop = function() {
        var left = [];
        var right = [];

        right = right.concat(this.getInternetGateways());
        right = right.concat(this.getEgressOnlyInternetGateways());
        right = right.concat(this.getVPNGateways());
        right = right.concat(this.getCustomerGateways());
        right = right.concat(this.getWAFWebACLs());
        right = right.concat(this.getTransitGateways());

        left = left.concat(this.getHostedZones());
        left = left.concat(this.getCloudFrontDistributions());

        return {
          left: _.map(left, function(r) { return r.id }),
          right: _.map(right, function(r) { return r.id })
        }
      };

      vpc.loadRight = function() {
        var resources = [];

        resources = resources.concat(this.getVPCEndpoints());
        resources = resources.concat(this.getDirectConnectGateways());
        resources = resources.concat(this.getVPCPeeringConnections());

        return _.map(resources, function(r) { return r.id });
      };

      vpc.loadLeft = function() {
        var resources = [];

        resources = resources.concat(this.getS3Buckets());
        resources = resources.concat(this.getAPIGateways());
        resources = resources.concat(this.getWorkSpaces());
        resources = resources.concat(this.getElasticBeanstalkEnvironments());

        // Get buckets connected to the VPC endpoint
        _.each(this.getVPCEndpoints(), function(vpce) {
          resources = resources.concat(environment.connectedTo(vpce, "Resources::IBM::S3::Bucket"));
        })

        return _.uniq(_.map(resources, function(r) { return r.id }));
      };

      return vpc;
    }
  }
}]);

angular.module('designer.workspace.views.infrastructure.azure.shapes.resource-group', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('AzureResourceGroupElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    return ContainerElement.extend({
      defaults: joint.util.defaultsDeep({
        shape: "azure.resource-group",
        size: { width: 200, height: 200 },
        z: 10,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        var name = resource.name || "";
        // var desc = resource.address_space_prefix || "";

        this.attr(".title/text", name);
        // this.attr(".description1/text", desc);
      },

      updateTheme: function() {
        var style = ResourceImages.getStyle("azure", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.azure.shapes.subnet', ['designer.workspace.canvases.jointjs.shapes.container', 'designer.workspace.views.infrastructure.azure.views.subnet'])
  .service('AzureSubnetElement', ["ContainerElement", "AzureSubnetView", "ResourceImages", function(ContainerElement, AzureSubnetView, ResourceImages) {
    var prebuilt_markup = V('<g>' +
      '<g class="scalable">' +
      '<rect class="mainRect"/>' +
      '</g>' +
      '<foreignObject class="securityGroupDisplay">' +
      '<div class="securityGroupContainer" xmlns="http://www.w3.org/1999/xhtml">' +
      '</div>' +
      '</foreignObject>' +
      '<text class="description1"/>' +
      '<text class="title"/>' +
      '</g>');

    return ContainerElement.extend({
      view: AzureSubnetView,
      prebuilt_markup: prebuilt_markup,
      markup: "  ",
      defaults: joint.util.defaultsDeep({
        shape: "azure.subnet",
        size: { width: 200, height: 200 },
        z: 20,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 },
          '.securityGroupDisplay': { ref: '.mainRect', 'ref-x': 0.99999999, 'ref-y': 0, x: -48, y: 8, width: "40px", height: "80px" }
        }
      }, ContainerElement.prototype.defaults),

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();
        var style = ResourceImages.getStyle("azure", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      },

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        var name = resource.name || "";
        var desc = resource.address_prefix || "";

        this.attr(".title/text", name);
        this.attr(".description1/text", desc);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.azure.shapes.virtual-network', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('AzureVirtualNetworkElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    return ContainerElement.extend({
      defaults: joint.util.defaultsDeep({
        shape: "azure.virtual-network",
        size: { width: 200, height: 200 },
        z: 15,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        var name = resource.name || "";
        var desc = resource.address_space_prefix || "";

        this.attr(".title/text", name);
        this.attr(".description1/text", desc);
      },

      updateTheme: function() {  
        var style = ResourceImages.getStyle("azure", this.attributes.shape); // VpcElement
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.azure.views.subnet', ['designer.workspace.canvases.jointjs.views.container'])
  .service('AzureSubnetView', ["ContainerView", "$rootScope", function(ContainerView, $rootScope) {
    return ContainerView.extend({
      template: [
        '<div class="security-group-icon">',
        '</div>'
      ].join(''),

      initialize: function() {
        ContainerView.prototype.initialize.apply(this, arguments);

        this.$box = $(_.template(this.template)());
        this.subnet_groups = {};

        // Prevent paper from handling pointerdown.
        this.$box.find('.html-element').on('mousedown click', function(evt) {
          evt.stopPropagation();
        });

        // Remove the box when the model gets removed from the graph.
        this.model.on('remove', this.removeBox, this);

        // Listen for our angular events
        $rootScope.$on("group:highlight", angular.bind(this, this.highlightSubnetGroup));
        $rootScope.$on("group:unhighlight", angular.bind(this, this.unhighlightSubnetGroups));
      },

      render: function() {
        ContainerView.prototype.render.apply(this, arguments);

        $(this.el).find(".securityGroupContainer").append(this.$box);

        var resource = this.model.get("resource");
        var security_groups = resource.getSecurityGroups();
        var route_tables = resource.getRouteTables();

        if(security_groups.length > 0) {
          this.addResourceIcon(security_groups[0]);
        }

        if(route_tables.length > 0) {
          this.addResourceIcon(route_tables[0]);
        }

        return this;
      },

      addResourceIcon: function(resource) {
        var el = $('<span></span>');

        // Show the image
        var svg = $('<svg><use xlink:href="' + resource.image + '" /></svg>')
        el.append(svg);

        this.$box.append(el);
      },

      removeBox: function(evt) {
        this.$box.remove();
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.ibm.shapes.availability-zone', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('IBMAZElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    return ContainerElement.extend({
      selectBorderColor: "#FF9900",
      defaults: joint.util.defaultsDeep({
        shape: "ibm.availability-zone",
        size: { width: 200, height: 200 },
        z: 14,
        attrs: {
          '.title': { fill: '#FF9900', y: -10 },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#FFAD32', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, rx: 5, ry: 5, fill: "#F4F8FA" }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");
        this.attr(".title/text", (resource.name || ""));
      },

      updateTheme: function() {
        var style = ResourceImages.getStyle("ibm", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.ibm.shapes.subnet',
  ['designer.workspace.canvases.jointjs.shapes.container', 'designer.workspace.views.infrastructure.ibm.views.subnet'])
  .service('IBMSubnetElement', ["ContainerElement", "IBMSubnetView", "ResourceImages", function(ContainerElement, IBMSubnetView, ResourceImages) {

    return ContainerElement.extend({
      defaults: joint.util.defaultsDeep({
        shape: "ibm.subnet",
        size: { width: 200, height: 200 },
        z: 20,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 1, rx: 5, ry: 5, fill: "#FFFFFF" }
        }
      }, ContainerElement.prototype.defaults),

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();
        var style = ResourceImages.getStyle("ibm", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      },

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        var name = resource.name || "";
        var desc = resource.cidr_block || "";

        if(name !== resource.provider_id) {
          desc = resource.provider_id + " - " + desc;
        }

        this.attr(".title/text", name);
        this.attr(".description1/text", desc);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.ibm.shapes.vpc', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('IBMVpcElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {

    return ContainerElement.extend({
      defaults: joint.util.defaultsDeep({
        shape: "ibm.vpc",
        size: { width: 600, height: 600 },
        z: 10,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        this.attr(".title/text", (resource.name || ""));
        this.attr(".description1/text", (resource.cidr_block || ""));
      },

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();

        var style = ResourceImages.getStyle("ibm", this.attributes.shape); // VpcElement
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.ibm.views.subnet', ['designer.workspace.canvases.jointjs.views.container'])
  .service('IBMSubnetView', ["ContainerView", "$rootScope", function(ContainerView, $rootScope) {
    return ContainerView.extend({
      subnet_row_height: 29,
      template: [
        '<div class="subnet-group-row">',
        '</div>'
      ].join(''),

      initialize: function() {
        ContainerView.prototype.initialize.apply(this, arguments);

        this.$box = $(_.template(this.template)());
        this.subnet_groups = {};

        // Prevent paper from handling pointerdown.
        this.$box.find('.html-element').on('mousedown click', function(evt) {
          evt.stopPropagation();
        });

        // Remove the box when the model gets removed from the graph.
        this.model.on('remove', this.removeBox, this);

        // Listen for our angular events
        $rootScope.$on("group:highlight", angular.bind(this, this.highlightSubnetGroup));
        $rootScope.$on("group:unhighlight", angular.bind(this, this.unhighlightSubnetGroups));
      },

      render: function() {
        ContainerView.prototype.render.apply(this, arguments);

        $(this.el).find(".subnetGroupContainer").append(this.$box);

        var resource = this.model.get("resource");

        var y_pos = 55;
        var height = 0;
        this.$box.empty();
        
        _.each(resource.getSubnetGroups(), function(group) {
          var el = this.buildSubnetGroupRow(group);

          this.$box.append(el);
          this.subnet_groups[group.id] = el;

          y_pos += this.subnet_row_height;
          height += this.subnet_row_height;
        }.bind(this));

        this.model.attr(".subnetGroupDisplay/y", -y_pos);
        this.model.attr(".subnetGroupDisplay/height", height);

        return this;
      },

      buildSubnetGroupRow: function(group) {
        var name = group.name;
        if(name.length > 45) {
          name = name.substr(0, 40) + ' ...';
        }

        var el = $('<span></span>');
        el.text(name);
        el.addClass(group.simple_name.replace(/\./g, "-"));
        el.on("click", function() { $rootScope.$broadcast("group:unhighlight"); $rootScope.$broadcast("resource:select", group); });
        el.on("mouseover", function() { $rootScope.$broadcast("group:highlight", group) });
        el.on("mouseout", function() { $rootScope.$broadcast("group:unhighlight") });

        // Show the image
        var svg = $('<svg><use xlink:href="' + group.image + '" /></svg>')
        el.append(svg);

        return el;
      },

      highlightSubnetGroup: function(evt, group) {
        _.each(this.subnet_groups, function(el, group_id) {
          if(group.id === group_id) {
            el.addClass("group-highlight");

            // Highlight the subnet too eh
            this.highlight();
          }
        }.bind(this));
      },

      unhighlightSubnetGroups: function(evt) {
        _.each(this.subnet_groups, function(el, group_id) {
          el.removeClass("group-highlight");
        }.bind(this));

        this.unhighlight();
      },

      updateTheme: function() {
        this.model.updateTheme();
        this.render();
      },

      removeBox: function(evt) {
        this.$box.remove();
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.gcp.shapes.network', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('GCPNetworkElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    return ContainerElement.extend({
      defaults: joint.util.defaultsDeep({
        shape: "gcp.network",
        size: { width: 200, height: 200 },
        z: 10,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 }
        }
      }, ContainerElement.prototype.defaults),


      updateContainerText: function(paper) {
        var resource = this.get("resource");

        this.attr(".title/text", (resource.name || ""));
        this.attr(".description1/text", (resource.i_pv4_range || ""));
      },

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();

        var style = ResourceImages.getStyle("gcp", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.gcp.shapes.subnetwork', ['designer.workspace.canvases.jointjs.shapes.container', 'designer.workspace.views.infrastructure.gcp.views.subnetwork'])
  .service('GCPSubnetworkElement', ["ContainerElement", "GCPSubnetworkView", "ResourceImages", function(ContainerElement, GCPSubnetworkView, ResourceImages) {
    var prebuilt_markup = V('<g>' +
      '<g class="scalable">' +
      '<rect class="mainRect"/>' +
      '</g>' +
      '<text class="description1"/>' +
      '<text class="title"/>' +
      '</g>');

    return ContainerElement.extend({
      view: GCPSubnetworkView,
      prebuilt_markup: prebuilt_markup,
      markup: " ",
      defaults: joint.util.defaultsDeep({
        shape: "gcp.subnetwork",
        size: { width: 200, height: 200 },
        z: 20,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#B8B8B8', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 },
        }
      }, ContainerElement.prototype.defaults),

      updateTheme: function() {
        var resource = this.get("resource");
        resource.setImageUrl();
        var style = ResourceImages.getStyle("gcp", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      },

      updateContainerText: function(paper) {
        var resource = this.get("resource");

        var name = resource.name || "";
        var desc = resource.ip_cidr_range || "";

        this.attr(".title/text", name);
        this.attr(".description1/text", desc);
      }
    });
  }]);

angular.module('designer.workspace.views.infrastructure.gcp.shapes.zone', ['designer.workspace.canvases.jointjs.shapes.container'])
  .service('GCPZoneElement', ["ContainerElement", "ResourceImages", function(ContainerElement, ResourceImages) {
    return ContainerElement.extend({
      defaults: joint.util.defaultsDeep({
        shape: "gcp.zone",
        size: { width: 200, height: 200 },
        z: 14,
        attrs: {
          '.title': { fill: '#979797' },
          '.description1': { fill: '#979797' },
          '.description2': { fill: '#979797' },
          '.mainRect': { stroke: '#000077', "stroke-width": 1, width: 600, height: 600, 'fill-opacity': 0, rx: 5, ry: 5 }
        }
      }, ContainerElement.prototype.defaults),

      updateContainerText: function(paper) {
        var resource = this.get("resource");
        this.attr(".title/text", (resource.name || ""));
      },

      updateTheme: function() {
        var style = ResourceImages.getStyle("gcp", this.attributes.shape);
        this.attr(".mainRect", style);
        this.attr(".title/fill", style["stroke"]);
        this.attr(".description1/fill", style["stroke"]);
      }
    });
  }]);


angular.module('designer.workspace.views.infrastructure.gcp.views.subnetwork', ['designer.workspace.canvases.jointjs.views.container'])
  .service('GCPSubnetworkView', ["ContainerView", "$rootScope", function(ContainerView, $rootScope) {
    return ContainerView.extend({
      template: [
        '<div class="security-group-icon">',
        '</div>'
      ].join(''),

      initialize: function() {
        ContainerView.prototype.initialize.apply(this, arguments);

        this.$box = $(_.template(this.template)());
        this.subnetwork_groups = {};

        // Prevent paper from handling pointerdown.
        this.$box.find('.html-element').on('mousedown click', function(evt) {
          evt.stopPropagation();
        });

        // Remove the box when the model gets removed from the graph.
        this.model.on('remove', this.removeBox, this);

        // Listen for our angular events
        $rootScope.$on("group:highlight", angular.bind(this, this.highlightSubnetGroup));
        $rootScope.$on("group:unhighlight", angular.bind(this, this.unhighlightSubnetGroups));
      },

      render: function() {
        ContainerView.prototype.render.apply(this, arguments);

        return this;
      },

      addResourceIcon: function(resource) {
        var el = $('<span></span>');

        // Show the image
        var img = $('<img src="' + resource.image + '" />');
        el.append(img);

        this.$box.append(el);
      },

      removeBox: function(evt) {
        this.$box.remove();
      }
    });
  }]);

angular.module('designer.model.resources.azure.network.application_gateway.backend_addresspool', ['designer.model.resource'])
  .factory('Azure_ApplicationGateway_BackendAddressPool', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.application_gateway.frontend_ip_configuration', ['designer.model.resource'])
  .factory('Azure_ApplicationGateway_FrontendIpConfiguration', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        resource.getPublicIpAddress = function () {
          return environment.connectedTo(this, "Resources::Azure::Network::PublicIpAddress");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.application_gateway.probe', ['designer.model.resource'])
  .factory('Azure_ApplicationGateway_Probe', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.application_gateway.request_routing_rule', ['designer.model.resource'])
  .factory('Azure_ApplicationGateway_RequestRoutingRule', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.network_interface.ip_configuration', ['designer.model.resource'])
  .factory('Azure_NetworkInterface_IpConfiguration', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function() {
          var info = {};
          return info;
        };

        resource.getVirtualMachine = function() {
          return this.getNetworkInterface().getVirtualMachine();
        };

        resource.getSubnet = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::Subnet")[0];
        };

        resource.getNetworkInterface = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface")[0];
        };

        resource.getPublicIpAddress = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::PublicIpAddress");
        };

        resource.getBackendAddressPools = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer::BackendAddressPool");
        };

        resource.getApplicationSecurityGroup = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ApplicationSecurityGroup")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.express_route_circuit.peering', ['designer.model.resource'])
  .factory('Azure_ExpressRouteCircuit_Peering', ["Resource", function(Resource) {
    return {
      load: function(resource, environment) {
        resource = Resource.load(resource, environment);
        resource.type_name = 'EXPRESS ROUTE CIRCUIT PEERING';
        resource.status_list = {
          "disabled": "stopped",
          "enabled": "good"
        };
        
        resource.info = function() {
          var info = {};

          info.express_route = resource.getExpressRoute();

          return info;
        };

        resource.getExpressRoute = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ExpressRouteCircuit")[0];
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.network_security_group.security_rule', ['designer.model.resource'])
  .factory('Azure_NetworkSecurityGroup_SecurityRule', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};
          
          return info;
        };

        resource.getAppSecurityGroups = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::ApplicationSecurityGroup");
        };

        resource.getNetworkSecurityGroup = function() {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkSecurityGroup")[0];
        };

        resource.formatSecurityRule = function() {
            // Compile it for display
          var rule_info = {};
          rule_info.name = this.name;
          rule_info.priority = this.priority;
          rule_info.action = this.access;
          rule_info.source = this.source_address_prefix == "*" ? "Any" : this.source_address_prefix;
          rule_info.destination = this.destination_address_prefix == "*" ? "Any" : this.destination_address_prefix;

          if(!rule_info.source || !rule_info.destination) {
            var app_sgs = this.getAppSecurityGroups();
            _.each(app_sgs, function(app_sg) {
              if (this.source_application_security_group_id && this.source_application_security_group_id.toLowerCase() === app_sg.provider_id)
                rule_info.app_sg_source = app_sg;
              if (this.destination_application_security_group_id && this.destination_application_security_group_id.toLowerCase() === app_sg.provider_id)
                rule_info.app_sg_destination = app_sg;
            }.bind(this));
          }
          if(this.direction == "Inbound") {
            var destination_port = this.destination_port_range ? this.destination_port_range : this.destination_port_ranges.join();
            rule_info.service = this.destination_port_range == "*" ? "Any" : this.protocol + "/" + destination_port;
          } else {
            var source_port = this.source_port_range ? this.source_port_range : this.source_port_ranges.join();
            rule_info.service = this.source_port_range == "*" ? "Any" : this.protocol + "/" + source_port;
          }

          return rule_info;
        }

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.load_balancer.backend_addresspool', ['designer.model.resource'])
  .factory('Azure_LoadBalancer_BackendAddressPool', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        resource.getNetworkInterfaceIpConfiguration = function () {
          return environment.connectedTo(this, "Resources::Azure::Network::NetworkInterface::IpConfiguration");
        };
        
        resource.getLoadBalancer = function () {
          return environment.connectedTo(this, "Resources::Azure::Network::LoadBalancer")[0];
        };

        resource.getVirtualMachines = function () {
          return environment.connectedTo(this, "Resources::Azure::Compute::VirtualMachine");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.load_balancer.frontend_ip_configuration', ['designer.model.resource'])
  .factory('Azure_LoadBalancer_FrontendIpConfiguration', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        resource.getPublicIpAddress = function () {
          return environment.connectedTo(this, "Resources::Azure::Network::PublicIpAddress");
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.load_balancer.probe', ['designer.model.resource'])
  .factory('Azure_LoadBalancer_Probe', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.load_balancer.rule', ['designer.model.resource'])
  .factory('Azure_LoadBalancer_Rule', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        return resource;
      }
    }
  }]);

angular.module('designer.model.resources.azure.network.virtual_network_gateway.ip_configuration', ['designer.model.resource'])
  .factory('Azure_VirtualNetworkGateway_IpConfiguration', ["Resource", function (Resource) {
    return {
      load: function (resource, environment) {
        resource = Resource.load(resource, environment);

        resource.info = function () {
          var info = {};

          return info;
        };

        resource.getPublicIpAddress = function () {
          return environment.connectedTo(this, "Resources::Azure::Network::PublicIpAddress");
        };

        return resource;
      }
    }
  }]);
